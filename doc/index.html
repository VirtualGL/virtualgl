<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta name="language" content="en">
<meta name="date" content="2006-12-12T14:22:16-06:00">
<meta name="generator" content="deplate.rb 0.8">
<title>VirtualGL 2.0 User&rsquo;s Guide</title>
<link rel="start" href="index.html" title="Frontpage">
<link rel="chapter" href="index.html#hd001" title="1 Legal Information">
<link rel="chapter" href="index.html#hd002" title="2 Overview">
<link rel="chapter" href="index.html#hd003" title="3 System Requirements">
<link rel="chapter" href="index.html#hd004" title="4 Installing the VirtualGL Server and Direct Mode Client on Linux">
<link rel="chapter" href="index.html#hd005" title="5 Installing the VirtualGL Server and Direct Mode Client on Solaris">
<link rel="chapter" href="index.html#hd006" title="6 Installing the VirtualGL Direct Mode Client on Windows">
<link rel="chapter" href="index.html#hd007" title="7 Using VirtualGL in Direct Mode">
<link rel="chapter" href="index.html#hd008" title="8 Securing Direct Mode">
<link rel="chapter" href="index.html#hd009" title="9 Using VirtualGL in Raw Mode with VNC and Other X Proxies">
<link rel="chapter" href="index.html#hd0010" title="10 vglrun and Solaris Shell Scripts">
<link rel="chapter" href="index.html#hd0011" title="11 GLP: Using VirtualGL Without an X Server on the Server Machine">
<link rel="chapter" href="index.html#hd0012" title="12 Using VirtualGL with Applications That Manually Load OpenGL">
<link rel="chapter" href="index.html#hd0013" title="13 Using VirtualGL with Chromium and ModViz VGP">
<link rel="chapter" href="index.html#hd0014" title="14 Other Application Recipes">
<link rel="chapter" href="index.html#hd0015" title="15 Advanced OpenGL Features">
<link rel="chapter" href="index.html#hd0016" title="16 Performance Measurement">
<link rel="chapter" href="index.html#hd0017" title="17 The VirtualGL Configuration Dialog">
<link rel="chapter" href="index.html#hd0018" title="18 Advanced Configuration">
<link rel="stylesheet" type="text/css" href="virtualgl.css" title="virtualgl">
</head>
<body >
<a name="#pagetop"></a>
<div class="title">
<p class="title">VirtualGL 2.0 User&rsquo;s Guide</p>
</div>
<a name="file000"></a>
<p><em>Intended audience:</em> System Administrators, Graphics Programmers,
Researchers, and others with knowledge of the Linux or Solaris operating
systems, OpenGL and GLX, and X windows.</p>

<div id="Table_of_Contents">
<div id="Table_of_ContentsBlock" class="toc">
<h1 class="toc">Table of Contents</h1>
<ul class="toc">
    <li class="toc">
        <a href="#hd001" class="toc">1 Legal Information</a>
    </li>
    <li class="toc">
        <a href="#hd002" class="toc">2 Overview</a>
    </li>
    <li class="toc">
        <a href="#hd003" class="toc">3 System Requirements</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd003001" class="toc">3.1 Linux/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003002" class="toc">3.2 Linux/Itanium</a>
            </li>
            <li class="toc">
                <a href="#hd003003" class="toc">3.3 Solaris/Sparc</a>
            </li>
            <li class="toc">
                <a href="#hd003004" class="toc">3.4 Solaris/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003005" class="toc">3.5 Windows</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd004" class="toc">4 Installing the VirtualGL Server and
        Direct Mode Client on Linux</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd004001" class="toc">4.1 Granting VirtualGL Access to the
                Server&rsquo;s X Display</a>
            </li>
            <li class="toc">
                <a href="#hd004002" class="toc">4.2 Automatically Starting the VirtualGL
                Client</a>
            </li>
            <li class="toc">
                <a href="#hd004003" class="toc">4.3 Uninstalling</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd005" class="toc">5 Installing the VirtualGL Server and
        Direct Mode Client on Solaris</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd005001" class="toc">5.1 Granting VirtualGL Access to the
                Server&rsquo;s X Display</a>
            </li>
            <li class="toc">
                <a href="#hd005002" class="toc">5.2 Uninstalling</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd006" class="toc">6 Installing the VirtualGL Direct Mode
        Client on Windows</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd006001" class="toc">6.1 Obtaining Optimal Performance with
                Exceed</a>
            </li>
            <li class="toc">
                <a href="#hd006002" class="toc">6.2 Secure Shell</a>
            </li>
            <li class="toc">
                <a href="#hd006003" class="toc">6.3 Installing the VirtualGL Client
                as a Windows Service</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd007" class="toc">7 Using VirtualGL in Direct Mode</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd007001" class="toc">7.1 Linux or Solaris Client</a>
            </li>
            <li class="toc">
                <a href="#hd007002" class="toc">7.2 Windows Client</a>
            </li>
            <li class="toc">
                <a href="#hd007003" class="toc">7.3 Troubleshooting</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd008" class="toc">8 Securing Direct Mode</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd008001" class="toc">8.1 Built-In SSL Encryption</a>
            </li>
            <li class="toc">
                <a href="#hd008002" class="toc">8.2 Direct Mode over SSh</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd009" class="toc">9 Using VirtualGL in Raw Mode with VNC
        and Other X Proxies</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd009001" class="toc">9.1 TurboVNC</a>
            </li>
            <li class="toc">
                <a href="#hd009002" class="toc">9.2 Enabling Raw Mode</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0010" class="toc">10 vglrun and Solaris Shell Scripts</a>
    </li>
    <li class="toc">
        <a href="#hd0011" class="toc">11 GLP: Using VirtualGL Without an X
        Server on the Server Machine</a>
    </li>
    <li class="toc">
        <a href="#hd0012" class="toc">12 Using VirtualGL with Applications
        That Manually Load OpenGL</a>
    </li>
    <li class="toc">
        <a href="#hd0013" class="toc">13 Using VirtualGL with Chromium and
        ModViz VGP</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0013001" class="toc">13.1 Configuration 1: Sort-First Rendering
                (Image-Space Decomposition)</a>
            </li>
            <li class="toc">
                <a href="#hd0013002" class="toc">13.2 Configuration 2: Sort-First Rendering
                (Image-Space Decomposition) with Readback</a>
            </li>
            <li class="toc">
                <a href="#hd0013003" class="toc">13.3 Configuration 3: Sort-Last Rendering
                (Object-Space Decomposition)</a>
            </li>
            <li class="toc">
                <a href="#hd0013004" class="toc">13.4 A Note About Performance</a>
            </li>
            <li class="toc">
                <a href="#hd0013005" class="toc">13.5 ModViz VGP and VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0014" class="toc">14 Other Application Recipes</a>
    </li>
    <li class="toc">
        <a href="#hd0015" class="toc">15 Advanced OpenGL Features</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0015001" class="toc">15.1 Stereo</a>
            </li>
            <li class="toc">
                <a href="#hd0015002" class="toc">15.2 Transparent Overlays</a>
            </li>
            <li class="toc">
                <a href="#hd0015003" class="toc">15.3 Indexed (PseudoColor) Rendering</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0016" class="toc">16 Performance Measurement</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0016001" class="toc">16.1 VirtualGL&rsquo;s Built-In Profiling
                System</a>
            </li>
            <li class="toc">
                <a href="#hd0016002" class="toc">16.2 Frame Spoiling</a>
            </li>
            <li class="toc">
                <a href="#hd0016003" class="toc">16.3 VirtualGL Diagnostic Tools</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0017" class="toc">17 The VirtualGL Configuration Dialog</a>
    </li>
    <li class="toc">
        <a href="#hd0018" class="toc">18 Advanced Configuration</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0018001" class="toc">18.1 Server Settings</a>
            </li>
            <li class="toc">
                <a href="#hd0018002" class="toc">18.2 Client Settings</a>
            </li>
        </ul>
    </li>
</ul>
</div></div>
<hr class="break" />


<h1 id="hd001"><a name="file001"></a>1&nbsp;Legal Information</h1>

<p><img src="somerights20.png" alt="somerights20" class="inline" id="imgid_0" name="imgid_0"/></p>

<p>This document and all associated illustrations are licensed under the
<span class="remote"><a href="http://creativecommons.org/licenses/by/2.5/" class="remote">Creative
Commons Attribution 2.5 License</a></span><a name="idx001"></a>.  Any
works which contain material derived from this document must cite The
VirtualGL Project as the source of the material and list the current
URL for the VirtualGL web-site.</p>

<p>This product includes software developed by the OpenSSL Project for
use in the OpenSSL Toolkit (<a href="http://www.openssl.org/">http://www.openssl.org/</a>.)
Further information is contained in
<a href="LICENSE-OpenSSL.txt"><code>LICENSE-OpenSSL.txt</code></a><a name="idx002"></a>,
which can be found in the same directory as this documentation.</p>

<p>VirtualGL is licensed under the <a href="LICENSE.txt">wxWindows Library
License, v3</a><a name="idx003"></a>, a derivative of the
<a href="LGPL.txt">LGPL</a><a name="idx004"></a>.</p>

<hr class="break" />


<h1 id="hd002"><a name="file002"></a>2&nbsp;Overview</h1>

<p><a name="Overview"></a></p>

<p>VirtualGL is an open source package which provides hardware-accelerated
3D rendering capabilities to thin clients.  Normally, when you run
a Unix or Linux OpenGL application inside a thin client environment
(such as VNC, remote X11, NX, etc.), the 3D application either does
not work at all, is forced to use a slow software 3D renderer, or (worse)
is forced to send every 3D command and piece of 3D data over the network
to be rendered on the client machine. With VirtualGL, the OpenGL commands
from the application are redirected onto a dedicated server&rsquo;s
3D accelerator hardware.  The resulting rendered images are then read
back from the 3D hardware and composited into the appropriate window
on the user&rsquo;s desktop.  This produces a completely seamless shared
3D environment that performs fast enough to take the place of a dedicated
3D workstation.</p>

<p>VirtualGL has two basic modes of operation:</p>

<p><a name="Direct_Mode"></a></p>

<dl class="Description">
    <dt class="Description">1. &ldquo;Direct&rdquo; Mode</dt>
    <dd class="Description">
        Direct Mode requires an X server to be running on the client machine.
        This X server processes X11 commands from the application in order
        to render the non-OpenGL (2D) elements of the application&rsquo;s user
        interface.  The X server also feeds X11 input events (key, mouse, window
        resize, etc.) back to the application.  Meanwhile, VirtualGL intercepts
        the GLX calls from the application and modifies these calls such that
        they are sent to the server&rsquo;s X server rather than the client&rsquo;s.
        VirtualGL also modifies the GLX calls such that the OpenGL contexts
        are created in off- creen Pbuffers instead of X windows.  When an end-of-frame
        trigger is detected (such as <code>glXSwapBuffers()</code>), VirtualGL
        reads back the rendered 3D images from the server&rsquo;s framebuffer,
        compresses them using a high-speed image codec, and sends the compressed
        images on a separate socket to the client.  A separate VirtualGL Client
        application runs on the client machine, and this client application
        decompresses the image stream from the server and composites it into
        the appropriate X window.  Direct Mode is the fastest solution for
        running VirtualGL on a local area network, and it provides the same
        usability as running the application locally.  Direct Mode is typically
        used to run data-intensive OpenGL applications in a &ldquo;cold room&rdquo;
        and remotely interact with these applications from a laptop or a slim
        PC located elsewhere in the same building/campus.  Such big data applications
        often exceed the capabilities of a single PC (particularly a 32-bit
        PC), and the data sizes are large enough that transmitting the data
        across even the fastest of local area networks is impractical.
    </dd>
</dl>

<div class="figure">
<img src="virtualgl.png" alt="virtualgl" class="figure" id="imgid_13" name="imgid_13"/>
</div>

<p><a name="Raw_Mode"></a></p>

<dl class="Description">
    <dt class="Description">2. &ldquo;Raw&rdquo; or &ldquo;Proxy&rdquo; Mode</dt>
    <dd class="Description">
        In this mode, there is no X server running on the client machine. 
        The 2D rendering is instead performed on the server machine by an &ldquo;X
        Proxy,&rdquo; which can be one of any number of Unix thin client applications,
        such as VNC.  These X proxies act as normal X servers, except that
        they perform X11 rendering to a virtual desktop in the server&rsquo;s
        memory rather than to a real framebuffer.  Changes to regions of the
        virtual desktop are compressed as image tiles and sent to any connected
        clients.  As with Direct Mode, VirtualGL intercepts the GLX calls from
        the application, redirects the calls to the server&rsquo;s X server,
        and modifies them such that OpenGL rendering occurs in Pbuffers instead
        of X windows.  VirtualGL also reads back the rendered images, as with
        Direct Mode.  But in Raw Mode, VirtualGL does not perform any image
        compression.  It instead draws the rendered 3D images into the X proxy
        as uncompressed 2D bitmaps, thus relying on the X proxy to compress
        the images and send them to the client.  Raw Mode, in combination with
        TurboVNC, is the fastest solution for running VirtualGL on a wide area
        network (broadband, T1, etc.), and it provides rudimentary built-in
        collaboration capabilities.  But whereas Direct Mode can mimic the
        behavior of running the application locally, VNC requires the user
        to interact with the entire remote desktop in a single window and thus
        does not provide the same user experience as running the application
        locally.  Raw Mode is typically used to run data-intensive 3D applications
        in a &ldquo;cold room&rdquo; and remotely interact with these applications
        from a PC located in another city.
    </dd>
</dl>

<div class="figure">
<img src="idealx11proxy.png" alt="idealx11proxy" class="figure" id="imgid_14" name="imgid_14"/>
</div>

<hr class="break" />


<h1 id="hd003"><a name="file003"></a>3&nbsp;System Requirements</h1>


<h2 id="hd003001">3.1&nbsp;Linux/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (32-bit)</th>
    <th class="head standard">Server (64-bit)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4, 1.7 GHz or faster (or equivalent) <ul class="Itemize"><li>
    For optimal performance, the processor should support SSE2 extensions.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li>
    For optimal performance with 64-bit VirtualGL, the processor should
    support SSE3 extensions.  Only newer AMD 64-bit processors (mid-2005
    and later) support SSE3.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Decent 3D graphics accelerator <ul class="Itemize"><li>
    nVidia strongly recommended
</li>
<li>
    Pbuffers do not work on certain ATI adapters when drivers later than
    v8.14 are used.  If you encounter this problem, try driver v8.14 or
    older.
</li>
<li>
    For applications that use stereo, a high-end 3D accelerator such as
    the nVidia Quadro is required on the server.
</li>
<li>
    Install the vendor drivers for your 3D accelerator of choice. Do not
    use the drivers that ship with Linux, as these do not provide 3D acceleration.
</li></ul></td>
    <td class="standard">Decent 3D graphics accelerator <ul class="Itemize"><li>
    nVidia strongly recommended
</li>
<li>
    Pbuffers do not work on certain ATI adapters when drivers later than
    v8.14 are used.  If you encounter this problem, try driver v8.14 or
    older.
</li>
<li>
    For applications that use stereo, a high-end 3D accelerator such as
    the nVidia Quadro is required on the server.
</li>
<li>
    Install the vendor drivers for your 3D accelerator of choice. Do not
    use the drivers that ship with Linux, as these do not provide 3D acceleration.
</li></ul></td>
    <td class="standard">Graphics card with decent 2D performance <ul class="Itemize"><li>
    For applications that use stereo or transparent overlays, a high-end
    3D accelerator such as the nVidia Quadro is required on the client.
</li>
<li>
    If using a 3D accelarator, install the vendor drivers for that 3D accelerator.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Recommended O/S</td>
    <td class="standard"><ul class="Itemize"><li>
    RedHat Linux 7.2 or newer (or equivalent), or
</li>
<li>
    SuSE Linux 9 or newer
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    RedHat Enterprise Linux 3.0 or 4.0 (64-bit) or equivalent (Works with
    <span class="remote"><a href="http://www.whiteboxlinux.org" class="remote">WhiteBox</a></span><a name="idx005"></a>,
    and
    <span class="remote"><a href="http://www.centos.org" class="remote">CentOS</a></span><a name="idx006"></a>),
    or
</li>
<li>
    SuSE Linux 9 or newer
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    RedHat Linux 7.2 or newer (or equivalent), or
</li>
<li>
    SuSE Linux 9 or newer
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard">X server configured for true color (24/32-bit)</td>
    <td class="standard">X server configured for true color (24/32-bit)</td>
    <td class="standard">X server configured for true color (24/32-bit)</td>
  </tr>
</table>
</div>



<h2 id="hd003002">3.2&nbsp;Linux/Itanium</h2>

<p>VirtualGL should build and run on Itanium Linux, but it has not been
thoroughly tested. 
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">Contact
us</a></span><a name="idx007"></a> if you encounter any difficulties.</p>


<h2 id="hd003003">3.3&nbsp;Solaris/Sparc</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (32/64-bit)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">UltraSPARC III 900 MHz or faster <ul class="Itemize"><li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">UltraSPARC III 900 MHz or faster</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Decent 3D graphics accelerator <ul class="Itemize"><li>
    Tested with
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr600/" class="remote">XVR-600</a></span><a name="idx008"></a>,
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr1200/" class="remote">XVR-1200</a></span><a name="idx009"></a>
    (&ldquo;jfb&rdquo;), and
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0010"></a>
    (&ldquo;kfb&rdquo;)
</li>
<li>
    XVR-2500 required for stereo rendering
</li></ul> <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun OpenGL</a></span><a name="idx0011"></a> <ul class="Itemize"><li>
    1.3 or later required
</li>
<li>
    1.5 or later required for stereo rendering or
    <a href="#GLP_Usage">GLP</a><a name="idx0012"></a> and recommended
    otherwise.  OpenGL 1.5 is part of Solaris 10 Update 1 and is also bundled
    with the XVR-2500.
</li></ul></td>
    <td class="standard">Graphics card with decent 2D performance <ul class="Itemize"><li>
    For applications that use stereo or transparent overlays, a high-end
    3D accelerator such as the XVR-1200 or XVR-2500 is required on the
    client.
</li></ul> <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun OpenGL</a></span><a name="idx0013"></a> <ul class="Itemize"><li>
    OpenGL 1.3 or later recommended if the client has a 3D accelerator
    installed, such as the XVR-1200.  If available, the VirtualGL Direct
    Mode client will draw images using OpenGL, which improves the client&rsquo;s
    performance on some Sun 3D accelerators.
</li>
<li>
    OpenGL 1.3 or later required if stereo or transparent overlays are
    to be used.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Solaris 8 or higher</td>
    <td class="standard">Solaris 8 or higher</td>
  </tr>
  <tr class="standard">
    <td class="high standard"><span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patches</a></span><a name="idx0014"></a></td>
    <td class="standard"><ul class="Itemize"><li>
    <em>OpenGL 1.5:</em>  120812-12 or 120812-14 (or later) required for
    stereo rendering.  Recommended otherwise
</li>
<li>
    <em>XVR-2500 (&ldquo;kfb&rdquo;) Drivers:</em> 120928-10 (or later)
    required for stereo rendering.  Recommended otherwise
</li>
<li>
    <em>OpenGL 1.3, 32-bit:</em> 113886-38 or 113886-41 (or later) recommended
</li>
<li>
    <em>OpenGL 1.3, 64-bit:</em> 113887-38 or 113887-41 (or later) recommended
</li></ul></td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0015"></a>
</li>
<li>
    If your system does not ship with SSh pre-installed (older Solaris
    8 systems don&rsquo;t), then download and install an OpenSSh package
    from
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0016"></a>
    or <a href="http://www.sunfreeware.com/.">http://www.sunfreeware.com/.</a>
</li>
<li>
    X server configured for true color (24/32-bit) [if not using
    <a href="#GLP_Usage">GLP</a><a name="idx0017"></a>]
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0018"></a>
</li>
<li>
    If your system does not ship with SSh pre-installed (older Solaris
    8 systems don&rsquo;t), then download and install an OpenSSh package
    from
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0019"></a>
    or <a href="http://www.sunfreeware.com/.">http://www.sunfreeware.com/.</a>
</li>
<li>
    X server configured for true color (24/32-bit)
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003004">3.4&nbsp;Solaris/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (32-bit)</th>
    <th class="head standard">Server (64-bit)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4, 1.7 GHz or faster (or equivalent) <ul class="Itemize"><li>
    For optimal performance, the processor should support SSE2 extensions.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">nVidia 3D graphics accelerator <ul class="Itemize"><li>
    For applications that use stereo, a high-end 3D accelerator such as
    the nVidia Quadro is required on the server.
</li></ul></td>
    <td class="standard">nVidia 3D graphics accelerator <ul class="Itemize"><li>
    For applications that use stereo, a high-end 3D accelerator such as
    the nVidia Quadro is required on the server.
</li></ul></td>
    <td class="standard">Graphics card with decent 2D performance <ul class="Itemize"><li>
    For applications that use stereo or transparent overlays, a high-end
    3D accelerator such as the nVidia Quadro is required on the client.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Solaris 10 or higher</td>
    <td class="standard">Solaris 10 or higher</td>
    <td class="standard">Solaris 10 or higher</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0020"></a> (v2.4 or higher recommended)
</li>
<li>
    X server configured for true color (24/32-bit)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0021"></a> (v2.4 or higher recommended)
</li>
<li>
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Solaris
    Patch</a></span><a name="idx0022"></a> 18345-04 (or later)
</li>
<li>
    X server configured for true color (24/32-bit)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0023"></a> (v2.4 or higher recommended)
</li>
<li>
    X server configured for true color (24/32-bit)
</li></ul></td>
  </tr>
</table>
</div>


<div class="important"><p class="important">
Solaris 10/x86 comes with mediaLib pre-installed, but it is strongly recommended that you upgrade this version of mediaLib to at least 2.4.  This will greatly increase the performance of Solaris/x86 VirtualGL clients as well as the performance of 32-bit apps on Solaris/x86 VirtualGL servers.
</p></div>


<h2 id="hd003005">3.5&nbsp;Windows</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Graphics card with decent 2D performance <ul class="Itemize"><li>
    For applications that use stereo or transparent overlays, a high-end
    3D accelerator such as the nVidia Quadro or 3DLabs Wildcat Realizm
    is required on the client.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Windows 2000 or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    If Direct Mode is to be used,
    <span class="remote"><a href="http://www.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0024"></a>
    Exceed 8 or newer is required on the client machine.<br /><br /> <em>Contact
    Gary Romualdez of Hummingbird Ltd. [tel. (416) 496-6393 or
    <script type="text/javascript"><!--
    document.write(String.fromCharCode(60,97,32,104,114,101,102,61,34,109,97,105,108,116,111,58,103,97,114,121,46,114,111,109,117,97,108,100,101,122,64,104,117,109,109,105,110,103,98,105,114,100,46,99,111,109,34,62,103,97,114,121,46,114,111,109,117,97,108,100,101,122,64,104,117,109,109,105,110,103,98,105,114,100,46,99,111,109,60,47,97,62))
    --></script><noscript>gary DOT romualdez AT hummingbird DOT com</noscript>]
    for Exceed pricing information.</em>
</li>
<br />
<li>
    For applications that use stereo or transparent overlays, Exceed 3D
    is required on the client.
</li>
<li>
    Client desktop needs to be configured for true color (24 or 32-bit.)
</li></ul></td>
  </tr>
</table>
</div>


<hr class="break" />


<h1 id="hd004"><a name="file004"></a>4&nbsp;Installing the VirtualGL Server and Direct Mode Client on Linux</h1>

<div class="important"><p class="important">
Installing the VirtualGL package is necessary on any Linux machine that will act as a VirtualGL server or as a VirtualGL <a href="#Direct_Mode">Direct Mode</a><a name="idx0025"></a>	client.  It is not necessary to install VirtualGL on the client machine if <a href="#Raw_Mode">Raw Mode</a><a name="idx0026"></a> is to be used.
</p></div>


<h3 id="hd004000001">Installing TurboJPEG</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Obtain the latest TurboJPEG RPM from the &ldquo;Files&rdquo; area of
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">http://sourceforge.net/projects/virtualgl</a></span><a name="idx0027"></a>.
        <div class="important"><p class="important">
        .tgz packages are provided for users of non-RPM platforms.  You can use <span class="remote"><a href="http://www.kitenet.net/programs/alien/" class="remote">alien</a></span><a name="idx0028"></a> to convert these into .deb packages if you prefer.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-Uvh&nbsp;turbojpeg*.rpm
</pre>

    </li>
</ol>


<h3 id="hd004000002">Installing VirtualGL</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        If you are using RedHat/CentOS Enterprise Linux 2.1, 3, or 4 or SuSE
        Linux 9, obtain one of the pre-built VirtualGL RPMs from the files
        area of
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">http://sourceforge.net/projects/virtualgl</a></span><a name="idx0029"></a>.
        <br /><br /> The Enterprise Linux 2.1 RPM should (theoretically) also
        work with RedHat Linux 7.2 and 7.3 (and maybe 7.1 if patched.)<br />
        The Enterprise Linux 3 RPM should (theoretically) also work with RedHat
        Linux 8 (patched), RedHat Linux 9, and Fedora Core 1 &amp; 2.<br />
        The Enterprise Linux 4 RPM should (theoretically) also work with Fedora
        Core 3 &amp; 4.<br /> The SuSE Linux 9 RPM should (theoretically) also
        work with SuSE 10.
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-Uvh&nbsp;VirtualGL*.rpm
</pre>

    </li>
</ol>


<h3 id="hd004000003">Installing VirtualGL from Source</h3>

<p>If you are using an RPM-based distribution of Linux but there isn&rsquo;t
a pre-built VirtualGL RPM that matches your distribution, then you
can build your own RPM using the VirtualGL Source RPM (SRPM.)</p>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Obtain the VirtualGL SRPM from the files area of
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">http://sourceforge.net/projects/virtualgl</a></span><a name="idx0030"></a>.
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the SRPM,
        and issue the following commands:
<pre class="verbatim">
rpm&nbsp;-i&nbsp;VirtualGL*.src.rpm
cd&nbsp;/usr/src/redhat/SPECS
rpmbuild&nbsp;-ba&nbsp;virtualgl.spec
</pre>

        <div class="important"><p class="important">
        On SuSE, cd to <code>/usr/src/packages/SPECS</code> instead.  Some versions of SuSE symlink this to <code>/usr/src/redhat/SPECS</code>.
        </p></div>
    </li>
    <li class="Ordered" value="3">
        Sit back and watch the fun.
    </li>
    <li class="Ordered" value="4">
        If the build completes successfully, it will produce a binary RPM in
        <code>/usr/src/redhat/RPMS/{your_cpu_architecture}</code> (or <code>/usr/src/packages/RPMS/{your_cpu_architecture})</code>,
        which you can install using the instructions from the previous section.
    </li>
</ol>

<p>If you are using a non-RPM based distribution of Linux, then log in
as root, download the VirtualGL source tarball from the files area
of
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">http://sourceforge.net/projects/virtualgl</a></span><a name="idx0031"></a>,
uncompress it, <code>cd&nbsp;vgl</code>, and type <code>make&nbsp;install</code>.
Refer to <code>BUILDING.txt</code> in the source directory for further
details.</p>


<h3 id="hd004000004">NVidia driver permissions</h3>

<p>If installing VirtualGL on a server which is running version 1.0-71xx
or earlier of the NVidia accelerated GLX drivers, follow the instructions
in <code>/usr/share/doc/NVIDIA_GLX-1.0/README</code> regarding setting
the appropriate permissions for <code>/dev/nvidia*</code>.  This is
not necessary with more recent versions of the driver.  <code>cat&nbsp;/proc/driver/nvidia/version</code>
to determine which version of the NVidia driver is installed on your
system.</p>


<h2 id="hd004001">4.1&nbsp;Granting VirtualGL Access to the Server&rsquo;s X Display</h2>

<p>VirtualGL requires access to the server&rsquo;s 3D graphics card so
that it can create off-screen pixel buffers (Pbuffers) and redirect
the 3D rendering from applications into these Pbuffers.  Unfortunately,
accessing a 3D graphics card on Linux currently requires going through
an X server.  So the only way to share the server’s 3D graphics resources
among multiple users is to grant those users display access to the
X server that is running on the shared 3D graphics card.</p>

<p>It is important to understand the security risks associated with this.
Once X display access is granted to a user, there is nothing preventing
that user from logging keystrokes or reading back images from the X
display.  Using <code>xauth</code>, one can obtain “untrusted” X authentication
keys which prevent such exploits, but unfortunately, those untrusted
keys also disallow access to the 3D hardware.  So it is necessary to
grant full trusted X access to any users that will need to run VirtualGL.
Unless you fully trust the users to whom you are granting this access,
you should avoid logging in locally to the server’s X display as root
unless absolutely necessary.  Even then, it’s probably a good idea
to make sure that there are no suspicious-looking processes running
on the system prior to logging in.</p>

<p>This section will explain how to configure a VirtualGL server such
that select users can run VirtualGL, even if the server is sitting
at the login prompt. The basic idea is to call a script (<code>vglgenkey</code>)
from the display manager&rsquo;s startup script.  <code>vglgenkey</code>
invokes <code>xauth</code> to generate an authorization key for the
server&rsquo;s X display, and it stores this key under <code>/etc/opt/VirtualGL</code>.
The VirtualGL launcher script (<code>vglrun</code>) then attempts to
read this key and merge it into the user&rsquo;s <code>.Xauthority</code>
file, thus granting the user access to the server&rsquo;s X display.
Therefore, you can control who has access to the server&rsquo;s X display
simply by controlling who has read access to the <code>/etc/opt/VirtualGL</code>
directory.</p>

<p>If you prefer, you can also grant access to every authenticated user
on the server by replacing the references to <code>vglgenkey</code>
below with <code>xhost&nbsp;+localhost</code>.</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        If the server machine is configured to boot into runlevel 5 (graphical
        login), then temporarily shut down its X server by issuing
<pre class="verbatim">
init&nbsp;3
</pre>

        as root
    </li>
    <li class="Ordered">
        Log in as root from the text console.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        Create a new directory <code>/etc/opt/VirtualGL</code> and make it
        readable by the <code>vglusers</code> group, e.g.:
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/opt/VirtualGL
chgrp&nbsp;vglusers&nbsp;/etc/opt/VirtualGL
chmod&nbsp;750&nbsp;/etc/opt/VirtualGL
</pre>

    </li>
    <li class="Ordered">
        If the server machine is configured to boot into runlevel 3 (text login),
        then configure it to boot into a graphical login by changing the first
        line of <code>/etc/inittab</code> from<br /> <br />
        <code>id:3:initdefault:</code><br /> <br /> to<br /> <br /> <code>id:5:initdefault:</code>
    </li>
    <li class="Ordered">
        Add
<pre class="verbatim">
vglgenkey
</pre>

        at the top of the display manager&rsquo;s startup script.  The location
        of this script varies depending on the particular Linux distribution
        and display manager being used.  The following table lists some common
        locations for this file: <br /><br />
        <div class="table">
        <table class="standard" align="center">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard"></th>
            <th class="head standard">xdm or kdm</th>
            <th class="head standard">gdm<br /><sub>(default display manager on most Linux systems)</sub></th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="high standard">RedHat 7/8/9<br />Enterprise Linux 2.1/3</td>
            <td class="standard"><code>/etc/X11/xdm/Xsetup_0</code><br /> <br /> (replace &ldquo;0&rdquo; with the display number of the X server you are configuring)</td>
            <td class="standard"><code>/etc/X11/gdm/Init/Default</code><br /> <br /> (usually this is just symlinked to <code>/etc/X11/xdm/Xsetup_0</code>)</td>
          </tr>
          <tr class="standard">
            <td class="high standard">Enterprise Linux 4<br />Fedora Core 1/2/3</td>
            <td class="standard"><code>/etc/X11/xdm/Xsetup_0</code><br /> <br /> (replace &ldquo;0&rdquo; with the display number of the X server you are configuring)</td>
            <td class="standard"><code>/etc/X11/gdm/Init/:0</code><br /> <br /> (usually this is just symlinked to <code>/etc/X11/xdm/Xsetup_0</code>)</td>
          </tr>
          <tr class="standard">
            <td class="high standard">SuSE/United Linux</td>
            <td class="standard"><code>/etc/X11/xdm/Xsetup</code></td>
            <td class="standard"><code>/etc/opt/gnome/gdm/Init/Default</code></td>
          </tr>
        </table>
        </div>
        
    </li>
    <li class="Ordered">
        If the server is running gdm (the factory default on most Linux systems),
        then you&rsquo;ll need to set up gdm to allow TCP connections to the
        X server. To do this, edit the <code>gdm.conf</code> file and add the
        following line under the <code>[security]</code> section (or change
        it if it already exists):
<pre class="verbatim">
DisallowTCP=false
</pre>

        See the table below for the location of gdm.conf on various systems.
    </li>
    <li class="Ordered">
        Unless you know that you absolutely need it, disable the XTEST extension.
        Disabling XTEST will not prevent a user from logging keystrokes or
        reading images from the X display, but it will prevent them from inserting
        key and mouse events and thus hijacking a local X session.<br />
        <br /> Disabling XTEST is accomplished by passing an argument of <code>-tst</code>
        on the command line used to launch the X server.  The location of this
        command line varies depending on the particular Linux distribution
        and display manager being used.   The following table lists some common
        locations:<br /> <br />
        <div class="table">
        <table class="standard" align="center">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard"></th>
            <th class="head standard">xdm</th>
            <th class="head standard">gdm<br /><sub>(default on most Linux systems)</sub></th>
            <th class="head standard">kdm</th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="high standard">RedHat (or equivalent)</td>
            <td class="standard"><code>/etc/X11/xdm/Xservers</code></td>
            <td class="standard"><code>/etc/X11/gdm/gdm.conf</code></td>
            <td class="standard"><code>/etc/X11/xdm/Xservers</code></td>
          </tr>
          <tr class="standard">
            <td class="high standard">SuSE/United Linux</td>
            <td class="standard"><code>/etc/X11/xdm/Xservers</code></td>
            <td class="standard"><code>/etc/opt/gnome/gdm/gdm.conf</code></td>
            <td class="standard"><code>/etc/opt/kde3/share/config/kdm/Xservers</code></td>
          </tr>
        </table>
        </div>
        
        <br /> For xdm-style configuration files, add <code>-tst</code> to
        the line corresponding to the display number you are configuring, e.g.:
<pre class="verbatim">
:0&nbsp;local&nbsp;/usr/X11R6/bin/X&nbsp;:0&nbsp;vt07&nbsp;-tst
</pre>

        For gdm-style configuration files, add <code>-tst</code> to all lines
        that appear to be X server command lines, e.g.:
<pre class="verbatim">
StandardXServer=/usr/X11R6/bin/X&nbsp;-tst
</pre>

<pre class="verbatim">
[server-Standard]
command=/usr/X11R6/bin/X&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

<pre class="verbatim">
[server-Terminal]
command=/usr/X11R6/bin/X&nbsp;-tst&nbsp;-audit&nbsp;0&nbsp;-terminate
</pre>

<pre class="verbatim">
[server-Chooser]
command=/usr/X11R6/bin/X&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

    </li>
    <li class="Ordered">
        Restart the X server by issuing
<pre class="verbatim">
init&nbsp;5
</pre>

        as root.
    </li>
    <li class="Ordered">
        You can check your work by running
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
xdpyinfo&nbsp;-display&nbsp;:0
</pre>

        In particular, make sure that XTEST doesn&rsquo;t show up in the list
        of extensions if you disabled it above.  If <code>xdpyinfo</code> fails
        to run, then the permissions on Display :0 are probably still too restrictive,
        meaning that the change in Step 6 didn&rsquo;t take for some reason.
    </li>
</ol>


<h2 id="hd004002">4.2&nbsp;Automatically Starting the VirtualGL Client</h2>

<p>The VirtualGL Direct Mode client for Linux can be configured to start
automatically whenever an X Windows session starts.  To do this, run</p>

<pre class="verbatim">
vglclient_config&nbsp;-install
</pre>

<p>as root.</p>

<p>Depending on your system configuration, this script will either tweak
the <code>/etc/X11/xinit/xinitrc</code> file or create a link in <code>/etc/X11/xinit/xinitrc.d</code>
so that the VirtualGL client will be automatically started whenever
any X Windows session is started.  Running <code>vglclient_config&nbsp;-install</code>
also adds a line to <code>/etc/X11/gdm/PostSession/Default</code> (or
the equivalent for your system) to terminate the client whenever you
log out of the X Windows session.  This is known to work on RedHat-
and SuSE-compatible platforms that use the Gnome Display Manager (gdm.)
It probably won&rsquo;t work on other distributions and display managers.</p>

<p>To remove the auto-start feature, run</p>

<pre class="verbatim">
vglclient_config&nbsp;-remove
</pre>

<p>as root.</p>

<p>If <code>vglclient_config</code> doesn&rsquo;t work on your system,
then you can edit the appropriate X11 session files so that</p>

<pre class="verbatim">
/usr/bin/vglclient_daemon&nbsp;start
</pre>

<p>runs whenever an X session starts and</p>

<pre class="verbatim">
/usr/bin/vglclient_daemon&nbsp;stop
</pre>

<p>runs whenever the session terminates.</p>

<p><code>vglclient_daemon</code> will only start <code>vglclient</code>
if it is not already running, so starting the client in this manner
guarantees that there will never be more than one copy of it running
on the system.  <code>vglclient_daemon</code> should work on any Linux
platform that conforms to the Linux Standard Base (LSB.)</p>

<p>If additional X displays are started by the same user (:1, :2, etc.),
this will not cause additional VirtualGL client instances to start.
Only one VirtualGL client instance is needed to talk to all active
displays.  However, it is important to note that all active displays
on the client machine need to be running under the same user privileges
as the VirtualGL client, or they need to grant permissions to localhost
(<code>xhost&nbsp;+localhost</code>) so that the VirtualGL client can
access them.</p>

<p>If you wish to change the default port that the client listens on,
you will need to edit <code>/usr/bin/vglclient_daemon</code> and pass
the appropriate argument (<code>-port&nbsp;&lt;port&nbsp;number&gt;</code>
or <code>-sslport&nbsp;&lt;port&nbsp;number&gt;</code>) on the <code>vglclient</code>
command line located in that file.  By default, the client will listen
on port 4242 for unencrypted connections and port 4243 for SSL connections.</p>


<h2 id="hd004003">4.3&nbsp;Uninstalling</h2>

<p>As root, issue the following command:</p>

<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
</pre>

<hr class="break" />


<h1 id="hd005"><a name="file005"></a>5&nbsp;Installing the VirtualGL Server and Direct Mode Client on Solaris</h1>

<div class="important"><p class="important">
Installing the VirtualGL package is necessary on any Solaris machine that will act as a VirtualGL server or as a VirtualGL <a href="#Direct_Mode">Direct Mode</a><a name="idx0032"></a>	client.  It is not necessary to install VirtualGL on the client machine if <a href="#Raw_Mode">Raw Mode</a><a name="idx0033"></a> is to be used.
</p></div>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Obtain the latest VirtualGL package from the files area of
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">http://sourceforge.net/projects/virtualgl</a></span><a name="idx0034"></a>.
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the package,
        and issue the following commands:
<pre class="verbatim">
bzip2&nbsp;-d&nbsp;SUNWvgl-{version}.pkg.bz2
pkgadd&nbsp;-d&nbsp;SUNWvgl-{version}.pkg
</pre>

    </li>
    <li class="Ordered" value="3">
        Select the <code>SUNWvgl</code> package (usually option 1) from the
        menu.
    </li>
</ol>
<div class="important"><p class="important">
VirtualGL for Solaris installs into <code>/opt/SUNWvgl</code>.
</p></div>


<h3 id="hd005000001">Device Permissions</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Edit <code>/etc/logindevperm</code> and comment out the &ldquo;frame
        buffers&rdquo; line, e.g.:
<pre class="verbatim">
#&nbsp;/dev/console&nbsp;&nbsp;&nbsp;&nbsp;0600&nbsp;&nbsp;&nbsp;&nbsp;/dev/fbs/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;frame&nbsp;buffers
</pre>

    </li>
    <li class="Ordered" value="2">
        Change the permissions and group for <code>/dev/fbs/*</code> to allow
        write access to anyone who will need to use VirtualGL, e.g.:
<pre class="verbatim">
chmod&nbsp;660&nbsp;/dev/fbs/*
chown&nbsp;root&nbsp;/dev/fbs/*
chgrp&nbsp;vglusers&nbsp;/dev/fbs/*
</pre>

    </li>
</ol>
<div class="important"><p class="important">
Explanation: Normally, when someone logs into a Solaris machine, the system will automatically assign ownership of the framebuffer devices to that user and set the permissions for the framebuffer devices to those specified in <code>/etc/logindevperm</code>.  The default setting in <code>/etc/logindevperm</code> disallows anyone from using the framebuffer devices except the user that is logged in.  But in order to run VirtualGL, a user needs write access to the framebuffer devices.  So in order to make the framebuffer a shared resource, it is necessary to disable the login device permissions mechanism for the framebuffer devices and manually set the owner and group for these devices such that any VirtualGL users can write to them.
</p></div>


<h3 id="hd005000002">Other</h3>

<p>The server&rsquo;s SSh daemon should have the <code>X11Forwarding</code>
option enabled.  This is configured in <code>sshd_config</code>, the
location of which varies depending on your distribution of SSh.  Solaris
10 generally keeps this in <code>/etc/ssh</code>, whereas Blastwave
keeps it in <code>/opt/csw/etc</code> and SunFreeware keeps it in <code>/usr/local/etc</code>.</p>


<h2 id="hd005001">5.1&nbsp;Granting VirtualGL Access to the Server&rsquo;s X Display</h2>

<div class="important"><p class="important">
If you plan to use VirtualGL only in <a href="#GLP_Usage">GLP</a><a name="idx0035"></a> mode, then you can skip this section.
</p></div>

<p>VirtualGL requires access to the server&rsquo;s 3D graphics card so
that it can create off-screen pixel buffers (Pbuffers) and redirect
the 3D rendering from applications into these Pbuffers.  Unfortunately,
accessing a 3D graphics card on Solaris/x86 systems or on Solaris/Sparc
systems without <a href="#GLP_Usage">GLP</a><a name="idx0036"></a>
requires going through an X server.  On such systems, the only way
to share the server&rsquo;s 3D graphics resources among multiple users
is to grant those users display access to the X server that is running
on the shared 3D graphics card.</p>

<p>It is important to understand the security risks associated with this.
Once X display access is granted to a user, there is nothing preventing
that user from logging keystrokes or reading back images from the X
display.  Using <code>xauth</code>, one can obtain &ldquo;untrusted&rdquo;
X authentication keys which prevent such exploits, but unfortunately,
those untrusted keys also disallow access to the 3D hardware.  So it
is necessary to grant full trusted X access to any users that will
need to run VirtualGL.  Unless you fully trust the users to whom you
are granting this access, you should avoid logging in locally to the
server&rsquo;s X display as root unless absolutely necessary.  Even
then, it&rsquo;s probably a good idea to make sure that there are no
suspicious-looking processes running on the system prior to logging
in.</p>

<p>This section will explain how to configure a VirtualGL server such
that select users can run VirtualGL, even if the server is sitting
at the login prompt. The basic idea is to call a script (<code>vglgenkey</code>)
from the display manager&rsquo;s startup script.  <code>vglgenkey</code>
invokes <code>xauth</code> to generate an authorization key for the
server&rsquo;s X display, and it stores this key under <code>/etc/opt/VirtualGL</code>.
The VirtualGL launcher script (<code>vglrun</code>) then attempts to
read this key and merge it into the user&rsquo;s <code>.Xauthority</code>
file, thus granting the user access to the server&rsquo;s X display.
Therefore, you can control who has access to the server&rsquo;s X display
simply by controlling who has read access to the <code>/etc/opt/VirtualGL</code>
directory.</p>

<p>If you prefer, you can also grant access to every authenticated user
on the server by replacing the references to <code>vglgenkey</code>
below with <code>xhost&nbsp;+localhost</code>.</p>


<h3 id="hd005001001">If your system is using dtlogin as a display manager:</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in as root.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        Create a new directory <code>/etc/opt/VirtualGL</code> and make it
        readable by the <code>vglusers</code> group, e.g.:
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/opt/VirtualGL
chgrp&nbsp;vglusers&nbsp;/etc/opt/VirtualGL
chmod&nbsp;750&nbsp;/etc/opt/VirtualGL
</pre>

    </li>
    <li class="Ordered">
        Temporarily shut down dtlogin by issuing
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;stop
</pre>

    </li>
    <li class="Ordered">
        If the <code>/etc/dt/config</code> directory does not exist, create
        it.
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/dt/config
</pre>

    </li>
    <li class="Ordered">
        If <code>/etc/dt/config/Xsetup</code> does not exist, then copy the
        default <code>Xsetup</code> file from <code>/usr/dt/config</code> to
        that location:
<pre class="verbatim">
cp&nbsp;/usr/dt/config/Xsetup&nbsp;/etc/dt/config/Xsetup
</pre>

    </li>
    <li class="Ordered">
        Edit <code>/etc/dt/config/Xsetup</code>, and add the following lines
        to the bottom of the file:
<pre class="verbatim">
/opt/SUNWvgl/bin/vglgenkey
</pre>

    </li>
    <li class="Ordered">
        If <code>/etc/dt/config/Xconfig</code> does not exist, then copy the
        default <code>Xconfig</code> file from <code>/usr/dt/config</code>
        to that location:
<pre class="verbatim">
cp&nbsp;/usr/dt/config/Xconfig&nbsp;/etc/dt/config/Xconfig
</pre>

    </li>
    <li class="Ordered">
        Edit <code>/etc/dt/config/Xconfig</code>, and add (or uncomment) the
        following line:
<pre class="verbatim">
Dtlogin*grabServer:&nbsp;False
</pre>

        <dl class="Description">
            <dt class="Description">Explanation</dt>
            <dd class="Description">
                The <code>Dtlogin*grabServer</code> option restricts X display access
                to only the <code>dtlogin</code> process.  This is an added security
                measure, since it prevents a user from attaching any kind of sniffer
                program to the X display even if they have display access.  But <code>Dtlogin*grabServer</code>
                also prevents VirtualGL from using the X display to access the 3D graphics
                hardware, so this option must be disabled for VirtualGL to work properly.
            </dd>
        </dl>
        <div class="important"><p class="important">
        If the system you are configuring as a VirtualGL server is also being used as a Sun Ray server, then make these same modifications to <code>/etc/dt/config/Xconfig.SUNWut.prototype</code>.  Otherwise, the modifications you just made to <code>/etc/dt/config/Xconfig</code> will be overwritten the next time the system is restarted.
        </p></div>
    </li>
    <li class="Ordered">
        Unless you know that you absolutely need it, disable the XTEST extension.
        Disabling XTEST will not prevent a user from logging keystrokes or
        reading images from the X display, but it will prevent them from inserting
        key and mouse events and thus hijacking a local X session.
        <ol class="Ordered alpha" type="a">
            <li class="Ordered" value="1">
                If <code>/etc/dt/config/Xservers</code> does not exist, then copy the
                default <code>Xservers</code> file from <code>/usr/dt/config</code>
                to that location:
<pre class="verbatim">
cp&nbsp;/usr/dt/config/Xservers&nbsp;/etc/dt/config/Xservers
</pre>

            </li>
            <li class="Ordered" value="2">
                Edit <code>/etc/dt/config/Xservers</code> and add an argument of <code>-tst</code>
                to the line corresponding to the display number you are configuring,
                e.g.:
<pre class="verbatim">
:0&nbsp;&nbsp;Local&nbsp;local_uid@console&nbsp;root&nbsp;/usr/openwin/bin/Xsun&nbsp;:0&nbsp;-nobanner&nbsp;-tst
</pre>

                <div class="important"><p class="important">
                If the system you are configuring as a VirtualGL server is also being used as a Sun Ray server, then make these same modifications to <code>/etc/dt/config/Xservers.SUNWut.prototype</code>.  Otherwise, the modifications you just made to <code>/etc/dt/config/Xservers</code> will be overwritten the next time the system is restarted.
                </p></div>
            </li>
        </ol>
    </li>
    <li class="Ordered">
        Verify that <code>/etc/dt/config</code> and <code>/etc/dt/config/Xsetup</code>
        can be executed by all users, and verify that <code>/etc/dt/config/Xconfig</code>
        and <code>/etc/dt/config/Xservers</code> can be read by all users.
    </li>
    <li class="Ordered">
        Restart the X server by issuing
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;start
</pre>

    </li>
    <li class="Ordered">
        You can check your work by running
<pre class="verbatim">
/usr/openwin/bin/xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/usr/openwin/bin/xdpyinfo&nbsp;-display&nbsp;:0
</pre>

        In particular, make sure that XTEST doesn&rsquo;t show up in the list
        of extensions if you disabled it above.  If <code>xdpyinfo</code> fails
        to run, then the permissions on Display :0 are probably still too restrictive,
        meaning that the change in Step 7 didn&rsquo;t take for some reason.
    </li>
</ol>


<h3 id="hd005001002">If your system is using gdm as a display manager (Solaris 10 or later):</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in as root.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        Create a new directory <code>/etc/opt/VirtualGL</code> and make it
        readable by the <code>vglusers</code> group, e.g.:
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/opt/VirtualGL
chgrp&nbsp;vglusers&nbsp;/etc/opt/VirtualGL
chmod&nbsp;750&nbsp;/etc/opt/VirtualGL
</pre>

    </li>
    <li class="Ordered">
        Temporarily shut down gdm by issuing
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm2-login
</pre>

    </li>
    <li class="Ordered">
        Add
<pre class="verbatim">
/opt/SUNWvgl/bin/vglgenkey
</pre>

        to the top of the <code>/etc/X11/gdm/Init/Default</code> file.
    </li>
    <li class="Ordered">
        Edit <code>/etc/X11/gdm/gdm.conf</code> and add the following line
        under the <code>[security]</code> section (or change it if it already
        exists):
<pre class="verbatim">
DisallowTCP=false
</pre>

    </li>
    <li class="Ordered">
        Unless you know that you absolutely need it, disable the XTEST extension.
        Disabling XTEST will not prevent a user from logging keystrokes or
        reading images from the X display, but it will prevent them from inserting
        key and mouse events and thus hijacking a local X session.<br />
        <br /> Edit <code>/etc/X11/gdm/gdm.conf</code> and add <code>-tst</code>
        to all lines that appear to be X server command lines, e.g.:
<pre class="verbatim">
StandardXServer=/usr/X11R6/bin/Xorg&nbsp;-tst
</pre>

<pre class="verbatim">
[server-Standard]
command=/usr/X11R6/bin/Xorg&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

<pre class="verbatim">
[server-Terminal]
command=/usr/X11R6/bin/Xorg&nbsp;-tst&nbsp;-audit&nbsp;0&nbsp;-terminate
</pre>

<pre class="verbatim">
[server-Chooser]
command=/usr/X11R6/bin/Xorg&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

    </li>
    <li class="Ordered">
        Restart gdm by issuing
<pre class="verbatim">
svcadm&nbsp;enable&nbsp;gdm2-login
</pre>

    </li>
    <li class="Ordered">
        You can check your work by running
<pre class="verbatim">
/usr/openwin/bin/xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/usr/openwin/bin/xdpyinfo&nbsp;-display&nbsp;:0
</pre>

        In particular, make sure that XTEST doesn&rsquo;t show up in the list
        of extensions if you disabled it above.  If <code>xdpyinfo</code> fails
        to run, then the permissions on Display :0 are probably still too restrictive,
        meaning that the change in Step 5 didn&rsquo;t take for some reason.
    </li>
</ol>


<h2 id="hd005002">5.2&nbsp;Uninstalling</h2>

<p>As root, issue the following command:</p>

<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

<p>Answer &ldquo;yes&rdquo; when prompted.</p>

<hr class="break" />


<h1 id="hd006"><a name="file006"></a>6&nbsp;Installing the VirtualGL Direct Mode Client on Windows</h1>

<div class="important"><p class="important">
Installing the VirtualGL package is necessary on any Windows machine that will act as a VirtualGL <a href="#Direct_Mode">Direct Mode</a><a name="idx0037"></a>	client.  It is not necessary to install VirtualGL on the client machine if <a href="#Raw_Mode">Raw Mode</a><a name="idx0038"></a> is to be used.
</p></div>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the latest VirtualGL installer package from the files area
        of
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">http://sourceforge.net/projects/virtualgl</a></span><a name="idx0039"></a>.
        The installer will usually be named <code>VirtualGL-{version}.exe</code>.
    </li>
    <li class="Ordered">
        Run the VirtualGL installer.  The installation of VirtualGL should
        be self-explanatory.  The only configuration option is the directory
        in which you want the files to be installed.
    </li>
    <li class="Ordered">
        Install Hummingbird Exceed if it isn&rsquo;t already installed.
    </li>
    <li class="Ordered">
        Add the Exceed path (e.g. <code>C:\Program&nbsp;Files\Hummingbird\Connectivity\9.00\Exceed</code>)
        to your system <code>PATH</code> environment if it isn&rsquo;t already
        there.
    </li>
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        In the &ldquo;X Server Protocol&rdquo; applet, select the &ldquo;Protocol&rdquo;
        tab and make sure that &ldquo;Use 32 bits per pixel for true color&rdquo;
        is not checked. <br /><br />
        <img src="exceed1.png" alt="exceed1" class="inline" id="imgid_1" name="imgid_1"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
    <li class="Ordered">
        Open the &ldquo;Other Server Settings&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Performance&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        Select the &ldquo;Performance&rdquo; tab and make sure that &ldquo;Default
        Backing Store&rdquo; is set to &ldquo;None.&rdquo; <br /><br />
        <img src="exceed3.png" alt="exceed3" class="inline" id="imgid_2" name="imgid_2"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h2 id="hd006001">6.1&nbsp;Obtaining Optimal Performance with Exceed</h2>

<p>VirtualGL has the ability to take advantage of the MIT-SHM extension
in Hummingbird Exceed to accelerate image drawing on Windows.  This
can improve the overall performance of the VirtualGL pipeline by as
much as 20% in some cases.</p>

<p>The bad news is that this extension has some issues in earlier versions
of Exceed.  If you are using Exceed 8 or 9, you will need to obtain
the following patches from the Hummingbird support site:</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Product</th>
    <th class="head standard">Patches Required</th>
    <th class="head standard">How to Obtain</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 8.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v8.0.0.28 (or higher)</td>
    <td class="standard">Download all patches from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0040"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 9.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v9.0.0.9 (or higher)</td>
    <td class="standard"><code>exceed.exe</code> can be patched by running Hummingbird Update.<br /> <br /> All other patches must be downloaded from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0041"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
</table>
</div>


<p>No patches should be necessary for Exceed 10 and above.</p>

<p>Next, you need to enable the MIT-SHM extension in Exceed:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        Select the &ldquo;Extensions&rdquo; tab and make sure that &ldquo;MIT-SHM&rdquo;
        is checked. <br /><br />
        <img src="exceed2.png" alt="exceed2" class="inline" id="imgid_3" name="imgid_3"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h2 id="hd006002">6.2&nbsp;Secure Shell</h2>

<p>It is recommended that you use SSh (Secure Shell) to log in to the
application server and launch applications.  Some servers are configured
to allow telnet and RSh access, but telnet and RSh both send passwords
unencrypted over the network and are thus being phased out in favor
of SSh.  If
<span class="remote"><a href="http://www.cygwin.com/" class="remote">Cygwin</a></span><a name="idx0042"></a>
is already installed on your Windows VirtualGL client machine, then
you can use the SSh client included in Cygwin.  Otherwise, download
and install
<span class="remote"><a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/" class="remote">PuTTY</a></span><a name="idx0043"></a>.</p>


<h2 id="hd006003">6.3&nbsp;Installing the VirtualGL Client as a Windows Service</h2>

<p>The VirtualGL Windows Client can be installed as a Windows service
(and subsequently removed) using the links provided in the &ldquo;VirtualGL
Client&rdquo; start menu group.  Once installed, the service can be
started from the Services applet in the Control Panel (located under
&ldquo;Administrative Tools&rdquo;) or by invoking</p>

<pre class="verbatim">
net&nbsp;start&nbsp;vglclient
</pre>

<p>from a command prompt.  The service can be subsequently stopped by
invoking</p>

<pre class="verbatim">
net&nbsp;stop&nbsp;vglclient
</pre>

<p>If you wish to install the client as a service and have it listen on
a port other than the default (4242 for unencrypted connections or
4243 for SSL connections), then you will need to install the service
manually from the command line.</p>

<pre class="verbatim">
vglclient&nbsp;-?
</pre>

<p>gives a list of the relevant command-line options.</p>

<hr class="break" />


<h1 id="hd007"><a name="file007"></a>7&nbsp;Using VirtualGL in Direct Mode</h1>


<h2 id="hd007001">7.1&nbsp;Linux or Solaris Client</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        If you have not installed the VirtualGL client as a service or if your
        client is a Solaris machine, then you will need to start the client
        manually.  To do this, run
<pre class="verbatim">
vglclient
</pre>

        on Linux or
<pre class="verbatim">
/opt/SUNWvgl/bin/vglclient
</pre>

        on Solaris.
    </li>
    <li class="Ordered">
        Open a Secure Shell (SSh) session into the application server:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;-l&nbsp;{your_user_name}&nbsp;{server_machine_name_or_IP}
</pre>

    </li>
    <li class="Ordered">
        In the SSh session, set the <code>VGL_CLIENT</code> environment variable
        on the server to point back to the client&rsquo;s X display.  e.g.:
<pre class="verbatim">
export&nbsp;VGL_CLIENT={client_machine_name_or_IP}:0.0
</pre>

        or
<pre class="verbatim">
setenv&nbsp;VGL_CLIENT&nbsp;{client_machine_name_or_IP}:0.0
</pre>

    </li>
    <li class="Ordered">
        In the SSh session, launch your 3D application using:
<pre class="verbatim">
vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        if the application server is running Linux or
<pre class="verbatim">
/opt/SUNWvgl/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        if the application server is running Solaris. <br /><br /> Consult
        Section <a href="#Advanced_Configuration" class="ref">18</a> for more
        information on <code>vglrun</code> command line options.
    </li>
</ol>


<h3 id="hd007001001">Direct X11 Connections</h3>

<p>You may have noticed that the procedure above enables forwarding of
the X11 traffic over the SSh connection.  You can also use VirtualGL
with a direct X11 connection, if you prefer, and grant the application
server access to the client machine&rsquo;s X server using <code>xhost</code>
or <code>xauth</code>.  We have never observed any performance benefit
or other benefit to using a direct X11 connection, however.  Additionally,
some newer Linux distributions ship with X11 TCP connections disabled,
and thus using direct X11 connections is not possible with such systems
without reconfiguring them.  If you do choose to use a direct X11 connection,
then set the <code>DISPLAY</code> environment variable in step 3 rather
than <code>VGL_CLIENT</code>.</p>


<h2 id="hd007002">7.2&nbsp;Windows Client</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        If you have not installed the VirtualGL client as a service, then you
        will need to start the client manually.  To do this, use the link provided
        in the VirtualGL Client start menu group.
    </li>
    <li class="Ordered">
        Make sure that Exceed is running.
    </li>
    <li class="Ordered">
        Open a command prompt
    </li>
    <li class="Ordered">
        Set the <code>DISPLAY</code> environment to whichever display Exceed
        is occupying, e.g.:
<pre class="verbatim">
set&nbsp;DISPLAY=localhost:0.0
</pre>

        <div class="important"><p class="important">
        If you don&rsquo;t anticipate the need to launch multiple Exceed sessions, then you can set this environment variable globally (<em>Control Panel&ndash;&gt;System&ndash;&gt;Advanced</em>.)
        </p></div>
    </li>
    <li class="Ordered">
        Open a Secure Shell (SSh) connection to the application server:
        <dl class="Description">
            <dt class="Description">CygWin users</dt>
            <dd class="Description">
                Open a new command prompt and type:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;-l&nbsp;{your_user_name}&nbsp;{server_machine_name_or_IP}
</pre>

            </dd>
            <dt class="Description">PuTTY users</dt>
            <dd class="Description">
                Open a new command prompt and type:
<pre class="verbatim">
putty&nbsp;-X&nbsp;-l&nbsp;{your_user_name}&nbsp;{server_machine_name_or_IP}
</pre>

        &hellip; or &hellip; <br /><br />
                <ol class="Ordered alpha" type="a">
                    <li class="Ordered" value="1">
                        Launch PuTTY.
                    </li>
                    <li class="Ordered" value="2">
                        Select the <em>Connection&ndash;&gt;SSH&ndash;&gt;Tunnels</em> category.
                    </li>
                    <li class="Ordered" value="3">
                        Check &ldquo;Enable X11 forwarding&rdquo; and set the &ldquo;X display
                        location&rdquo; to <code>localhost:0.0</code> or to whichever display
                        number that Exceed is occupying. <br /><br />
                        <img src="putty3.png" alt="putty3" class="inline" id="imgid_4" name="imgid_4"/>
                    </li>
                    <li class="Ordered" value="4">
                        Select the &ldquo;Session&rdquo; category.
                    </li>
                    <li class="Ordered" value="5">
                        Set the &ldquo;Protocol&rdquo; to &ldquo;SSH,&rdquo; then enter the
                        host name or IP address of the application server. <br /><br />
                        <img src="putty1.png" alt="putty1" class="inline" id="imgid_5" name="imgid_5"/>
                    </li>
                    <li class="Ordered" value="6">
                        Click &ldquo;Open&rdquo;
                    </li>
                </ol>
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        In the remote shell session, set the <code>VGL_CLIENT</code> environment
        variable on the server to point back to the client machine:
<pre class="verbatim">
export&nbsp;VGL_CLIENT={client_machine_name_or_IP}:0.0
</pre>

        or
<pre class="verbatim">
setenv&nbsp;VGL_CLIENT&nbsp;{client_machine_name_or_IP}:0.0
</pre>

    </li>
    <li class="Ordered">
        In the SSh session, launch your 3D application:
<pre class="verbatim">
vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        if the application server is running Linux or
<pre class="verbatim">
/opt/SUNWvgl/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        if the application server is running Solaris. <br /><br /> Consult
        Section <a href="#Advanced_Configuration" class="ref">18</a> for more
        information on <code>vglrun</code> command line options.
    </li>
</ol>


<h3 id="hd007002001">Direct X11 Connections</h3>

<p>You may have noticed that the procedure above enables forwarding of
the X11 traffic over the SSh connection.  You can also use VirtualGL
with a direct X11 connection, if you prefer, and grant the application
server access to the X display using the &ldquo;Security&rdquo; applet
in Exceed XConfig.  We have never observed any performance benefit
or other benefit to using a direct X11 connection, however.  If you
do choose to use a direct X11 connection, then set the <code>DISPLAY</code>
environment variable in step 6 rather than <code>VGL_CLIENT</code>.</p>


<h2 id="hd007003">7.3&nbsp;Troubleshooting</h2>

<p>It is generally a good idea to make sure that a regular X application
(such as xterm) can be remotely displayed from the application server
to your client workstation prior to attempting to run VirtualGL.</p>

<hr class="break" />


<h1 id="hd008"><a name="file008"></a>8&nbsp;Securing Direct Mode</h1>


<h2 id="hd008001">8.1&nbsp;Built-In SSL Encryption</h2>

<p>VirtualGL has built-in support for encrypting its compressed image
stream inside a Secure Socket Layer (SSL.)  For performance reasons,
this feature is not enabled by default, but it can easily be enabled.
On the server, set the environment variable <code>VGL_SSL</code> to
<code>1</code> prior to launching the application, or pass an argument
of <code>+s</code> to <code>vglrun</code>.  No action is required on
the client.  The client will automatically accept SSL or unencrypted
connections, unless you have configured it otherwise (see Section
<a href="#Advanced_Configuration" class="ref">18</a> for more details.)</p>


<h2 id="hd008002">8.2&nbsp;Direct Mode over SSh</h2>

<p>So what if your only path into the network is through SSh, perhaps
through a single &ldquo;gateway&rdquo; machine.  No problem, because
SSh allows you to tunnel both incoming and outgoing TCP/IP connections
on any port from one machine to another.  Tunneling VirtualGL&rsquo;s
compressed image stream through SSh will not be as fast as using the
built-in SSL encryption capabilities of VirtualGL, but sometimes it&rsquo;s
the only option available.</p>

<p>Let&rsquo;s assume the following configuration:</p>

<p><img src="sshtunnel.png" alt="sshtunnel" class="inline" id="imgid_6" name="imgid_6"/></p>

<p>What we want to do is tunnel both the X11 protocol stream and VirtualGL&rsquo;s
compressed image stream through SSh.  Here&rsquo;s one way to do it:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the VirtualGL client
    </li>
    <li class="Ordered">
        If the client machine is running Windows,
        <ol class="Ordered alpha" type="a">
            <li class="Ordered" value="1">
                Start Exceed
            </li>
            <li class="Ordered" value="2">
                Open a console and type
<pre class="verbatim">
set&nbsp;DISPLAY=localhost:0.0
</pre>

        (replace &ldquo;:0.0&rdquo; with whatever display number Exceed is
        parking on.)
            </li>
        </ol>
    </li>
    <li class="Ordered">
        In that same console:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;-R&nbsp;4242:localhost:4242&nbsp;username@ssh_gateway_machine
</pre>

        This tells SSh to tunnel all X11 traffic from your session on <code>ssh_gateway_machine</code>
        to your client&rsquo;s display, and additionally it will tunnel all
        outbound traffic to port 4242 on <code>ssh_gateway_machine</code> to
        inbound port 4242 on your client machine.
        <div class="important"><p class="important">
        This command line also works with PuTTY.  Just replace &ldquo;ssh&rdquo; with the path to the PuTTY executable.  You can also configure the same thing through the PuTTY GUI as follows: <br /><br /> <img src="putty2.png" alt="putty2" class="inline" id="imgid_7" name="imgid_7"/>
        </p></div>
    </li>
    <li class="Ordered">
        Now you should have a terminal session open into <code>ssh_gateway_machine</code>.
        Inside this session, issue the following command:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;-R&nbsp;4242:localhost:4242&nbsp;username@app_server_machine
</pre>

        This tells SSh to tunnel all X11 traffic from your session on <code>app_server_machine</code>
        to your session on <code>ssh_gateway_machine</code>, where it will
        be re-tunneled to the client display.  Additionally, all outbound traffic
        to port 4242 on <code>app_server_machine</code> will be tunneled to
        port 4242 on <code>ssh_gateway_machine</code>, which will then re-tunnel
        the traffic to inbound port 4242 on your client machine.
    </li>
    <li class="Ordered">
        You should now have a terminal session open into <code>app_server_machine</code>.
        Inside that session, set the environment variable <code>VGL_CLIENT</code>
        to <code>localhost:n.0</code>, where <code>n</code> is the display
        number of the X server running on the Client machine.
    </li>
    <li class="Ordered">
        <code>vglrun</code> your application.
    </li>
</ol>

<p>You can of course replace port 4242 in all of the steps above with
whatever port you choose, but make sure that if you change the port,
you configure both the client and server to talk on the port you choose
(using the <code>-port</code> argument to <code>vglclient</code> as
well as the <code>VGL_PORT</code> environment variable on the server.)</p>

<div class="important"><p class="important">
This same procedure would also work if you needed to connect directly to <code>app_server_machine</code> and tunnel everything over SSh.  In that case, simply leave out Step 3.
</p></div>

<hr class="break" />


<h1 id="hd009"><a name="file009"></a>9&nbsp;Using VirtualGL in Raw Mode with VNC and Other X Proxies</h1>

<p><a name="Raw_Mode_Usage"></a></p>

<p>Referring to Section <a href="#Overview" class="ref">2</a>, Raw Mode
is a mode in which VirtualGL bypasses its own image compressor and
instead draws the rendered 3D images as uncompressed bitmaps into an
X proxy.  In this mode, VirtualGL relies on the X proxy to do the job
of compressing and delivering images to the client(s).</p>

<div class="figure">
<img src="idealx11proxy.png" alt="idealx11proxy" class="figure" id="imgid_15" name="imgid_15"/>
</div>


<h3 id="hd009000001">Advantages of using VirtualGL with an X proxy:</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        X proxies eliminate the need to send X11 traffic over the network,
        thus they can provide reasonable remote display performance on low-bandwidth,
        high-latency connections (such as broadband or long-haul T1 lines.)
        The application GUI will load and render much faster (perhaps even
        orders of magnitude faster) with an X proxy than with remote X11 on
        such connections.
    </li>
    <li class="Itemize asterisk">
        Some X proxies (such as VNC) provide rudimentary collaboration capabilities.
        Multiple clients can simultaneously view the same server session and
        pass around control of the keyboard and mouse.
    </li>
    <li class="Itemize asterisk">
        The client is stateless.  If the network hiccups or the client is otherwise
        disconnected, the session remains running on the server and can be
        rejoined from any machine on the network.
    </li>
    <li class="Itemize asterisk">
        X proxies sometimes provide clients for platforms (such as PDA&rsquo;s,
        etc.) that VirtualGL doesn&rsquo;t support.
    </li>
    <li class="Itemize asterisk">
        No X server is required on the client machine.  This reduces the deployment
        cost and complexity for Windows clients.
    </li>
</ul>


<h3 id="hd009000002">Disadvantages of using VirtualGL with an X proxy:</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        Performance.  Most X proxies are simply not capable of streaming full-screen
        video at interactive frame rates, and thus on faster networks they
        fall far short of the performance of Direct Mode.  TurboVNC (see below)
        is meant to address this problem, at least in part.
    </li>
    <li class="Itemize asterisk">
        With the exception of TurboVNC, X proxies lack double buffering support.
    </li>
    <li class="Itemize asterisk">
        With the exception of NX, X proxies generally do not provide seamless
        windows.  Rather than each application window appearing as a separate
        client window, the entire server desktop appears in a single client
        window.
    </li>
    <li class="Itemize asterisk">
        X proxies require more server resources, both because they have to
        compress more pixels (an entire desktop rather than a single window)
        and because 2D (X11) rendering occurs on the server rather than the
        client.
    </li>
    <li class="Itemize asterisk">
        X proxies cannot be used with <a href="#Advanced_OpenGL">advanced OpenGL
        features</a><a name="idx0044"></a>, such as stereo or overlays.
    </li>
</ul>

<p>When an X proxy session is started on the server, it generally chooses
a unique display number (such as :1, :2, etc.) and starts a customized
X server on that display number.  This customized X server renders
all graphical output from the application into a bitmap in memory,
which it then compresses and sends to the client(s).  The proxy may
or may not even implement the GLX extension (VNC does not), and thus
it might not have any native ability to run OpenGL applications. But
since VirtualGL is designed to intercept and hand off all GLX commands
to the hardware-accelerated root display (usually display :0), VirtualGL
can be used as a &ldquo;3D to 2D converter&rdquo; to allow 3D apps
to run within VNC or another X11 proxy that doesn&rsquo;t natively
support GLX.</p>


<h2 id="hd009001">9.1&nbsp;TurboVNC</h2>

<p>TurboVNC is essentially just a version of
<span class="remote"><a href="http://www.tightvnc.com/" class="remote">TightVNC</a></span><a name="idx0045"></a>
with optimizations to make it perform at peak efficiency with full-screen
video workloads (which is, in a nutshell, what VirtualGL produces.)
These optimizations include:</p>

<ul class="Itemize">
    <li class="Itemize asterisk">
        Using VirtualGL&rsquo;s high-performance JPEG codec (TurboJPEG) to
        handle tight JPEG encoding
    </li>
    <li class="Itemize asterisk">
        Using only JPEG and Full color encoding (mono, gradient, and indexed
        encoding are disabled.)  High-performance JPEG encoding is used in
        all cases except for very small image tiles for which using full color
        (raw) encoding is more efficient due to JPEG&rsquo;s compression overhead.
    </li>
    <li class="Itemize asterisk">
        Using the optimized tight protocol whenever possible.  Other VNC protocols
        (ZRLE, Hextile, etc.) are available on the server so that it can talk
        to non-TurboVNC clients.  But if a TurboVNC client connects to a TurboVNC
        server, they will both use optimized tight encoding at all times.
    </li>
    <li class="Itemize asterisk">
        Protocol tweaks to allow some stages of the VNC pipeline to occur in
        parallel.  This particularly improves performance on low-bandwidth
        (broadband) connections.
    </li>
</ul>

<p>Other notable differences between TurboVNC and TightVNC:</p>

<ul class="Itemize">
    <li class="Itemize asterisk">
        The compression level and quality parameters have been changed as follows:
        <br /><br /> <em>Compression Level</em> = 0 for 4:4:4 subsampling,
        1 for 4:1:1 subsampling, or 2 for 4:2:2 subsampling<br /> <em>Quality</em>
        = 0 to 100 (JPEG quality level) <br /><br />
    </li>
    <li class="Itemize asterisk">
        The TurboVNC client supports double buffering.  This is enabled by
        default but can be disabled by passing an argument of <code>-singlebuffer</code>
        to <code>vncviewer</code> (or selecting the corresponding option in
        the configuration GUI.) <br /><br />
    </li>
    <li class="Itemize asterisk">
        The TurboVNC client adds a special mode which optimizes the client/server
        interaction to improve performance on high-latency networks.  Normally,
        the VNC client will wait until one screen update has finished drawing
        before requesting the next one.  Enabling TurboVNC&rsquo;s high-latency
        network mode causes the client to send a request for the next frame
        while it is drawing the current one.  This mode decreases performance
        on local-area networks and is thus not enabled by default, but it can
        be enabled by passing an argument of <code>-wan</code> to <code>vncviewer</code>
        (or selecting the corresponding option in the configuration GUI.)
    </li>
</ul>

<p>On a local area network, TurboVNC + VirtualGL in Raw Mode can generally
produce levels of performance within 80-90% of VirtualGL in Direct
Mode.  On a wide-area network, TurboVNC wins hands down.  Direct Mode
is still preferable if a seamless user experience is a requirement
and if performance is critical. But if a bit of performance can be
sacrificed and if collaboration and a stateless client are more important
features than seamless windows, then VirtualGL+TurboVNC would be the
appropriate solution.  In the long term, we are looking for a way to
combine the best of both solutions into one.  But such is not an easy
problem to solve &hellip;</p>

<p>TurboVNC allows VirtualGL to be used with respectable performance over
low-bandwidth/high-latency networks, such as broadband or satellite.
As with VirtualGL&rsquo;s direct mode, the quality and subsampling
of TurboVNC&rsquo;s JPEG image stream can be adjusted to reduce the
size of the image stream without reducing the number of image colors.
TurboVNC provides a preset mode for broadband connections, which sets
the quality to a low level that is noticeably lossy but still quite
usable.  It should be possible to redraw a 1280x1024 window at greater
than 10 frames/second on a standard cable modem connection using this
preset mode.</p>

<p>For instructions on the usage of TurboVNC, please refer to the TurboVNC
man pages:</p>

<p>On Linux:</p>

<pre class="verbatim">
man&nbsp;-M&nbsp;/opt/TurboVNC/man&nbsp;{vncserver&nbsp;|&nbsp;Xvnc&nbsp;|&nbsp;vncviewer&nbsp;|&nbsp;vncconnect&nbsp;|&nbsp;vncpasswd}
</pre>

<p>On Solaris:</p>

<pre class="verbatim">
man&nbsp;-M&nbsp;/opt/SUNWtvnc/man&nbsp;{vncserver&nbsp;|&nbsp;Xvnc&nbsp;|&nbsp;vncviewer&nbsp;|&nbsp;vncconnect&nbsp;|&nbsp;vncpasswd}
</pre>

<p>On Windows, use the embedded help feature (the question mark button
in the upper right of the window.)</p>

<p>The TightVNC documentation:</p>

<p><a href="http://www.tightvnc.com/docs.html">http://www.tightvnc.com/docs.html</a></p>

<p>might also be helpful, since TurboVNC is based on TightVNC and shares
many of its features.</p>


<h2 id="hd009002">9.2&nbsp;Enabling Raw Mode</h2>

<p>Raw mode is automatically enabled if VirtualGL detects that it is running
on the same machine as the X server, which it assumes to be the case
if the X display name begins with a colon (&ldquo;:&rdquo;) or with
&ldquo;<code>unix:</code>&rdquo;.  In most cases, this will cause VirtualGL
to automatically use raw mode when it is launched in an X proxy environment
such as VNC or NX.  But you can manually enable Raw Mode by setting
the <code>VGL_COMPRESS</code> environment variable to <code>0</code>
on the server or passing an argument of <code>-c&nbsp;0</code> to <code>vglrun</code>
(see Section <a href="#Advanced_Configuration" class="ref">18</a> for
more details.)  Make sure that the <code>DISPLAY</code> variable points
to whatever display number that VNC (or your X proxy of choice) is
occupying (e.g. :1, :2, etc.)</p>

<hr class="break" />


<h1 id="hd0010"><a name="file010"></a>10&nbsp;<code>vglrun</code> and Solaris Shell Scripts</h1>

<p><code>vglrun</code> can be used to launch either binary executables
or shell scripts, but there are a few things to keep in mind when using
<code>vglrun</code> to launch a shell script on Solaris.  When you
<code>vglrun</code> a shell script, the VirtualGL faker library will
be preloaded into every executable that the script launches. Normally
this is innocuous, but if the script calls any executables that are
setuid root, then Solaris will refuse to load those executables because
you are attempting to preload a library (VirtualGL) that is not in
a &ldquo;secure path.&rdquo; Solaris keeps a tight lid on what goes
into <code>/usr/lib</code> and <code>/lib</code>, and by default, it
will only allow libraries in those paths to be preloaded into an executable
that is setuid root.  Generally, 3rd party packages are verboden from
installing anything into <code>/usr/lib</code> or <code>/lib</code>.
But you can use the <code>crle</code> utility to add other directories
to the operating system&rsquo;s list of secure paths.  In the case
of VirtualGL, you would issue (as root):</p>

<pre class="verbatim">
crle&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib
crle&nbsp;-64&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib/64
</pre>

<p>But please be aware of the security ramifications of this before you
do it. You are essentially telling Solaris that you trust the security
and stability of the VirtualGL code as much as you trust the security
and stability of the operating system.  And while we&rsquo;re flattered,
we&rsquo;re not sure that we&rsquo;re necessarily deserving of that
accolade, so if you are in a security critical environment, apply the
appropriate level of paranoia here.</p>

<p>An easier and perhaps more secure approach is to simply edit the application
script and have it issue <code>vglrun</code> only for the executables
that you wish to run in the VirtualGL environment.  But sometimes that
is not an option.</p>

<p><code>vglrun</code> on Solaris has two options that are relevant to
launching scripts:</p>

<pre class="verbatim">
vglrun&nbsp;-32&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 32-bit executables called by a script,
whereas</p>

<pre class="verbatim">
vglrun&nbsp;-64&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 64-bit executables.</p>

<hr class="break" />


<h1 id="hd0011"><a name="file011"></a>11&nbsp;GLP: Using VirtualGL Without an X Server on the Server Machine</h1>

<p><a name="GLP_Usage"></a></p>

<p>Sun Microsystems has developed an extension to OpenGL called GLP which
allows an application to directly access the rendering capabilities
of a 3D graphics card even if there is no X server running on the card.
Apart from greatly simplifying the process of setting up VirtualGL
on a server, GLP also greatly improves the overall security of VirtualGL
servers, since it is no longer necessary to grant every user access
to display :0.  In addition, GLP makes it quite simple to assign VirtualGL
jobs to any graphics pipe in a multi-pipe system.</p>

<p>Version 2.0 of VirtualGL for Sparc/Solaris can use GLP if it is available.
Currently, GLP is available only in
<span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
OpenGL</a></span><a name="idx0046"></a> 1.5 for Sparc/Solaris.</p>

<p>See <a href="http://www.opengl.org/about/arb/meeting_notes/notes/glP_presentation.pdf">http://www.opengl.org/about/arb/meeting_notes/notes/glP_presentation.pdf</a>
for more details on GLP.</p>

<p>If GLP is supported on your application server, it can be enabled by
passing an argument of <code>-d&nbsp;glp</code> to <code>vglrun</code>,
e.g.:</p>

<pre class="verbatim">
/opt/SUNWvgl/bin/vglrun&nbsp;-d&nbsp;glp&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

<p>This will tell the VirtualGL faker to enable GLP mode and select the
first available GLP device.  You can also set the <code>VGL_DISPLAY</code>
environment variable to <code>glp</code> to achieve the same effect:</p>

<pre class="verbatim">
export&nbsp;VGL_DISPLAY=glp
/opt/SUNWvgl/bin/vglrun&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

<p>Additionally, you can specify a specific GLP device to use for rendering:</p>

<pre class="verbatim">
export&nbsp;VGL_DISPLAY=/dev/fbs/jfb0
/opt/SUNWvgl/bin/vglrun&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

<hr class="break" />


<h1 id="hd0012"><a name="file012"></a>12&nbsp;Using VirtualGL with Applications That Manually Load OpenGL</h1>

<p><a name="dlopen"></a></p>

<p>The lion&rsquo;s share of OpenGL applications are dynamically linked
against <code>libGL.so</code>, and thus <code>libGL.so</code> is automatically
loaded whenever the application loads.  Whenever <code>vglrun</code>
is used to launch such applications, VirtualGL is loaded ahead of <code>libGL.so</code>,
meaning that OpenGL and GLX symbols are resolved from VirtualGL first
and the &ldquo;real&rdquo; OpenGL library second.</p>

<p>However, some applications (particularly games) are not dynamically
linked against <code>libGL.so</code>.  These applications typically
call <code>dlopen()</code> and <code>dlsym()</code> later on in the
program&rsquo;s execution to manually load OpenGL and GLX symbols from
<code>libGL.so</code>.  Such applications also generally provide a
mechanism (usually either an environment variable or a command line
argument) which allows the user to specify a library that can be loaded
instead of <code>libGL.so</code>.</p>

<p>So let&rsquo;s assume that you just downloaded the latest version of
the Linux game Foo Wars from the Internet, and (for whatever reason)
you want to run the game in a VNC session.  The game provides a command
line switch <code>-g</code> which can be used to specify an OpenGL
library to load other than <code>libGL.so</code>.  You would launch
the game using a command line such as this:</p>

<pre class="verbatim">
vglrun&nbsp;foowars&nbsp;-g&nbsp;/usr/lib/librrfaker.so
</pre>

<p>You still need to use <code>vglrun</code> to launch the game, because
VirtualGL must also intercept a handful of X11 calls.  Using <code>vglrun</code>
allows VGL to intercept these calls, whereas using the game&rsquo;s
built-in mechanism for loading a substitute OpenGL library allows VirtualGL
to intercept the GLX and OpenGL calls.</p>

<p>In some cases, the application doesn&rsquo;t provide an override mechanism
such as the above.  In these cases, you should pass an argument of
<code>-dl</code> to <code>vglrun</code> when starting the application,
e.g.:</p>

<pre class="verbatim">
vglrun&nbsp;-dl&nbsp;foowars
</pre>

<p>Passing <code>-dl</code> to <code>vglrun</code> forces another library
to be loaded ahead of VirtualGL and <code>libGL.so</code>.  This new
library intercepts any calls to <code>dlopen()</code> and forces the
application to open VirtualGL instead of <code>libGL.so</code>.</p>

<p>Section <a href="#Application_Recipes" class="ref">14</a> contains
specific recipes for getting a variety of games and other applications
to work with VirtualGL.</p>

<hr class="break" />


<h1 id="hd0013"><a name="file013"></a>13&nbsp;Using VirtualGL with Chromium and ModViz VGP</h1>

<p><a name="Chromium"></a></p>

<p>Chromium is a powerful framework for performing various types of parallel
OpenGL rendering.  It is usually used on clusters of commodity Linux
PC&rsquo;s to divide up the task of rendering scenes with large geometries
or large pixel counts (such as when driving a display wall.)  Chromium
is most often used in one of three configurations:</p>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Sort-First Rendering (Image-Space Decomposition)
    </li>
    <li class="Ordered" value="2">
        Sort-First Rendering (Image-Space Decomposition) with Readback
    </li>
    <li class="Ordered" value="3">
        Sort-Last Rendering (Object-Space Decomposition)
    </li>
</ol>


<h2 id="hd0013001">13.1&nbsp;Configuration 1: Sort-First Rendering (Image-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-displaywall.png" alt="chromium-displaywall" class="figure" id="imgid_16" name="imgid_16"/>
</div>

<p>Sort-First Rendering (Image-Space Decomposition) is used to overcome
the fill-rate limitations of individual graphics cards.  When configured
to use sort-first rendering, Chromium divides up the scene based on
which polygons will be visible in a particular section of the final
image.  It then instructs each node of the cluster to render only the
polygons that are necessary to generate the image section (&ldquo;tile&rdquo;)
for that node.  This is primarily used to drive high-resolution displays
that would be impractical to drive from a single graphics card due
to limitations in the card&rsquo;s framebuffer memory, processing power,
or both.  Configuration 1 could be used, for instance, to drive a CAVE,
video wall, or even an extremely high-resolution monitor.  In this
configuration, each Chromium node generally uses all of its screen
real estate to render a section of the multi-screen image.</p>

<p>VirtualGL is generally not very useful with Configuration 1.  You could
theoretically install a separate copy of VirtualGL on each display
node and use it to redirect the output of each <code>crserver</code>
instance to a multi-screen X server running elsewhere on the network.
But there would be no way to synchronize the screens on the remote
end.  Chromium uses DMX to synchronize the screens in a multi-screen
configuration, and VirtualGL would have to be made DMX-aware for it
to perform the same job.  Maybe at some point in the future &hellip;
If you have a need for such a configuration,
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">let
us know</a></span><a name="idx0047"></a>.</p>


<h2 id="hd0013002">13.2&nbsp;Configuration 2: Sort-First Rendering (Image-Space Decomposition) with Readback</h2>

<div class="figure">
<img src="chromium-sortfirst.png" alt="chromium-sortfirst" class="figure" id="imgid_17" name="imgid_17"/>
</div>

<p>Configuration 2 uses the same sort-first principle as Configuration
1, except that each tile is only a fraction of a single screen, and
the tiles are recombined into a single window on Node 0.  This configuration
is perhaps the least often used of the three, but it is useful in cases
where the scene contains a large amount of textures (such as in volume
rendering) and thus rendering the whole scene on a single node would
be prohibitively slow due to fill-rate limitations.</p>

<p>In this configuration, the application is allowed to choose a visual,
create an X window, and manage the window as it would normally do.
But all other OpenGL and GLX activity is intercepted by the Chromium
App Faker (CrAppFaker) so that the rendering task can be split up among
the rendering nodes.  Once each node has rendered its section of the
final image, the tiles get passed back to a Chromium Server (CrServer)
process running on Node 0.  This CrServer process attaches to the previously-created
application window and draws the pixels into it using <code>glDrawPixels()</code>.</p>

<p>The general strategy for making this work with VirtualGL is to first
make it work without VirtualGL and then insert VirtualGL only into
the processes that run on Node 0.  VirtualGL must be inserted into
the CrAppFaker process to prevent CrAppFaker from sending <code>glXChooseVisual()</code>
calls to the X server (which would fail if the X server is a VNC server
or otherwise does not provide GLX.)  VirtualGL must be inserted into
the CrServer process on Node 0 to prevent it from sending <code>glDrawPixels()</code>
calls to the X server (which would effectively send uncompressed images
over the network.)  Instead, VirtualGL forces CrServer to draw into
a Pbuffer, and VGL takes charge of transmitting those pixels to the
destination X server in the most efficient way possible.</p>

<p>Since Chromium uses <code>dlopen()</code> to load the system&rsquo;s
OpenGL library, preloading VirtualGL into the CrAppFaker and CrServer
processes using <code>vglrun</code> is not sufficient.  Fortunately,
Chromium provides an environment variable, <code>CR_SYSTEM_GL_PATH</code>,
which allows one to specify an alternate path in which it will search
for the system&rsquo;s <code>libGL.so</code>.  The VirtualGL packages
for Linux and Solaris include a symbolic link named <code>libGL.so</code>
which really points to the VirtualGL faker library (<code>librrfaker.so</code>)
instead.  This symbolic link is located in its own isolated directory,
so that directory can be passed to Chromium in the <code>CR_SYSTEM_GL_PATH</code>
environment variable, thus causing Chromium to load VirtualGL rather
than the &ldquo;real&rdquo; OpenGL library. Refer to the following
table:</p>

<p><a name="CR_SYSTEM_GL_PATH_Table"></a></p>

<div class="table">
<table class="standard" align="center">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">32-bit Applications</th>
    <th class="head standard">64-bit Applications</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard"><code>/opt/VirtualGL/lib</code></td>
    <td class="standard"><code>/opt/VirtualGL/lib64</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris</td>
    <td class="standard"><code>/opt/SUNWvgl/fakelib</code></td>
    <td class="standard"><code>/opt/SUNWvgl/fakelib/64</code></td>
  </tr>
</table>
<div class="tableNote" style="text-align=center;"><code>CR_SYSTEM_GL_PATH</code> setting required to use VirtualGL with Chromium</div>
</div>


<p>Running the CrServer in VirtualGL is simply a matter of setting this
environment variable and then invoking <code>crserver</code> with <code>vglrun</code>,
e.g.:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/lib
vglrun&nbsp;crserver
</pre>

<p>In the case of CrAppFaker, it is also necessary to set <code>VGL_GLLIB</code>
to the location of the &ldquo;real&rdquo; OpenGL library, e.g. <code>/usr/lib/libGL.so.1</code>.
CrAppFaker creates its own fake version of <code>libGL.so</code> which
is really just a copy of Chromium&rsquo;s <code>libcrfaker.so</code>.
So VirtualGL, if left to its own devices, will unwittingly try to load
<code>libcrfaker.so</code> instead of the &ldquo;real&rdquo; OpenGL
library.  Chromium&rsquo;s <code>libcrfaker.so</code> will in turn
try to load VirtualGL again, and an endless loop will occur.</p>

<p>So what we want to do is something like this:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/lib
export&nbsp;VGL_GLLIB=/usr/lib/libGL.so.1
crappfaker
</pre>

<p>CrAppFaker will copy the application to a temp directory and then copy
<code>libcrfaker.so</code> to that same directory, renaming it as <code>libGL.so</code>.
So when the application is started, it loads <code>libcrfaker.so</code>
instead of <code>libGL.so</code>. <code>libcrfaker.so</code> will then
load VirtualGL instead of the &ldquo;real&rdquo; libGL, because we&rsquo;ve
overridden <code>CR_SYSTEM_GL_PATH</code> to make Chromium find VirtualGL&rsquo;s
fake <code>libGL.so</code> first.  VirtualGL will then use the library
specified in <code>VGL_GLLIB</code> to make any &ldquo;real&rdquo;
OpenGL calls that it needs to make.</p>

<p>Note that <code>crappfaker</code> should not be invoked with <code>vglrun</code>.</p>

<p>So, putting this all together, here is an example of how you might
start a sort-first rendering job using Chromium and VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-first rendering with readback
    </li>
    <li class="Ordered">
        Start <code>crserver</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table above)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered">
        On Node 0, set <code>VGL_GLLIB</code> to the location of the &ldquo;real&rdquo;
        libGL, e.g. <code>/usr/lib/libGL.so.1</code> or <code>/usr/lib64/libGL.so.1</code>
    </li>
    <li class="Ordered">
        On Node 0, launch <code>crappfaker</code> (do not use <code>vglrun</code>
        here)
    </li>
</ol>

<p>Again, it&rsquo;s always a good idea to make sure this works without
VirtualGL before adding VirtualGL into the mix.</p>

<div class="important"><p class="important">
When using VirtualGL with this mode, resizing the application window may not work properly.  This is because the resize event is sent to the application process, and therefore the CrServer process that&rsquo;s actually drawing the pixels has no way of knowing that a window resize has occurred. A possible fix is to modify Chromium such that it propagates the resize event down the render chain so that all of the CrServer processes are aware that a resize event occurred.
</p></div>


<h2 id="hd0013003">13.3&nbsp;Configuration 3: Sort-Last Rendering (Object-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-sortlast.png" alt="chromium-sortlast" class="figure" id="imgid_18" name="imgid_18"/>
</div>

<p>Sort-Last Rendering is used when the scene contains a huge number of
polygons and the rendering bottleneck is processing all of that geometry
on a single graphics card.  In this case, each node runs a separate
copy of the application, and for best results, the application needs
to be at least partly aware that it&rsquo;s running in a parallel environment
so that it can give Chromium hints as to how to distribute the various
objects to be rendered.  Each node generates an image of a particular
portion of the object space, and these images must be composited in
such a way that the front-to-back ordering of pixels is maintained.
This is generally done by collecting Z buffer data from each node to
determine whether a particular pixel on a particular node is visible
in the final image.  The rendered images from each node are often composited
using a &ldquo;binary swap&rdquo;, whereby the nodes combine their
images in a cascading tree so that the overall compositing time is
proportional to log<sub>2</sub>(N) rather than N.</p>

<p>To make this configuration work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-last rendering
    </li>
    <li class="Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table in Section
        <a href="#CR_SYSTEM_GL_PATH_Table" class="ref">13.2</a>.)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h3 id="hd0013003001">CRUT</h3>

<p>The Chromium Utility Toolkit provides a convenient way for graphics
applications to specifically take advantage of Chromium&rsquo;s sort-last
rendering capabilities.  Such applications can use CRUT to explicitly
specify how their object space should be decomposed.  CRUT applications
require an additional piece of software, <code>crutserver</code>, to
be running on Node 0.  So to make such applications work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-last rendering
    </li>
    <li class="Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table in Section
        <a href="#CR_SYSTEM_GL_PATH_Table" class="ref">13.2</a>.)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crutserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h2 id="hd0013004">13.4&nbsp;A Note About Performance</h2>

<p>Chromium&rsquo;s use of X11 is generally not very optimal.  It assumes
a very fast connection between the X server and the Chromium Server.
In certain modes, Chromium polls the X server on every frame to determine
whether windows have been resized, etc.  Thus, we have observed that,
even on a fast network, Chromium tends to perform much better with
VirtualGL running in a TurboVNC session as opposed to VirtualGL running
in Direct Mode.</p>


<h2 id="hd0013005">13.5&nbsp;ModViz VGP and VirtualGL</h2>

<p>ModViz Virtual Graphics Platform<sup>TM</sup> is a polished commercial
clustered rendering framework for Linux which supports all three of
the rendering modes described above and provides a much more straightforward
interface to configure and run these types of parallel rendering jobs.</p>

<p>All VGP jobs, regardless of configuration, are all spawned through
<code>vglauncher</code>, a front-end program which automatically takes
care of starting the appropriate processes on the rendering nodes,
intercepting OpenGL calls from the application instance(s), sending
rendered images back to Node 0, and compositing the images as appropriate.
In a similar manner to VirtualGL&rsquo;s <code>vglrun</code>, VGP&rsquo;s
vglauncher preloads a library (<code>libVGP.so</code>) in place of
<code>libGL.so</code>, and this library intercepts the OpenGL calls
from the application.</p>

<p>So our strategy here is similar to our strategy for loading the Chromium
App Faker.  We want to insert VirtualGL between VGP and the real system
OpenGL library, so that VGP will call VirtualGL and VirtualGL will
call <code>libGL.so</code>. Achieving this with VGP is relatively simple:</p>

<pre class="verbatim">
export&nbsp;VGP_BACKING_GL_LIB=librrfaker.so
vglrun&nbsp;vglauncher&nbsp;--preload=librrfaker.so:/usr/lib/libGL.so&nbsp;{application}
</pre>

<p>Replace <code>/usr/lib/libGL.so</code> with the full path of your system&rsquo;s
OpenGL library (<code>/usr/lib64/libGL.so</code> if you are launching
a 64-bit application.)</p>

<hr class="break" />


<h1 id="hd0014"><a name="file014"></a>14&nbsp;Other Application Recipes</h1>

<p><a name="Application_Recipes"></a></p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Application</th>
    <th class="head standard">Platform</th>
    <th class="head standard">Recipe</th>
    <th class="head standard">Notes</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Army Ops</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;armyops</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Descent 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;descent3&nbsp;-g&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;descent3</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Doom 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;doom3&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;doom3</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Enemy Territory (Return to Castle Wolfenstein)</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;et&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;et</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heretic II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;heretic2&nbsp;+set&nbsp;gl_driver&nbsp;/usr/lib/librrfaker.so&nbsp;+set&nbsp;vid_ref&nbsp;glx</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;heretic2&nbsp;+set&nbsp;vid_ref&nbsp;glx</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heavy Gear II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;hg2&nbsp;-o&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;hg2</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">I-deas Master Series 9, 10, &amp; 11</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">When running I-deas with VirtualGL on a Solaris/Sparc server, remotely displaying to a non-Sparc client machine or to an X proxy such as VNC, it may be necessary to set the <code>SDRC_SUN_IGNORE_GAMMA</code> environment variable to <code>1</code>.</td>
    <td class="standard">I-deas normally aborts if it detects that the X visual assigned to it is not gamma-corrected.  But gamma-corrected X visuals only exist on Solaris/Sparc X servers, so if you are displaying the application using another type of X server or X proxy which doesn&rsquo;t provide gamma-corrected X visuals, then it is necessary to override the gamma detection mechanism in I-deas.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Java2D applications that use OpenGL</td>
    <td class="standard">Linux, Solaris</td>
    <td class="standard">Java2D will use OpenGL to perform its rendering if <code>sun.java2d.opengl</code> is set to <code>True</code>, e.g.: <br /><br /> <code>java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /> In order for this to work in VirtualGL, it is necessary to invoke <code>vglrun</code> with the <code>-dl</code> switch, e.g.: <br /><br /> <code>vglrun&nbsp;-dl&nbsp;java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /> If you are using Java v6 b92 or later, you can also set the environment variable <code>J2D_ALT_LIBGL_PATH</code> to the path of <code>librrfaker.so</code>, e.g.: <br /><br /> <code>setenv&nbsp;J2D_ALT_LIBGL_PATH&nbsp;/opt/SUNWvgl/lib/librrfaker.so</code><br /> <code>vglrun&nbsp;java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Pro/ENGINEER Wildfire v2.0</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">Add <br /><br /> <code>graphics&nbsp;opengl</code> <br /><br /> to <code>~/config.pro</code>.  You may also need to set the <code>VGL_XVENDOR</code> environment variable to <code>&quot;Sun&nbsp;Microsystems,&nbsp;Inc.&quot;</code> if you are running Pro/ENGINEER 2.0 over a remote X connection to a Linux or Windows VirtualGL client.</td>
    <td class="standard">Pro/E 2.0 for Solaris will disable OpenGL if it detects a remote connection to a non-Sun X server.</td>
  </tr>
  <tr class="standard">
    <td class="standard">QGL (OpenGL Qt Widget)</td>
    <td class="standard">Linux</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;{application}</code></td>
    <td class="standard">Qt can be built such that it either resolves symbols from libGL automatically or uses <code>dlopen()</code> to manually resolve those symbols from libGL.  As of Qt v3.3, the latter behavior is the default, so OpenGL programs built with later versions of libQt will not work with VirtualGL unless the <code>-dl</code> switch is used with <code>vglrun</code>. <br /><br /> See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Quake 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;quake3&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;quake3</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Soldier of Fortune</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;sof&nbsp;+set&nbsp;gl_driver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;sof</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Unreal Tournament 2004</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;ut2004</code></td>
    <td class="standard">See Section <a href="#dlopen" class="ref">12</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">VisConcept</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">Set the environment variable <code>VGL_GUI_XTTHREADINIT</code> to <code>0</code>.</td>
    <td class="standard">Popping up the VirtualGL configuration dialog may cause the application to hang unless you set this environment variable.  See Section <a href="#VGL_GUI_XTTHREADINIT" class="ref">18.1</a> for more details.</td>
  </tr>
</table>
</div>


<hr class="break" />


<h1 id="hd0015"><a name="file015"></a>15&nbsp;Advanced OpenGL Features</h1>

<p><a name="Advanced_OpenGL"></a></p>


<h2 id="hd0015001">15.1&nbsp;Stereo</h2>

<p>The general idea behind VirtualGL is to offload the 3D rendering work
to the server so that the client only needs the ability to draw 2D
images.  But unfortunately, there is no way to draw stereo images using
2D (X11) commands, so the VirtualGL client must use OpenGL to draw
in stereo.  When an application requests a stereo visual, VirtualGL
will attempt to ascertain whether the client supports OpenGL and, if
so, whether it has stereo visuals available. VirtualGL then checks
the server&rsquo;s display to see whether it has stereo visuals available
as well.  If both are true, then VirtualGL will return a stereo visual
to the application.  If, for any given frame, VirtualGL detects that
the application has drawn something to one of the right eye buffers,
it will read back both eye buffers and send the contents as a pair
of compressed images (one for each eye) to the VirtualGL client.  The
VGL client then decompresses the stereo image pair and draws it as
a single stereo frame to the client&rsquo;s display using <code>glDrawPixels()</code>.</p>

<p>The upshot of this is that, in order to use stereo in VirtualGL, the
client machine must support OpenGL and GLX (Exceed 3D is required for
Windows clients) and must have a graphics card (such as the nVidia
Quadro, etc.) which is capable of drawing in stereo.  It is usually
necessary to explicitly enable stereo visuals in the graphics card
configuration for both the client and server machines.  Use <code>glxinfo</code>
to verify whether or not stereo visuals are enabled on both client
and server before attempting to run VirtualGL with a stereo application.</p>

<div class="important"><p class="important">
Stereo requires Direct Mode.  If VirtualGL is running in Raw Mode and the application renders something in stereo, only the contents of the left eye buffer will be sent to the display.
</p></div>


<h2 id="hd0015002">15.2&nbsp;Transparent Overlays</h2>

<p>Transparent overlays have similar requirements and restrictions to
stereo.  In this case, VirtualGL completely bypasses its own GLX faker
and uses indirect OpenGL rendering to render the transparent overlay
on the client machine&rsquo;s 3D hardware.  The underlay is still rendered
on the server, as always.  Using indirect rendering to render the overlay
is unfortunately necessary, because there is no reliable way to draw
to an overlay using 2D (X11) functions, there are severe performance
issues (on some cards) with using <code>glDrawPixels()</code> to draw
to the overlay, and there is no reasonable way to composite the overlay
and underlay on the server machine.</p>

<p>However, overlays are generally used only for drawing small, simple,
static shapes and text, so we have found that it is usually faster
to send the overlay geometry over to the client rather than rendering
it as an image and sending the image.  So even if it were possible
to implement overlays without using indirect rendering, it&rsquo;s
likely that indirect rendering would still be the fastest approach.</p>

<p>As with stereo, overlays often must be explicitly enabled in the graphics
card&rsquo;s configuration.  In the case of overlays, however, they
need only be supported and enabled on the client machine.</p>

<p>Indexed color (8-bit) overlays have been tested and are known to work
with nVidia Quadro hardware.  True color (24-bit) overlays will probably
work as well, but they have not been tested.  Use <code>glxinfo</code>
to verify whether your client&rsquo;s X display supports overlays and
whether they are enabled.  In Exceed 3D, make sure that the &ldquo;Overlay
Support&rdquo; option is checked in the &ldquo;Exceed 3D and GLX&rdquo;
applet:</p>

<p><img src="exceed6.png" alt="exceed6" class="inline" id="imgid_8" name="imgid_8"/></p>

<div class="important"><p class="important">
As with stereo, overlays do not work inside an X proxy session. VirtualGL must be displaying to a real X server on the client machine.
</p></div>


<h2 id="hd0015003">15.3&nbsp;Indexed (PseudoColor) Rendering</h2>

<p>In a PseudoColor visual, each pixel is represented by an index which
refers to a location in a color table.  The color table stores the
actual color values (256 of them in the case of 8-bit PseudoColor)
which correspond to each index. An application merely tells the X server
which color index to use when drawing, and the X server takes care
of mapping that index to an actual color from the color table.  OpenGL
allows for rendering to Pseudocolor visuals, and it does so by being
intentionally ignorant of the relationship between indices and actual
colors.  As far as OpenGL is concerned, each color index value is just
a meaningless number, and it is only when the final image is drawn
by the X server that these numbers take on meaning.  As a result, many
pieces of OpenGL&rsquo;s core functionality, such as lighting and shading,
either have undefined behavior or do not work at all with PseudoColor
rendering. PseudoColor rendering used to be a common technique to visualize
scientific data, because such data often only contained 8 bits per
sample to begin with. Applications could manipulate the color table
to allow the user to dynamically control the relationship between sample
values and colors.  As more and more graphics cards drop support for
PseudoColor rendering, however, the applications which use it are a
vanishing breed.</p>

<p>VirtualGL supports PseudoColor rendering if a PseudoColor visual is
available on the client&rsquo;s display.  A PseudoColor visual need
not be present on the server.  On the server, VirtualGL uses the red
channel of a standard RGB Pbuffer to store the color index.  Upon receiving
an end of frame trigger, VirtualGL reads back the red channel of the
Pbuffer and uses <code>XPutImage()</code> to draw it into the appropriate
window.  The upshot of this is that there is no compression with PseudoColor
rendering in VirtualGL.  However, since there is only 1 byte per pixel
in this mode, the images can still be sent to the client reasonably
quickly even though they are uncompressed.</p>

<p>PseudoColor rendering should work in VNC, provided that the VNC server
is configured for 8-bit Pseudocolor.  TurboVNC does not support PseudoColor,
but RealVNC and other VNC flavors do.  Note, however, that VNC cannot
provide both PseudoColor and TrueColor visuals at the same time.</p>

<hr class="break" />


<h1 id="hd0016"><a name="file016"></a>16&nbsp;Performance Measurement</h1>

<p><a name="Perf_Measurement"></a></p>


<h2 id="hd0016001">16.1&nbsp;VirtualGL&rsquo;s Built-In Profiling System</h2>

<p>The easiest way to uncover bottlenecks in the VirtualGL pipeline is
to set the <code>VGL_PROFILE</code> environment variable to <code>1</code>
on both server and client (passing an argument of <code>+pr</code>
to <code>vglrun</code> on the server has the same effect.)  This will
cause VirtualGL to measure and report the throughput of the various
stages in its pipeline.  For example, here are some measurements from
a dual Pentium 4 server communicating with a Pentium III client on
a 100 Mbit LAN:</p>

<dl class="Description">
    <dt class="Description">Server</dt>
    <dd class="Description">
<pre class="verbatim">
Readback&nbsp;&nbsp;&nbsp;-&nbsp;43.27&nbsp;Mpixels/sec&nbsp;-&nbsp;34.60&nbsp;fps
Compress&nbsp;0&nbsp;-&nbsp;33.56&nbsp;Mpixels/sec&nbsp;-&nbsp;26.84&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.02&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.41&nbsp;fps&nbsp;-&nbsp;10.19&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
    <dt class="Description">Client</dt>
    <dd class="Description">
<pre class="verbatim">
Decompress&nbsp;-&nbsp;10.35&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;8.28&nbsp;fps
Blit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;35.75&nbsp;Mpixels/sec&nbsp;-&nbsp;28.59&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.00&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.40&nbsp;fps&nbsp;-&nbsp;10.18&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
</dl>

<p>The total throughput of the pipeline is 8.0 Mpixels/sec, or 6.4 frames/sec,
indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels in size (a
little less than 1280 x 1024 pixels.)  The readback and compress stages,
which occur in parallel on the server, are obviously not slowing things
down.  And we&rsquo;re only using 1/10 of our available network bandwidth.
So we look to the client and discover that its slow decompression speed
is the primary bottleneck. Decompression and blitting on the client
do not occur in parallel, so the aggregate performance is the harmonic
mean of the two rates: <em>[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec</em>.</p>


<h2 id="hd0016002">16.2&nbsp;Frame Spoiling</h2>

<p>By default, VirtualGL will only send a frame to the client if the client
is ready to receive it.  If a rendered frame arrives at the server&rsquo;s
queue and a previous frame is still being processed, the new frame
is dropped (&ldquo;spoiled.&rdquo;) This prevents a backlog of frames
on the server, which would cause a perceptible delay in the responsiveness
of interactive applications.  But when running non-interactive applications,
particularly benchmarks, it may be desirable to disable frame spoiling.
With frame spoiling disabled, the server will render frames only as
quickly as the VirtualGL pipeline can receive them, which will conserve
server resources as well as allow OpenGL benchmarks to accurately measure
the throughput of the VirtualGL pipeline.  With frame spoiling enabled,
these benchmarks will report meaningless data, since they are measuring
the server&rsquo;s rendering rate, and that rendering rate is decoupled
from the overall throughput of VirtualGL.</p>

<p>To disable frame spoiling, set the <code>VGL_SPOIL</code> environment
variable to <code>0</code> on the server or pass an argument of <code>-sp</code>
to <code>vglrun</code>.  See Section <a href="#VGL_SPOIL" class="ref">18.1</a>
for more details.</p>


<h2 id="hd0016003">16.3&nbsp;VirtualGL Diagnostic Tools</h2>

<p>VirtualGL includes several tools which can be useful in diagnosing
performance problems with the system.</p>


<h3 id="hd0016003001">NetTest</h3>

<p>NetTest is a low-level network benchmark that uses the same network
classes as VirtualGL.  It can be used to test the latency and throughput
of any TCP/IP connection, with or without SSL encryption.  The VirtualGL
Linux package installs NetTest in <code>/opt/VirtualGL/bin</code>.
The VirtualGL Solaris package installs it in <code>/opt/SUNWvgl/bin</code>.
The Windows installer installs it in <code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code>
by default.</p>

<p>To use NetTest, first start up the nettest server on one end of the
connection:</p>

<pre class="verbatim">
nettest&nbsp;-server&nbsp;[-ssl]
</pre>

<p>(use <code>-ssl</code> if you want to test the performance of SSL encryption
over this particular connection.)</p>

<p>Next, start the client on the other end of the connection:</p>

<pre class="verbatim">
nettest&nbsp;-client&nbsp;{server_name}&nbsp;[-ssl]
</pre>

<p>(<code>server_name</code> is the hostname or IP address of the machine
where the NetTest server is running.  Use <code>-ssl</code> if the
NetTest server is running in SSL mode.)</p>

<p>The nettest client will produce output similar to the following:</p>

<pre class="verbatim">
TCP&nbsp;transfer&nbsp;performance&nbsp;between&nbsp;localhost&nbsp;and&nbsp;{server}:

Transfer&nbsp;size&nbsp;&nbsp;1/2&nbsp;Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput
(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(msec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MB/sec)
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.176896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.005391
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.179391&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.010632
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.021006
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181292&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.042083
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181694&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.083981
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181690&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.167965
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.182010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.335339
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.182197&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.669991
256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183593&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.329795
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.656586
1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.186189&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.245015
2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.379702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.143834
4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.546805&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.143778
8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.908712&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.597335
16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.643810&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.505359
32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.961701&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.551368
65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.769007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.833754
131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.313003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.049232
262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22.412990&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.154246
524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44.760510&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.170561
1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89.294810&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.198859
2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;178.426602&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.209091
4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;356.547194&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.218711
</pre>

<p>We can see that the throughput peaks out at about 11.2 MB/sec.  1 MB
= 1048576 bytes, so 11.2 MB/sec = 94 million bits per second, which
is pretty good for a 100 Mbit connection.  We can also see that, as
the transfer size decreases, the round-trip time becomes dominated
by latency.  The latency is the same thing as the 1/2 round-trip time
for a zero-byte packet, which is about 0.18 ms in this case.</p>


<h3 id="hd0016003002">CPUstat</h3>

<p>CPUstat is available only in the VirtualGL Linux packages and is located
in the same place as NetTest (<code>/opt/VirtualGL/bin</code>.)  It
measures the average, minimum, and peak CPU usage for all processors
combined and for each processor individually.  On Windows, this same
functionality is provided in the Windows Performance Monitor, which
is part of the operating system.</p>

<p>CPUstat measures the CPU usage over a given sample period (a few seconds)
and continuously reports how much the CPU was utilized since the last
sample period.  Output for a particular sample looks something like
this:</p>

<pre class="verbatim">
ALL&nbsp;:&nbsp;&nbsp;51.0&nbsp;(Usr=&nbsp;47.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;3.5)&nbsp;/&nbsp;Min=&nbsp;47.4&nbsp;Max=&nbsp;52.8&nbsp;Avg=&nbsp;50.8
cpu0:&nbsp;&nbsp;20.5&nbsp;(Usr=&nbsp;19.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;1.0)&nbsp;/&nbsp;Min=&nbsp;19.4&nbsp;Max=&nbsp;88.6&nbsp;Avg=&nbsp;45.7
cpu1:&nbsp;&nbsp;81.5&nbsp;(Usr=&nbsp;75.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;6.0)&nbsp;/&nbsp;Min=&nbsp;16.6&nbsp;Max=&nbsp;83.5&nbsp;Avg=&nbsp;56.3
</pre>

<p>The first column indicates what percentage of time the CPU was active
since the last sample period (this is then broken down into what percentage
of time the CPU spent running user, nice, and system/kernel code.)
&ldquo;ALL&rdquo; indicates the average utilization across all CPU&rsquo;s
since the last sample period.  &ldquo;Min&rdquo;, &ldquo;Max&rdquo;,
and &ldquo;Avg&rdquo; indicate a running minimum, maximum, and average
of all samples since cpustat was started.</p>

<p>Generally, if an application&rsquo;s CPU usage is fairly steady, you
can run CPUstat for a bit and wait for the Max. and Avg. for the &ldquo;ALL&rdquo;
category to stabilize, then that will tell you what the application&rsquo;s
peak and average % CPU utilization is.</p>


<h3 id="hd0016003003">TCBench</h3>

<p>TCBench was born out of the need to compare VirtualGL&rsquo;s performance
to other thin client packages, some of which had frame spoiling features
that couldn&rsquo;t be disabled.  TCBench measures the frame rate of
a thin client system as seen from the client&rsquo;s point of view.
It does this by attaching to one of the client windows and continuously
reading back a small area at the center of the window.  While this
may seem to be a somewhat non-rigorous test, experiments have shown
that if care is taken to make sure that the application is updating
the center of the window on every frame (such as in a spin animation),
TCBench can produce quite accurate results.  It has been sanity checked
with VirtualGL&rsquo;s internal profiling mechanism and with a variety
of system-specific techniques, such as monitoring redraw events on
the client&rsquo;s windowing system.</p>

<p>The VirtualGL Linux package installs TCBench in <code>/opt/VirtualGL/bin</code>.
The VirtualGL Solaris package installs TCBench in <code>/opt/SUNWvgl/bin</code>.
The Windows installer installs it in <code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code>
by default.  Run <code>tcbench</code> from the command line, and it
will prompt you to click in the window you want to measure.   That
window should already have an automated animation of some sort running
before you launch TCBench.</p>

<p>TCBench can also be used to measure the frame rate of applications
that are running on the local console, although for extremely fast
applications (those that exceed 40 fps on the local console), you may
need to increase the sampling rate of TCBench to get accurate results.
The default sampling rate of 50 samples/sec should be fine for measuring
the throughput of VirtualGL and other thin client systems.</p>

<pre class="verbatim">
tcbench&nbsp;-?
</pre>

<p>gives the relevant command line switches that can be used to adjust
the benchmark time, the sampling rate, and the x and y offset of the
sampling area within the window.</p>

<hr class="break" />


<h1 id="hd0017"><a name="file017"></a>17&nbsp;The VirtualGL Configuration Dialog</h1>

<p><a name="Config_Dialog"></a></p>

<p>Several of VirtualGL&rsquo;s configuration parameters can be changed
on the fly once an application has started.  This is accomplished by
using the VirtualGL configuration dialog, which can be activated by
holding down the <code>CTRL</code> and <code>SHIFT</code> keys and
pressing the <code>F9</code> key while any one of the application&rsquo;s
windows is active.  This displays a dialog box similar to the following:</p>

<p><img src="configdialog.gif" alt="configdialog" class="inline" id="imgid_9" name="imgid_9"/></p>

<p>You can use this dialog to enable or disable frame spoiling or to adjust
the JPEG quality and subsampling.  Changes are reflected immediately
in the application.</p>

<dl class="Description">
    <dt class="Description">Frame Spoiling</dt>
    <dd class="Description">
        Clicking on this button will toggle frame spoiling on and off.  If
        the button is highlighted (black), then frame spoiling is enabled.
    </dd>
    <dt class="Description">Qual Preset: Broadband/T1</dt>
    <dd class="Description">
        Clicking on this button will set the JPEG quality to 30 and the JPEG
        subsampling to 4:1:1, settings which will produce good performance
        on broadband connections (but at the expense of image quality.)
    </dd>
    <dt class="Description">Qual Preset: LAN</dt>
    <dd class="Description">
        Clicking on this button will set the JPEG quality to 95 and the JPEG
        subsampling to 4:4:4, settings which will produce perceptually lossless
        image quality (100 Mbit/sec switched LAN recommended.)
    </dd>
    <dt class="Description">JPEG Quality</dt>
    <dd class="Description">
        Click and drag the slider to change the JPEG quality to an arbitrary
        value between 1 and 100.
    </dd>
    <dt class="Description">JPEG Subsampling</dt>
    <dd class="Description">
        Click on any of the three buttons to change the JPEG subsampling. 
        The highlighted (black) button indicates the current value.
    </dd>
    <dt class="Description">Close Dialog</dt>
    <dd class="Description">
        Close the dialog (you can also use the close gadget on the dialog window)
    </dd>
</dl>
<div class="important"><p class="important">
The JPEG quality and subsampling gadgets will only be shown if VirtualGL is running in direct mode.  In raw mode, the only setting that can be changed with this dialog is frame spoiling.
</p></div>

<p>The <code>VGL_GUI</code> environment variable can be used to change
the key sequence used to pop up the dialog box.  If the default of
<code>CTRL-SHIFT-F9</code> is not suitable, then set <code>VGL_GUI</code>
to any combination of <code>ctrl</code>, <code>shift</code>, <code>alt</code>,
and one of <code>{f1,&nbsp;f2,...,&nbsp;f12}</code> (these are not
case sensitive.)  e.g.</p>

<pre class="verbatim">
export&nbsp;VGL_GUI=CTRL-F9
</pre>

<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code> is
pressed.</p>

<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code>
to <code>none</code>.</p>

<div class="important"><p class="important">
VirtualGL monitors the application&rsquo;s X event loop to determine whenever a particular key sequence has been pressed.  If an application is not monitoring key press events in its X event loop, then the VirtualGL configuration dialog might not pop up at all.  There is unfortunately no workaround for this, but it should be a rare occurrence.
</p></div>

<hr class="break" />


<h1 id="hd0018"><a name="file018"></a>18&nbsp;Advanced Configuration</h1>

<p><a name="Advanced_Configuration"></a></p>


<h2 id="hd0018001">18.1&nbsp;Server Settings</h2>

<p>You can control the operation of the VirtualGL faker in four different
ways. Each method of configuration takes precedence over the previous
method:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Setting a configuration environment variable globally (e.g. in <code>/etc/profile</code>)
    </li>
    <li class="Ordered">
        Setting a configuration environment variable on a per-user basis (e.g.
        in <code>~/.bashrc</code>)
    </li>
    <li class="Ordered">
        Setting a configuration environment variable only for the current shell
        session (e.g. <code>export&nbsp;VGL_XXX={whatever}</code>)
    </li>
    <li class="Ordered">
        Passing a configuration option as an argument to <code>vglrun</code>.
        This effectively overrides any previous environment variable setting
        corresponding to that configuration option.
    </li>
</ol>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Environment Variable Name</th>
    <th class="head standard"><code>vglrun</code> Command-Line Override</th>
    <th class="head standard">Description</th>
    <th class="head standard">Default Value</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>VGL_CLIENT</code></td>
    <td class="standard"><code>-cl&nbsp;&lt;client</code><br /><code>display&gt;</code></td>
    <td class="standard"><em>The X display where VirtualGL should send its image stream</em> <br /><br /> When running in Direct Mode, VirtualGL uses a dedicated TCP/IP connection to transmit compressed images of an application&rsquo;s OpenGL rendering area from the application server to the client display.  Thus, the server needs to know on which machine the VirtualGL client software is running, and it needs to know which X display on that machine will be used to draw the application&rsquo;s GUI.  VirtualGL can normally surmise this by reading the application server&rsquo;s <code>DISPLAY</code> environment variable.  But in cases where X11 traffic is tunneled through SSh or LBX or another type of indirect X11 connection, the <code>DISPLAY</code> environment variable on the application server may not point to the client machine.  In these cases, set <code>VGL_CLIENT</code> to the display where the application&rsquo;s GUI will end up, e.g. <br /><br /> <code>export&nbsp;VGL_CLIENT={my_client_machine}:0.0</code> <br /><br /> <em>** This option has no effect in Raw Mode. **</em></td>
    <td class="standard">Read from the <code>DISPLAY</code> environment</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_COMPRESS=0</code><br /><code>VGL_COMPRESS=1</code></td>
    <td class="standard"><code>-c&nbsp;&lt;0,&nbsp;1&gt;</code></td>
    <td class="standard"><em>0 = Raw Mode (send rendered images uncompressed via. X11),</em><br /> <em>1 = Direct Mode (compress rendered images as JPEG &amp; send on a separate socket)</em> <br /><br /> When this option is set to 0, VirtualGL will bypass its internal image compression pipeline and instead use <code>XPutImage()</code> to composite the rendered 3D images into the appropriate application window.  This mode (&ldquo;Raw Mode&rdquo;) is primarily useful in conjunction with VNC, NX, or other remote display software that performs X11 rendering on the server and uses its own mechanism for compressing and transporting images to the client.  Enabling Raw Mode on a remote X11 connection is not advisable, since it will result in uncompressed images being sent over the network. <br /><br /> If this option is not specified, then VirtualGL&rsquo;s default behavior is to use Direct Mode when the application is being displayed to a remote X server and to use Raw Mode otherwise.  VirtualGL assumes that if the <code>DISPLAY</code> environment variable begins with a colon or with &ldquo;<code>unix:</code>&rdquo; (e.g. &ldquo;<code>:0.0</code>&rdquo;, &ldquo;<code>unix:1000.0</code>&rdquo;, etc.), then the X11 connection is local and thus doesn&rsquo;t require image compression.  Otherwise, it assumes that the X11 connection is remote and that compression is required.  If the display string begins with &ldquo;<code>localhost</code>&rdquo; or with the server&rsquo;s hostname, VGL assumes that the display is being tunneled through SSh, and it enables Direct Mode in this case. <br /><br /> <em>NOTE:  Stereo does not work with Raw Mode.</em> <br /><br /> See Section <a href="#Raw_Mode_Usage" class="ref">9</a> for more details.</td>
    <td class="standard">Compression enabled (&ldquo;Direct Mode&rdquo;) if the application is displaying to a remote X server, disabled (&ldquo;Raw Mode&rdquo;) otherwise</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_DISPLAY</code></td>
    <td class="standard"><code>-d&nbsp;&lt;display&nbsp;or</code><br /><code>GLP&nbsp;device&gt;</code></td>
    <td class="standard"><em>The display or GLP device to use for 3D rendering</em> <br /><br /> If your server has multiple 3D graphics cards and you want the OpenGL rendering to be redirected to a display other than :0, set <code>VGL_DISPLAY=:1.0</code> or whatever.  This could be used, for instance, to support many application instances on a beefy multi-pipe graphics server. <br /><br /> <em>GLP mode (Solaris/Sparc only):</em> <br /><br /> Setting this option to <code>GLP</code> will enable GLP mode and select the first available GLP device for rendering.  You can also set this option to the pathname of a specific GLP device (e.g. <code>/dev/fbs/jfb0</code>.)  GLP is a special feature of Sun&rsquo;s OpenGL library which allows an application to render into Pbuffers on a graphics card even if there is no X server running on that graphics card.  See Section <a href="#GLP_Usage" class="ref">11</a> for more details on GLP.</td>
    <td class="standard">:0</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_FPS</code></td>
    <td class="standard"><code>-fps&nbsp;&lt;floating</code><br /><code>point&nbsp;number</code><br /><code>greater&nbsp;than&nbsp;0&gt;</code></td>
    <td class="standard"><em>Limit the client/server frame rate to the specified number of frames per second</em> <br /><br /> Setting <code>VGL_FPS</code> or passing <code>-fps</code> as an argument to <code>vglrun</code> will enable VirtualGL&rsquo;s frame rate governor.  When enabled, the frame rate governor will attempt to limit the overall throughput of the VirtualGL pipeline to the specified number of frames/second.  If frame spoiling is disabled, this effectively limits the server&rsquo;s rendering frame rate as well.  This option applies regardless of whether VirtualGL is being run in Direct Mode (with compression enabled) or in Raw Mode (with compression disabled.)</td>
    <td class="standard">Frame rate governor disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_GAMMA=0</code><br /><code>VGL_GAMMA=1</code><br /><code>VGL_GAMMA=&lt;gamma</code><br /> <code>correction</code><br /><code>factor</code>&gt;</td>
    <td class="standard"><code>-g</code><br />or<br /><code>+g</code><br />or<br /><code>-gamma&nbsp;&lt;gamma</code><br /><code>correction</code> <br /><code>factor&gt;</code></td>
    <td class="standard">&ldquo;Gamma&rdquo; refers to the relationship between the intensity of light which your computer&rsquo;s monitor is instructed to display and the intensity which it actually displays.  The curve is an exponential curve of the form <em>Y = X<sup>G</sup></em>, where X is between 0 and 1.  G is called the &ldquo;gamma&rdquo; of the monitor.  PC monitors and TV&rsquo;s usually have a gamma of around 2.2. <br /><br /> Some of the math involved in 3D rendering assumes a linear gamma (G = 1.0), so technically speaking, 3D applications will not display with mathematical correctness unless the pixels are &ldquo;gamma corrected&rdquo; to counterbalance the non-linear response curve of the monitor.  But some systems do not have any form of built-in gamma correction, and thus the applications developed for such systems have usually been designed to display properly without gamma correction.  Gamma correction involves passing pixels through a function of the form <em>X = W<sup>1/G</sup></em>, where G is the &ldquo;gamma correction factor&rdquo; and should be equal to the gamma of the monitor.  So the final output is <em>Y = X<sup>G</sup> = (W<sup>1/G</sup>)<sup>G</sup> = W</em>, which describes a linear relationship between the intensity of the pixels drawn by the application and the intensity of the pixels displayed by the monitor. <br /><br /> <em><code>VGL_GAMMA=1</code> or <code>vglrun&nbsp;+g</code> : Enable gamma correction with default settings</em> <br /><br /> This option tells VirtualGL to enable gamma correction using the best available method.  If VirtualGL is remotely displaying to a Solaris/Sparc X server which has gamma-corrected X visuals, then VGL will attempt to assign one of these visuals to the application.  This causes the 3D output of the application to be gamma corrected by the factor specified in <code>fbconfig</code> on the client machine (default: 2.22.)  Otherwise, if the X server (or proxy) does not have gamma-corrected X visuals or if the gamma-corrected visuals it has do not match the application&rsquo;s needs, then VirtualGL performs gamma correction internally and uses a default gamma correction factor of 2.22.  This option emulates the default behavior of OpenGL applications running locally on Sparc machines. <br /><br /> <em><code>VGL_GAMMA=0</code> or <code>vglrun&nbsp;-g</code> : Disable gamma correction</em> <br /><br /> This option tells VGL not to use gamma-corrected visuals, even if they are available on the X server, and disables VGL&rsquo;s internal gamma correction system as well.  This emulates the default behavior of OpenGL applications running locally on Linux or Solaris/x86 machines. <br /><br /> <em><code>VGL_GAMMA={gamma&nbsp;correction&nbsp;factor}</code> or <code>vglrun&nbsp;-gamma&nbsp;{gamma&nbsp;correction&nbsp;factor}</code> : Enable VGL&rsquo;s internal gamma correction system with the specified gamma correction factor</em> <br /><br /> If <code>VGL_GAMMA</code> is set to an arbitrary floating point value, then VirtualGL performs gamma correction internally using the specified value as the gamma correction factor.  You can also specify a negative value to apply a &ldquo;de-gamma&rdquo; function.  Specifying a gamma correction factor of G (where G &lt; 0) is equivalent to specifying a gamma correction factor of -1/G.</td>
    <td class="standard"><code>VGL_GAMMA=1</code> on Solaris/Sparc VGL servers, <code>VGL_GAMMA=0</code> otherwise</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_GLLIB</code></td>
    <td class="standard"></td>
    <td class="standard"><em> The location of an alternate OpenGL library</em> <br /><br /> Normally, VirtualGL loads the first OpenGL dynamic library that it finds in the dynamic linker path (usually <code>/usr/lib/libGL.so.1</code>, <code>/usr/lib64/libGL.so.1</code>,  or <code>/usr/lib/64/libGL.so.1</code>.)  You can use this setting to explicitly specify another OpenGL dynamic library to load. <br /><br /> Normally, you shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t work.  However, this setting is necessary when using VirtualGL with <a href="#Chromium">Chromium</a><a name="idx0048"></a>.</td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_GUI</code></td>
    <td class="standard"></td>
    <td class="standard"><em>Key sequence used to invoke the configuration dialog</em> <br /><br /> VirtualGL will normally monitor an application&rsquo;s X event queue and pop up the VirtualGL configuration dialog whenever <code>CTRL-SHIFT-F9</code> is pressed. In the event that this interferes with a key sequence that the application is already using, you can redefine the key sequence used to pop up VGL&rsquo;s configuration dialog by setting <code>VGL_GUI</code> to some combination of <code>shift</code>, <code>ctrl</code>, <code>alt</code>, and one of <code>{f1,&nbsp;f2,&nbsp;...,&nbsp;f12}</code>.  You can also set <code>VGL_GUI</code> to <code>none</code> to disable the configuration dialog altogether.  See Section <a href="#Config_Dialog" class="ref">17</a> for more details.</td>
    <td class="standard">shift-ctrl-f9</td>
  </tr>
  <tr class="standard">
    <td class="standard"><a name="VGL_GUI_XTTHREADINIT"></a> <code>VGL_GUI_XTTHREADINIT</code></td>
    <td class="standard"></td>
    <td class="standard"><em>0 to prevent VGL from calling <code>XtToolkitThreadInitialize()</code></em> <br /><br /> Xt &amp; Motif applications are supposed to call <code>XtToolkitThreadInitialize()</code> if they plan to access Xt functions from two or more threads simultaneously.  But rarely, a multi-threaded Xt/Motif application may avoid calling <code>XtToolkitThreadInitialize()</code> and rely on the fact that avoiding this call disables application and process locks.  This behavior is generally considered errant on the part of the application, but the application developers have probably figured out other ways around the potential instability that this situation creates. <br /><br /> The problem arises whenever VirtualGL pops up its configuration dialog (which is written using Xt.)  In order to create this dialog, VirtualGL creates a new Xt thread and calls <code>XtToolkitThreadInitialize()</code> as it is supposed to do to guarantee thread safety.  But if the application into which VGL is loaded exhibits the errant behavior described above, suddenly enabling application and process locks may cause the application to deadlock.  Setting <code>VGL_GUI_XTTHREADINIT</code> to <code>0</code> will remove VGL&rsquo;s call to <code>XtToolkitThreadInitialize()</code> and should thus eliminate the deadlock.<br /><br /> In short, if you try to pop up the VirtualGL config dialog and notice that it hangs the application, try setting <code>VGL_GUI_XTTHREADINIT</code> to <code>0</code>.</td>
    <td class="standard">1</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_NPROCS&nbsp;</code></td>
    <td class="standard"><code>-np&nbsp;&lt;#&nbsp;of&nbsp;CPUs&gt;</code><br />or<br /><code>-np&nbsp;0</code><br /> (automatically determine the optimal number of CPUs to use)</td>
    <td class="standard"><em>Specify the number of CPUs to use for multi-threaded compression</em> <br /><br /> VirtualGL can divide the task of compressing each frame among multiple server CPUs.  This might speed up the overall throughput if the compression stage of the pipeline is the primary bottleneck.  The default behavior (equivalent to setting <code>VGL_NPROCS=0</code>) is to use all but one of the available CPUs, up to a maximum of 3 total.  On a large multiprocessor system, the speedup is almost linear up to 3 processors, but the algorithm scales very little past that point.  VirtualGL will not allow more than 4 processors total to be used for compression, nor will it allow you to assign more processors than are available in the system. <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">1P system: 1<br /> 2P system: 1<br /> 3P system: 2<br /> 4P &amp; larger: 3</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_PORT</code></td>
    <td class="standard"><code>-p&nbsp;&lt;port&gt;</code></td>
    <td class="standard"><em>The TCP port to use when connecting to the client</em> <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">4242 for unencrypted connections, 4243 for SSL connections</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_PROFILE=0</code><br /><code>VGL_PROFILE=1</code></td>
    <td class="standard"><code>-pr</code><br />or<br /><code>+pr</code></td>
    <td class="standard"><em>Enable/disable profiling output</em> <br /><br /> If enabled, this will cause the VirtualGL faker to continuously benchmark itself and periodically print out the throughput of reading back, compressing, and sending pixels to the client. <br /><br /> See Section <a href="#Perf_Measurement" class="ref">16</a> for more details.</td>
    <td class="standard">Profiling disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_QUAL</code></td>
    <td class="standard"><code>-q&nbsp;&lt;1-100&gt;</code></td>
    <td class="standard"><em>An integer between 1 and 100 (inclusive)</em> <br /><br /> This setting allows you to specify the quality of the JPEG compression. Lower is faster but also grainier.  The default setting should produce perceptually lossless performance. <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">95</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_READBACK=0</code><br /><code>VGL_READBACK=1</code></td>
    <td class="standard"></td>
    <td class="standard"><em>Enable/disable readback</em> <br /><br /> On rare occasions, it might be desirable to have VirtualGL redirect OpenGL rendering from an application into a Pbuffer but not automatically read back and send the rendered pixels.  Some applications have their own mechanisms for reading back the buffer, so disabling VirtualGL&rsquo;s readback mechanism prevents duplication of effort. <br /><br /> This feature was developed initially to support running <span class="remote"><a href="http://www.paraview.org/" class="remote">ParaView</a></span><a name="idx0049"></a> in parallel using MPI.  ParaView MPI normally uses MPI processes 1 through N as rendering servers, each drawing a portion of the geometry into a separate window running on a separate X display.  ParaView reads back these server windows and composites the pixels into the main application window, which is controlled by MPI process 0.  By creating a script which passes a different value of <code>VGL_DISPLAY</code> and <code>VGL_READBACK</code> to each MPI process, it is possible to make all of the ParaView server processes render to off-screen buffers on different graphics cards while preventing VirtualGL from displaying any pixels except those generated by process 0.</td>
    <td class="standard">Readback enabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><a name="VGL_SPOIL"></a><code>VGL_SPOIL=0</code><br /><code>VGL_SPOIL=1</code></td>
    <td class="standard"><code>-sp</code><br />or<br /><code>+sp</code></td>
    <td class="standard"><em>Enable/disable frame spoiling</em> <br /><br /> By default, VirtualGL will drop frames so as not to slow down the rendering rate of the server&rsquo;s graphics engine.  This should produce the best results with interactive applications, but it may be desirable to turn off frame spoiling when running benchmarks or other non-interactive applications.  Turning off frame spoiling will force one frame to be read back and sent on each end-of-frame event, so that the frame rate reported by OpenGL benchmarks will accurately reflect the frame rate seen by the user.  Disabling frame spoiling also prevents non-interactive applications from wasting graphics resources by rendering frames that will never be seen.  With frame spoiling turned off, the rendering pipeline behaves as if it is fill-rate limited to about 30 or 40 Megapixels/second, the maximum throughput of the VirtualGL system on current CPU&rsquo;s.</td>
    <td class="standard">Spoiling enabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_SSL=0</code><br /><code>VGL_SSL=1</code></td>
    <td class="standard"><code>-s</code><br />or<br /><code>+s</code></td>
    <td class="standard"><em>Tunnel the VirtualGL compressed image stream inside a secure socket layer</em> <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">SSL disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_SUBSAMP</code></td>
    <td class="standard"><code>-samp&nbsp;&lt;411|422|444&gt;</code></td>
    <td class="standard"><em>411, 422, or 444</em> <br /><br /> This allows you to manually specify the level of chrominance subsampling in the JPEG compressor. <br /><br /> By default, VirtualGL uses no chrominance subsampling (AKA &ldquo;4:4:4 subsampling&rdquo;) when it compresses images for delivery to the client. Subsampling is premised on the fact that the human eye is more sensitive to changes in brightness than to changes in color.  Since the JPEG image format uses a colorspace in which brightness (luminance) and color (chrominance) are separated into different channels, one can sample the brightness for every pixel and the color for every other pixel and produce an image which has 16 million colors but uses an average of only 16 bits per pixel instead of 24.  This is called &ldquo;4:2:2 subsampling&rdquo;, since for every 4 pixels of luminance, there are only 2 pixels of each chrominance component.  Likewise, one can sample every fourth chrominance component to produce a 16-million color image with only 12 bits per pixel.  The latter is called &ldquo;4:1:1 subsampling.&rdquo;  Subsampling increases the performance and reduces the network usage, since there is less data to move around, but it can produce some visible artifacts.  Subsampling artifacts are rarely observed with volume data, since it usually only contains 256 colors to begin with.  But narrow, aliased lines and other sharp features on a black background will tend to produce subsampling artifacts. <br /><br /> The Axis Indicator from a Popular Visualization App displayed with 4:4:4, 4:2:2, and 4:1:1 subsampling (respectively):<br /> <img src="444.gif" alt="444" class="inline" id="imgid_10" name="imgid_10"/><img src="422.gif" alt="422" class="inline" id="imgid_11" name="imgid_11"/><img src="411.gif" alt="411" class="inline" id="imgid_12" name="imgid_12"/> <br /><br /> <em>NOTE:  If you select 4:1:1 subsampling, VirtualGL will in fact try to use 4:2:0 instead.  4:2:0 samples every other pixel both horizontally and vertically rather than sampling every fourth pixel horizontally.  But not all JPEG codecs support 4:2:0, so 4:1:1 is used when 4:2:0 is not available.</em> <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">444</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_SYNC=0</code><br /><code>VGL_SYNC=1</code></td>
    <td class="standard"><code>-sync</code><br />or<br /><code>+sync</code></td>
    <td class="standard"><em>Enable/disable strict 2D/3D synchronization (necessary to pass GLX conformance tests)</em> <br /><br /> Normally, VirtualGL&rsquo;s operation is asynchronous from the point of view of the application.  The application swaps the buffers or calls <code>glFinish()</code> or <code>glFlush()</code> or <code>glXWaitGL()</code>, and VirtualGL reads back the framebuffer and sends the pixels to the client&rsquo;s display &hellip; eventually.  This will work fine for the vast majority of applications, but it is not strictly conformant.  Technically speaking, when an application calls <code>glXWaitGL()</code> or <code>glFinish()</code>, it is well within its rights to expect the OpenGL-rendered pixels to be immediately available in the X window.  Fortunately, very few applications actually do expect this, but on rare occasions, an application may try to use <code>XGetImage()</code> or other X11 functions to obtain a bitmap of the pixels that were rendered by OpenGL.  Enabling <code>VGL_SYNC</code> is a somewhat extreme measure that may be needed to get such applications to work properly.  It was developed primarily as a way to pass the GLX conformance suite (<code>conformx</code>, specifically.)  When <code>VGL_SYNC</code> is enabled, every call to <code>glFinish()</code> or <code>glXWaitGL()</code> will cause the contents of the server&rsquo;s framebuffer to be read back and <em>synchronously</em> drawn into the client&rsquo;s window <em>without compression or frame spoiling</em>. The call to <code>glFinish()</code> or <code>glXWaitGL()</code> will not return until VirtualGL has verified that the pixels have been delivered into the client&rsquo;s window.  As such, enabling this mode can have potentially dire effects on performance.</td>
    <td class="standard">Synchronization disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_TILESIZE</code></td>
    <td class="standard"></td>
    <td class="standard"><em>A number between 8 and 1024 (inclusive)</em> <br /><br /> Normally, in Direct Mode, VirtualGL will divide an OpenGL window into tiles of 256x256 pixels, compare each tile vs. the previous frame, and only compress &amp; send the tiles which have changed.  It will also divide up the task of compressing these tiles among the available CPUs in a round robin fashion, if multi-threaded compression is enabled.  There are several tradeoffs that must be considered when choosing a tile size: <br /><br /> Smaller tile sizes: <ul class="Itemize"><li>
    Better parallel scalability
</li>
<li>
    Worse compression efficiency
</li>
<li>
    Better inter-frame optimization
</li>
<li>
    Worse network efficiency
</li></ul> Larger tile sizes: <ul class="Itemize"><li>
    Worse parallel scalability
</li>
<li>
    Better compression efficiency
</li>
<li>
    Worse inter-frame optimization
</li>
<li>
    Better network efficiency
</li></ul> <br /> Smaller tiles can more easily be divided up among multiple CPUs, but they compress less efficiently (and less quickly) on an individual basis.  Using larger tiles can reduce traffic to the client by allowing the server to send only one frame update instead of many.  But on the flip side, using larger tiles decreases the chance that a tile will be unchanged from the previous frame.  Thus, the server may only send one or two packets per frame, but the cumulative size of those packets may be much larger than if a smaller tile size was used. <br /><br /> 256x256 was chosen as the default because, in experiments, it provided the best balance between scalability and efficiency on the platforms that VirtualGL supports. <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">256</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_TRACE=0</code><br /><code>VGL_TRACE=1</code></td>
    <td class="standard"><code>-tr</code><br />or<br /><code>+tr</code></td>
    <td class="standard"><em>Enable/disable tracing</em> <br /><br /> When tracing is enabled, VirtualGL will log all calls to the GLX and X11 functions it is intercepting, as well as the arguments, return values, and execution times for those functions.  This is useful when diagnosing interaction problems between VirtualGL and a particular OpenGL application.</td>
    <td class="standard">Tracing disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_VERBOSE=0</code><br /><code>VGL_VERBOSE=1</code></td>
    <td class="standard"><code>-v</code><br />or<br /><code>+v</code></td>
    <td class="standard"><em>Enable/disable verbosity</em> <br /><br /> When in verbose mode, VirtualGL will reveal some of the decisions it makes behind the scenes, such as which code path it is using to compress JPEG images, which type of X11 drawing it is using, etc.  This can be helpful when diagnosing performance problems.</td>
    <td class="standard">Verbosity disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_X11LIB</code></td>
    <td class="standard"></td>
    <td class="standard"><em>the location of an alternate X11 library</em> <br /><br /> Normally, VirtualGL loads the first X11 dynamic library that it finds in the dynamic linker path (usually <code>/usr/lib/libX11.so.?</code>, <code>/usr/lib/64/libX11.so.?</code>, <code>/usr/X11R6/lib/libX11.so.?</code>, or <code>/usr/X11R6/lib64/libX11.so.?</code>.)  You can use this setting to explicitly specify another X11 dynamic library to load. <br /><br /> Normally, you shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t work.</td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_XVENDOR</code></td>
    <td class="standard"></td>
    <td class="standard"><em>Return a fake X11 vendor string when the application calls <code>XServerVendor()</code></em> <br /><br /> Some applications expect <code>XServerVendor()</code> to return a particular value, which the application (sometimes erroneously) uses to figure out whether it&rsquo;s running locally or remotely.  This setting allows you to fool such applications into thinking they&rsquo;re running on a &ldquo;local&rdquo; X server rather than a remote connection.</td>
    <td class="standard"></td>
  </tr>
</table>
</div>



<h2 id="hd0018002">18.2&nbsp;Client Settings</h2>


<h3 id="hd0018002001">Environment Variables</h3>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Environment Variable Name</th>
    <th class="head standard">Description</th>
    <th class="head standard">Default Value</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>VGL_PROFILE=0</code><br /><code>VGL_PROFILE=1</code></td>
    <td class="standard"><em>Enable/disable profiling output</em> <br /><br /> If enabled, this will cause the VirtualGL client to continuously benchmark itself and periodically print out the throughput of decompressing and drawing pixels into the application window. <br /><br /> See Section <a href="#Perf_Measurement" class="ref">16</a> for more details.</td>
    <td class="standard">Profiling disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_VERBOSE=0</code><br /><code>VGL_VERBOSE=1</code></td>
    <td class="standard"><em>Enable/disable verbosity</em> <br /><br /> When in verbose mode, VirtualGL will reveal some of the decisions it makes behind the scenes, such as which code path it is using to decompress JPEG images, which type of X11 drawing it is using, etc. This can be helpful when diagnosing performance problems.</td>
    <td class="standard">Verbosity disabled</td>
  </tr>
</table>
</div>



<h3 id="hd0018002002"><code>vglclient</code> Command-Line Arguments</h3>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"><code>vglclient</code> Argument</th>
    <th class="head standard">Description</th>
    <th class="head standard">Default</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>-port&nbsp;&lt;port</code><br /><code>number&gt;</code></td>
    <td class="standard">Causes the client to listen for unencrypted connections on the specified TCP port</td>
    <td class="standard">4242</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-sslport&nbsp;&lt;port</code><br /><code>number&gt;</code></td>
    <td class="standard">Causes the client to listen for SSL connections on the specified TCP port</td>
    <td class="standard">4243</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-sslonly</code></td>
    <td class="standard">Causes the client to reject all unencrypted connections</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-nossl</code></td>
    <td class="standard">Causes the client to reject all SSL connections</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-l&nbsp;&lt;log&nbsp;file&gt;</code></td>
    <td class="standard">Redirect all output from the client to the specified file</td>
    <td class="standard">Output goes to stderr</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-x</code></td>
    <td class="standard">Use X11 functions to draw pixels into the application window</td>
    <td class="standard">Use OpenGL on Solaris/Sparc or if stereo is enabled; use X11 otherwise</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-gl</code></td>
    <td class="standard">Use OpenGL functions to draw pixels into the application window</td>
    <td class="standard">Use OpenGL on Solaris/Sparc or if stereo is enabled; use X11 otherwise</td>
  </tr>
</table>
</div>


<hr class="break" />

</body>
</html>

