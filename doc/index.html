<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta name="language" content="en">
<meta name="date" content="2007-03-03T02:52:05-06:00">
<meta name="generator" content="deplate.rb 0.8">
<title>User&rsquo;s Guide for VirtualGL 2.1dev1 and TurboVNC 0.3.3</title>
<link rel="start" href="index.html" title="Frontpage">
<link rel="chapter" href="index.html#hd001" title="1 Legal Information">
<link rel="chapter" href="index.html#hd002" title="2 Overview">
<link rel="chapter" href="index.html#hd003" title="3 System Requirements">
<link rel="chapter" href="index.html#hd004" title="4 Obtaining and Installing VirtualGL">
<link rel="chapter" href="index.html#hd005" title="5 Obtaining and Installing TurboVNC">
<link rel="chapter" href="index.html#hd006" title="6 Configuring a Linux Machine as a VirtualGL Server">
<link rel="chapter" href="index.html#hd007" title="7 Configuring a Solaris Machine as a VirtualGL Server">
<link rel="chapter" href="index.html#hd008" title="8 Configuring a Windows Machine as a VirtualGL Direct Mode Client">
<link rel="chapter" href="index.html#hd009" title="9 Using VirtualGL in Direct Mode">
<link rel="chapter" href="index.html#hd0010" title="10 Using VirtualGL in Raw Mode with TurboVNC">
<link rel="chapter" href="index.html#hd0011" title="11 Using VirtualGL in Raw Mode with Other X Servers and Proxies">
<link rel="chapter" href="index.html#hd0012" title="12 vglrun and Solaris Shell Scripts">
<link rel="chapter" href="index.html#hd0013" title="13 Using VirtualGL with Applications That Manually Load OpenGL">
<link rel="chapter" href="index.html#hd0014" title="14 Using VirtualGL with Chromium and ModViz VGP">
<link rel="chapter" href="index.html#hd0015" title="15 Other Application Recipes">
<link rel="chapter" href="index.html#hd0016" title="16 Advanced OpenGL Features">
<link rel="chapter" href="index.html#hd0017" title="17 Performance Measurement">
<link rel="chapter" href="index.html#hd0018" title="18 The VirtualGL Configuration Dialog">
<link rel="chapter" href="index.html#hd0019" title="19 Advanced Configuration">
<link rel="stylesheet" type="text/css" href="virtualgl.css" title="virtualgl">
</head>
<body >
<a name="#pagetop"></a>
<div class="title">
<p class="title">User&rsquo;s Guide for VirtualGL 2.1dev1 and TurboVNC 0.3.3</p>
</div>
<a name="file000"></a>
<p><em>Intended audience:</em> System Administrators, Graphics Programmers,
Researchers, and others with knowledge of the Linux or Solaris operating
systems, OpenGL and GLX, and X windows.</p>

<div id="Table_of_Contents">
<div id="Table_of_ContentsBlock" class="toc">
<h1 class="toc">Table of Contents</h1>
<ul class="toc">
    <li class="toc">
        <a href="#hd001" class="toc">1 Legal Information</a>
    </li>
    <li class="toc">
        <a href="#hd002" class="toc">2 Overview</a>
    </li>
    <li class="toc">
        <a href="#hd003" class="toc">3 System Requirements</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd003001" class="toc">3.1 Linux/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003002" class="toc">3.2 Linux/Itanium</a>
            </li>
            <li class="toc">
                <a href="#hd003003" class="toc">3.3 Solaris/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003004" class="toc">3.4 Solaris/Sparc</a>
            </li>
            <li class="toc">
                <a href="#hd003005" class="toc">3.5 Windows</a>
            </li>
            <li class="toc">
                <a href="#hd003006" class="toc">3.6 Additional Requirements for Stereographic
                rendering</a>
            </li>
            <li class="toc">
                <a href="#hd003007" class="toc">3.7 Additional Requirements for Transparent
                Overlays</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd004" class="toc">4 Obtaining and Installing VirtualGL</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd004001" class="toc">4.1 Installing VirtualGL on Linux</a>
            </li>
            <li class="toc">
                <a href="#hd004002" class="toc">4.2 Installing VirtualGL on Solaris</a>
            </li>
            <li class="toc">
                <a href="#hd004003" class="toc">4.3 Installing VirtualGL on Windows
                (Client Only)</a>
            </li>
            <li class="toc">
                <a href="#hd004004" class="toc">4.4 Installing VirtualGL from Source</a>
            </li>
            <li class="toc">
                <a href="#hd004005" class="toc">4.5 Uninstalling VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd005" class="toc">5 Obtaining and Installing TurboVNC</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd005001" class="toc">5.1 Installing TurboVNC on Linux</a>
            </li>
            <li class="toc">
                <a href="#hd005002" class="toc">5.2 Installing TurboVNC on Solaris</a>
            </li>
            <li class="toc">
                <a href="#hd005003" class="toc">5.3 Installing TurboVNC on Windows
                (Client Only)</a>
            </li>
            <li class="toc">
                <a href="#hd005004" class="toc">5.4 Installing TurboVNC from Source</a>
            </li>
            <li class="toc">
                <a href="#hd005005" class="toc">5.5 Uninstalling TurboVNC</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd006" class="toc">6 Configuring a Linux Machine as a VirtualGL
        Server</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd006001" class="toc">6.1 Granting Access to the Server&rsquo;s
                X Display</a>
            </li>
            <li class="toc">
                <a href="#hd006002" class="toc">6.2 Device permissions</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd007" class="toc">7 Configuring a Solaris Machine as a VirtualGL
        Server</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd007001" class="toc">7.1 GLP: Using VirtualGL Without an
                X Server</a>
            </li>
            <li class="toc">
                <a href="#hd007002" class="toc">7.2 Granting Access to the Server&rsquo;s
                X Display</a>
            </li>
            <li class="toc">
                <a href="#hd007003" class="toc">7.3 Device Permissions</a>
            </li>
            <li class="toc">
                <a href="#hd007004" class="toc">7.4 SSh Server Configuration</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd008" class="toc">8 Configuring a Windows Machine as a VirtualGL
        Direct Mode Client</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd008001" class="toc">8.1 Optimizing Exceed</a>
            </li>
            <li class="toc">
                <a href="#hd008002" class="toc">8.2 Installing the VirtualGL Client
                as a Windows Service</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd009" class="toc">9 Using VirtualGL in Direct Mode</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd009001" class="toc">9.1 Direct Mode with X11 Forwarding</a>
            </li>
            <li class="toc">
                <a href="#hd009002" class="toc">9.2 Direct Mode with a Direct X11 Connection</a>
            </li>
            <li class="toc">
                <a href="#hd009003" class="toc">9.3 Direct Mode with SSL Encryption</a>
            </li>
            <li class="toc">
                <a href="#hd009004" class="toc">9.4 Direct Mode with X11 Forwarding
                and SSh Tunneling</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0010" class="toc">10 Using VirtualGL in Raw Mode with TurboVNC</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0010001" class="toc">10.1 Using Raw Mode When TurboVNC
                and VirtualGL Are Running on the Same Machine</a>
            </li>
            <li class="toc">
                <a href="#hd0010002" class="toc">10.2 Using Raw Mode When TurboVNC
                and VirtualGL Are Running on Different Machines</a>
            </li>
            <li class="toc">
                <a href="#hd0010003" class="toc">10.3 Disconnecting and Killing the
                TurboVNC Session</a>
            </li>
            <li class="toc">
                <a href="#hd0010004" class="toc">10.4 Using TurboVNC in a Web Browser</a>
            </li>
            <li class="toc">
                <a href="#hd0010005" class="toc">10.5 Connection Profiles: Optimizing
                TurboVNC&rsquo;s Performance for Different Network Types</a>
            </li>
            <li class="toc">
                <a href="#hd0010006" class="toc">10.6 Securing a TurboVNC Connection</a>
            </li>
            <li class="toc">
                <a href="#hd0010007" class="toc">10.7 Further Reading</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0011" class="toc">11 Using VirtualGL in Raw Mode with Other
        X Servers and Proxies</a>
    </li>
    <li class="toc">
        <a href="#hd0012" class="toc">12 vglrun and Solaris Shell Scripts</a>
    </li>
    <li class="toc">
        <a href="#hd0013" class="toc">13 Using VirtualGL with Applications
        That Manually Load OpenGL</a>
    </li>
    <li class="toc">
        <a href="#hd0014" class="toc">14 Using VirtualGL with Chromium and
        ModViz VGP</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0014001" class="toc">14.1 Configuration 1: Sort-First Rendering
                (Image-Space Decomposition)</a>
            </li>
            <li class="toc">
                <a href="#hd0014002" class="toc">14.2 Configuration 2: Sort-First Rendering
                (Image-Space Decomposition) with Readback</a>
            </li>
            <li class="toc">
                <a href="#hd0014003" class="toc">14.3 Configuration 3: Sort-Last Rendering
                (Object-Space Decomposition)</a>
            </li>
            <li class="toc">
                <a href="#hd0014004" class="toc">14.4 A Note About Performance</a>
            </li>
            <li class="toc">
                <a href="#hd0014005" class="toc">14.5 ModViz VGP and VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0015" class="toc">15 Other Application Recipes</a>
    </li>
    <li class="toc">
        <a href="#hd0016" class="toc">16 Advanced OpenGL Features</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0016001" class="toc">16.1 Stereographic Rendering</a>
            </li>
            <li class="toc">
                <a href="#hd0016002" class="toc">16.2 Transparent Overlays</a>
            </li>
            <li class="toc">
                <a href="#hd0016003" class="toc">16.3 Indexed (PseudoColor) Rendering</a>
            </li>
            <li class="toc">
                <a href="#hd0016004" class="toc">16.4 Troubleshooting</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0017" class="toc">17 Performance Measurement</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0017001" class="toc">17.1 VirtualGL&rsquo;s Built-In Profiling
                System</a>
            </li>
            <li class="toc">
                <a href="#hd0017002" class="toc">17.2 Frame Spoiling</a>
            </li>
            <li class="toc">
                <a href="#hd0017003" class="toc">17.3 VirtualGL Diagnostic Tools</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0018" class="toc">18 The VirtualGL Configuration Dialog</a>
    </li>
    <li class="toc">
        <a href="#hd0019" class="toc">19 Advanced Configuration</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0019001" class="toc">19.1 Server Settings</a>
            </li>
            <li class="toc">
                <a href="#hd0019002" class="toc">19.2 Client Settings</a>
            </li>
        </ul>
    </li>
</ul>
</div></div>
<hr class="break" />


<h1 id="hd001"><a name="file001"></a>1&nbsp;Legal Information</h1>

<p><img src="somerights20.png" alt="somerights20" class="inline" id="imgid_0" name="imgid_0"/></p>

<p>This document and all associated illustrations are licensed under the
<span class="remote"><a href="http://creativecommons.org/licenses/by/2.5/" class="remote">Creative
Commons Attribution 2.5 License</a></span><a name="idx001"></a>.  Any
works which contain material derived from this document must cite The
VirtualGL Project as the source of the material and list the current
URL for the VirtualGL web-site.</p>

<p>This product includes software developed by the OpenSSL Project for
use in the OpenSSL Toolkit (<a href="http://www.openssl.org/">http://www.openssl.org/</a>.)
Further information is contained in
<a href="LICENSE-OpenSSL.txt"><code>LICENSE-OpenSSL.txt</code></a><a name="idx002"></a>,
which can be found in the same directory as this documentation.</p>

<p>VirtualGL is licensed under the <a href="LICENSE.txt">wxWindows Library
License, v3</a><a name="idx003"></a>, a derivative of the <a href="LGPL.txt">GNU
Lesser General Public License (LGPL)</a><a name="idx004"></a>.</p>

<hr class="break" />


<h1 id="hd002"><a name="file002"></a>2&nbsp;Overview</h1>

<p><a name="Overview"></a></p>

<p>VirtualGL is an open source package which gives any Unix or Linux remote
display software the ability to run OpenGL applications with full 3D
hardware acceleration.  Some remote display software, such as VNC,
lacks the ability to run OpenGL applications entirely.  Other remote
display software forces OpenGL applications to use a slow software-only
OpenGL renderer, to the detriment of both performance as well as compatibility.
And running OpenGL applications using the traditional remote X-Windows
approach causes all of the OpenGL commands and 3D data to be sent over
the network to be rendered on the client machine, which is not a tenable
proposition unless the data is relatively small and static, unless
the network is fast, and unless the OpenGL application is specifically
tuned for a remote X-Windows environment.</p>

<p>With VirtualGL, the OpenGL commands and 3D data are instead redirected
to a 3D graphics accelerator on the server machine, and only the rendered
3D images are sent to the client machine.  VirtualGL thus &ldquo;virtualizes&rdquo;
3D graphics hardware, allowing it to be co-located in the &ldquo;cold
room&rdquo; with compute and storage resources.  VirtualGL also allows
3D graphics hardware to be shared among multiple users, and it provides
real-time performance on even the most modest of networks.  This makes
it possible for large, noisy, hot 3D workstations to be replaced with
laptops or even thinner clients, but more importantly, it eliminates
the workstation and the network as barriers to data size.  Users can
now visualize gigabytes and gigabytes of data in real time without
needing to cache any of the data locally or sit in front of the machine
that is rendering the data.</p>

<p>VirtualGL has two basic modes of operation:  &ldquo;Direct&rdquo; Mode
and &ldquo;Raw&rdquo; Mode.  In both modes, a separate X-Windows server
(or X-Windows proxy) is used to display the application&rsquo;s GUI
and to provide keyboard/mouse interaction.</p>

<p><a name="Direct_Mode"></a></p>

<dl class="Description">
    <dt class="Description">1. &ldquo;Direct&rdquo; Mode</dt>
    <dd class="Description">
        Direct Mode is most often used whenever the X server is located across
        the network from the graphics server, for instance if the X server
        is running on the user&rsquo;s desktop machine.  In this case, the
        3D application sends X11 commands across the network to the X server
        in order to display the application GUI, and the application receives
        X11 events back from the X server in order to respond to keyboard and
        mouse interaction from the user. Normally, a 3D application would also
        send GLX commands across the network to the X server in order to establish
        an OpenGL rendering context on the client machine.  Such an &ldquo;indirect&rdquo;
        OpenGL context could then be used to tunnel OpenGL commands and 3D
        data inside the X-Windows protocol stream.  But VirtualGL instead intercepts
        the GLX commands from the application so that it can force the OpenGL
        rendering context to be established in an invisible pixel buffer (&ldquo;Pbuffer&rdquo;)
        on a 3D graphics card in the server machine. VirtualGL also monitors
        buffer swaps and other commands from the application in order to determine
        when the application has finished rendering a frame. When such an end-of-frame
        trigger is detected, VGL reads back the rendered frame from the 3D
        graphics card, compresses it using a high-speed image codec, and sends
        the compressed image directly to the client machine using a dedicated
        TCP socket.  A separate VirtualGL Client application runs on the client
        machine, and this VirtualGL Client application decompresses the compressed
        frame and composites it into the appropriate X window.<br /> <br />
        Direct Mode is the fastest solution for running VirtualGL on a local
        area network, and it provides the same usability as running the 3D
        application &ldquo;locally&rdquo; on a workstation.  Direct Mode does
        not work particularly well on a high-latency or low-bandwidth network
        due to its reliance on the remote X-Windows protocol for displaying
        the application&rsquo;s GUI.  However, it works great with any modest
        laptop and 802.11g wireless or 100 Megabit Ethernet.
    </dd>
</dl>

<a name="fig002001"></a>
<div class="figure">
<p class="caption">Figure 2.1: VirtualGL in Direct Mode</p>
<img src="directmode.png" alt="directmode" class="figure" id="imgid_14" name="imgid_14"/>
</div>

<p><a name="Raw_Mode"></a></p>

<dl class="Description">
    <dt class="Description">2. &ldquo;Raw&rdquo; Mode</dt>
    <dd class="Description">
        In this mode, VirtualGL does not compress the rendered 3D images itself
        but rather sends them in uncompressed form to an X server. This is
        most useful in conjunction with an &ldquo;X Proxy&rdquo;, which can
        be one of any number of Unix remote display applications, such as VNC.
        These X proxies are essentially &ldquo;virtual&rdquo; X servers.  They
        appear to the application to be a normal X server, but they perform
        X11 rendering to a virtual framebuffer in the server machine&rsquo;s
        memory rather than to a real hardware framebuffer. This allows the
        X proxy to send only images to the client machine rather than chatty
        X-Windows commands.  As with Direct Mode, VirtualGL intercepts the
        GLX calls from the application and thus forces the application to render
        into an OpenGL Pbuffer located on the server machine&rsquo;s graphics
        card. VirtualGL also reads back the rendered images, as with Direct
        Mode.  But in Raw Mode, VirtualGL draws the rendered 3D images into
        the X server as uncompressed 2D bitmaps.  If the X server is really
        an X proxy, then VirtualGL relies on this X proxy to compress the images
        and send them to the client(s).  Since the use of an X proxy eliminates
        the need to send X-Windows commands over the network, this is the best
        means of using VirtualGL when the network has high latency or low bandwidth.
        The VirtualGL project provides an accelerated version of VNC, called
        &ldquo;TurboVNC&rdquo;, which is meant to be used with VirtualGL in
        Raw Mode on such networks.  TurboVNC also provides rudimentary collaboration
        capabilities, allowing multiple users to simultaneously interact with
        the same 3D application.  But whereas Direct Mode produces a similar
        user experience to running the 3D application &ldquo;locally&rdquo;,
        VNC and most other X proxies require the user to interact with a &ldquo;desktop
        in a window&rdquo;, which is not a completely seamless
        experience.<br /> <br /> Raw	Mode, in conjunction with an X proxy,
        is typically used to run data-intensive 3D applications in a &ldquo;cold
        room&rdquo; and remotely interact with these applications from a PC
        or laptop located in another city.  However, Raw Mode can also be used
        to transmit images directly to the client machine, if the network is
        sufficiently fast (Gigabit Ethernet, for instance.)
    </dd>
</dl>

<a name="fig002002"></a>
<div class="figure">
<p class="caption">Figure 2.2: VirtualGL in Raw Mode with an X proxy on the graphics server</p>
<img src="rawmodetoxproxy.png" alt="rawmodetoxproxy" class="figure" id="imgid_15" name="imgid_15"/>
</div>

<a name="fig002003"></a>
<div class="figure">
<p class="caption">Figure 2.3: VirtualGL in Raw Mode with an X proxy on a different server</p>
<img src="rawmodeoverservernetwork.png" alt="rawmodeoverservernetwork" class="figure" id="imgid_16" name="imgid_16"/>
</div>

<a name="fig002004"></a>
<div class="figure">
<p class="caption">Figure 2.4: VirtualGL in Raw Mode with no X proxy</p>
<img src="rawmodeovernetwork.png" alt="rawmodeovernetwork" class="figure" id="imgid_17" name="imgid_17"/>
</div>

<hr class="break" />


<h1 id="hd003"><a name="file003"></a>3&nbsp;System Requirements</h1>


<h2 id="hd003001">3.1&nbsp;Linux/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (x86)</th>
    <th class="head standard">Server (x86-64)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4, 1.7 GHz or faster (or equivalent) <ul class="Itemize"><li>
    For optimal performance, the processor should support SSE2 extensions.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li>
    For optimal performance with 64-bit VirtualGL, the processor should
    support SSE3 extensions.  Only newer AMD 64-bit processors (mid-2005
    and later) support SSE3.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard" colspan="2">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li>
    Tested with various nVidia cards
</li>
<li>
    Install the vendor drivers for the server&rsquo;s 3D graphics card.
    Do not use the drivers that ship with Linux, as these do not provide
    3D acceleration or Pbuffer support.
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance <ul class="Itemize"><li>
    If using a 3D graphics card, install the vendor drivers for that 3D
    graphics card.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Recommended O/S</td>
    <td class="standard" colspan="3"><ul class="Itemize"><li>
    Any distribution in the
    <span class="remote"><a href="http://www.redhat.com/" class="remote">RedHat</a></span><a name="idx005"></a>
    or
    <span class="remote"><a href="http://www.novell.com/linux/" class="remote">SuSE</a></span><a name="idx006"></a>
    families (including
    <span class="remote"><a href="http://fedora.redhat.com/" class="remote">Fedora</a></span><a name="idx007"></a>,
    <span class="remote"><a href="http://www.centos.org/" class="remote">CentOS</a></span><a name="idx008"></a>,
    and <span class="remote"><a href="http://www.whiteboxlinux.org/" class="remote">White
    Box</a></span><a name="idx009"></a>)
</li>
<li>
    Specifically tested with RedHat Enterprise Linux 2.1, RedHat/CentOS
    Enterprise Linux 3 &amp; 4 (32-bit and 64-bit), and SuSE Linux Enterprise
    9 &amp; 10 (32-bit and 64-bit)
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard" colspan="3">X server configured to export True Color (24-bit or 32-bit) visuals</td>
  </tr>
</table>
</div>



<h2 id="hd003002">3.2&nbsp;Linux/Itanium</h2>

<p>VirtualGL should build and run on Itanium Linux, but it has not been
thoroughly tested. 
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">Contact
us</a></span><a name="idx0010"></a> if you encounter any difficulties.</p>


<h2 id="hd003003">3.3&nbsp;Solaris/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">nVidia 3D graphics card</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard" colspan="3">Solaris 10 or higher</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0011"></a> (v2.4 or higher recommended
    *)
</li>
<li>
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Solaris
    Patch</a></span><a name="idx0012"></a> 118345-04 (or later)
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0013"></a> (v2.4 or higher recommended
    *)
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
  </tr>
</table>
</div>


<div class="important"><p class="important">
* Solaris 10/x86 comes with mediaLib pre-installed, but it is strongly recommended that you upgrade this version of mediaLib to at least 2.4.  This will greatly increase the performance of Solaris/x86 VirtualGL clients as well as the performance of 32-bit applications on Solaris/x86 VirtualGL servers.
</p></div>


<h2 id="hd003004">3.4&nbsp;Solaris/Sparc</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">UltraSPARC III 900 MHz or faster <ul class="Itemize"><li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">UltraSPARC III 900 MHz or faster</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li>
    Tested with
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr600/" class="remote">XVR-600</a></span><a name="idx0014"></a>,
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr1200/" class="remote">XVR-1200</a></span><a name="idx0015"></a>
    (&ldquo;jfb&rdquo;), and
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0016"></a>
    (&ldquo;kfb&rdquo;)
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard" colspan="2">Solaris 8 or higher</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0017"></a>
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0018"></a> 1.3 or later (1.5 or later
    required for <a href="#GLP_Usage">GLP</a><a name="idx0019"></a>)
</li>
<li>
    If your system does not ship with SSh pre-installed (older Solaris
    8 and 9 systems don&rsquo;t), then download and install an OpenSSH
    package from
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0020"></a>
    or <a href="http://www.sunfreeware.com/.">http://www.sunfreeware.com/.</a>
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
    (if not using <a href="#GLP_Usage">GLP</a><a name="idx0021"></a>)
</li></ul> Recommended <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patches</a></span><a name="idx0022"></a> <ul class="Itemize"><li>
    <em>OpenGL 1.5</em>: 120812-15 (or later)
</li>
<li>
    <em>XVR-2500 driver</em>: 120928-15 (or later)
</li>
<li>
    <em>OpenGL 1.3, 32-bit:</em> 113886-41 (or later)
</li>
<li>
    <em>OpenGL 1.3, 64-bit:</em> 113887-41 (or later)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0023"></a>
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0024"></a> 1.3 or later recommended if
    the client has a 3D graphics card installed.  If available, the VirtualGL
    Direct Mode client will use OpenGL to draw images, which improves the
    client&rsquo;s performance on Sun 3D graphics cards.
</li>
<li>
    If your system does not ship with SSh pre-installed (older Solaris
    8 and 9 systems don&rsquo;t), then download and install an OpenSSH
    package from
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0025"></a>
    or <a href="http://www.sunfreeware.com/.">http://www.sunfreeware.com/.</a>
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003005">3.5&nbsp;Windows</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Windows 2000 or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <em>Direct Mode Only</em>:
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0026"></a>
    Exceed 8 or newer required
</li>
<li>
    Secure Shell (SSh) client
</li>
<li>
    Client display must have a 24-bit or 32-bit color depth (True Color.)
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003006">3.6&nbsp;Additional Requirements for Stereographic rendering</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard" colspan="2" rowspan="2">3D graphics card that supports stereo (example: nVidia Quadro) and is configured to export stereo visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/Sparc</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0027"></a>
    graphics card
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0028"></a> 1.5 or later
</li>
<li>
    OpenGL
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patch</a></span><a name="idx0029"></a>
    120812-14 (or later)
</li>
<li>
    XVR-2500 driver
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patch</a></span><a name="idx0030"></a>
    120928-10 (or later)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports stereo (examples: XVR-1200, XVR-2500)
    and is configured to export stereo visuals
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0031"></a> 1.3 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard">N/A</td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports stereo (examples: nVidia Quadro, 3D
    Labs Wildcat Realizm) and is configured to export stereo pixel formats
</li>
<li>
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0032"></a>
    Exceed 3D v8 or newer
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003007">3.7&nbsp;Additional Requirements for Transparent Overlays</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard" rowspan="2">3D graphics card that supports transparent overlays (example: nVidia Quadro) and is configured to export overlay visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/Sparc</td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports transparent overlays (examples: XVR-1200,
    XVR-2500) and is configured to export overlay visuals
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0033"></a> 1.3 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports transparent overlays (examples: nVidia
    Quadro, 3D Labs Wildcat Realizm) and is configured to export overlay
    pixel formats
</li>
<li>
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0034"></a>
    Exceed 3D v8 or newer
</li></ul></td>
  </tr>
</table>
</div>


<hr class="break" />


<h1 id="hd004"><a name="file004"></a>4&nbsp;Obtaining and Installing VirtualGL</h1>

<div class="important"><p class="important">
VirtualGL must be installed on any machine that will act as a VirtualGL server or as a VirtualGL <a href="#Direct_Mode">Direct Mode</a><a name="idx0035"></a> client. It is not necessary to install VirtualGL on the client machine if <a href="#Raw_Mode">Raw Mode</a><a name="idx0036"></a> is to be used.
</p></div>


<h2 id="hd004001">4.1&nbsp;Installing VirtualGL on Linux</h2>


<h3 id="hd004001001">Installing TurboJPEG</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the TurboJPEG RPM package (<code>turbojpeg-{version}.i386.rpm</code>
        for 32-bit systems and <code>turbojpeg-{version}.x86_64.rpm</code>
        for 64-bit systems) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0037"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0038"></a>. <br />
        <div class="important"><p class="important">
        The 64-bit RPM provides both 32-bit and 64-bit TurboJPEG libraries. <br /><br /> .tgz packages are provided for users of non-RPM-based Linux distributions.  You can use <span class="remote"><a href="http://www.kitenet.net/programs/alien/" class="remote">alien</a></span><a name="idx0039"></a> to convert these into .deb packages if you prefer.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following commands:
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbojpeg*.rpm
</pre>

    </li>
</ol>


<h3 id="hd004001002">Installing VirtualGL</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the VirtualGL RPM package (<code>VirtualGL-{version}.i386.rpm</code>
        for 32-bit systems and <code>VirtualGL-{version}.x86_64.rpm</code>
        for 64-bit systems) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0040"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0041"></a>. <br />
        <div class="important"><p class="important">
        The 64-bit RPM provides both 32-bit and 64-bit VirtualGL components.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following commands:
<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
rpm&nbsp;-i&nbsp;VirtualGL*.rpm
</pre>

    </li>
</ol>


<h2 id="hd004002">4.2&nbsp;Installing VirtualGL on Solaris</h2>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the VirtualGL Solaris package (<code>SUNWvgl-{version}.pkg.bz2</code>
        for Sparc and <code>SUNWvgl-{version}-x86.pkg.bz2</code> for x86) from
        the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0042"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0043"></a>. <br />
        <div class="important"><p class="important">
        Both packages provide both 32-bit and 64-bit VirtualGL components.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the package,
        and issue the following commands:
<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

        (answer &ldquo;Y&rdquo; when prompted.)
<pre class="verbatim">
bzip2&nbsp;-d&nbsp;SUNWvgl-{version}.pkg.bz2
pkgadd&nbsp;-d&nbsp;SUNWvgl-{version}.pkg
</pre>

        Select the <code>SUNWvgl</code> package (usually option 1) from the
        menu.
    </li>
</ol>
<div class="important"><p class="important">
VirtualGL for Solaris installs into <code>/opt/SUNWvgl</code>.
</p></div>


<h2 id="hd004003">4.3&nbsp;Installing VirtualGL on Windows (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the VirtualGL Windows installer package (<code>VirtualGL-{version}.exe</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0044"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0045"></a>.
    </li>
    <li class="Ordered">
        Run the VirtualGL installer.  The installation of VirtualGL should
        be self-explanatory.  The only configuration option is the directory
        into which you want the files to be installed.
    </li>
</ol>


<h2 id="hd004004">4.4&nbsp;Installing VirtualGL from Source</h2>

<p>If you are using a non-RPM-based distribution of Linux or another platform
for which there is not a pre-built VirtualGL binary package available,
then log in as root, download the VirtualGL source tarball (<code>VirtualGL-{version}.tar.gz</code>)
from the
<span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
area</a></span><a name="idx0046"></a> of the
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
SourceForge web-site</a></span><a name="idx0047"></a>, uncompress it,
<code>cd&nbsp;vgl</code>, and read the contents of <code>BUILDING.txt</code>
for further instructions on how to build and install VirtualGL from
source.</p>


<h2 id="hd004005">4.5&nbsp;Uninstalling VirtualGL</h2>


<h3 id="hd004005001">Linux</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
</pre>


<h3 id="hd004005002">Solaris</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

<p>Answer &ldquo;yes&rdquo; when prompted.</p>


<h3 id="hd004005003">Windows</h3>

<p>Use the <em>Add or Remove Programs</em> applet in the Control Panel.</p>

<hr class="break" />


<h1 id="hd005"><a name="file005"></a>5&nbsp;Obtaining and Installing TurboVNC</h1>

<div class="important"><p class="important">
TurboVNC must be installed on any machine that will act as a TurboVNC server or client.  It is not necessary to install TurboVNC to use VirtualGL in <a href="#Direct_Mode">Direct Mode</a><a name="idx0048"></a>.  Also, TurboVNC need not necessarily be installed on the same server as VirtualGL.
</p></div>


<h2 id="hd005001">5.1&nbsp;Installing TurboVNC on Linux</h2>


<h3 id="hd005001001">Installing TurboJPEG</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the TurboJPEG RPM package (<code>turbojpeg-{version}.i386.rpm</code>
        for 32-bit systems and <code>turbojpeg-{version}.x86_64.rpm</code>
        for 64-bit systems) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0049"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0050"></a>. <br />
        <div class="important"><p class="important">
        The 64-bit RPM provides both 32-bit and 64-bit TurboJPEG libraries. <br /><br /> .tgz packages are provided for users of non-RPM-based Linux distributions.  You can use <span class="remote"><a href="http://www.kitenet.net/programs/alien/" class="remote">alien</a></span><a name="idx0051"></a> to convert these into .deb packages if you prefer.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbojpeg*.rpm
</pre>

    </li>
</ol>


<h3 id="hd005001002">Installing TurboVNC</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the TurboVNC RPM package (<code>turbovnc-{version}.i386.rpm</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0052"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0053"></a>. <br />
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbovnc*.rpm
</pre>

    </li>
</ol>


<h2 id="hd005002">5.2&nbsp;Installing TurboVNC on Solaris</h2>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the TurboVNC Solaris package (<code>SUNWtvnc-{version}.pkg.bz2</code>
        for Sparc and <code>SUNWtvnc-{version}-x86.pkg.bz2</code> for x86)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0054"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0055"></a>. <br />
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the package,
        and issue the following commands:
<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

        (answer &ldquo;Y&rdquo; when prompted.)
<pre class="verbatim">
bzip2&nbsp;-d&nbsp;SUNWtvnc-{version}.pkg.bz2
pkgadd&nbsp;-d&nbsp;SUNWtvnc-{version}.pkg
</pre>

        Select the <code>SUNWtvnc</code> package (usually option 1) from the
        menu.
    </li>
</ol>
<div class="important"><p class="important">
TurboVNC for Solaris installs into <code>/opt/SUNWtvnc</code>.
</p></div>


<h2 id="hd005003">5.3&nbsp;Installing TurboVNC on Windows (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the TurboVNC Windows installer package (<code>TurboVNC-{version}.exe</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0056"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0057"></a>.
    </li>
    <li class="Ordered">
        Run the TurboVNC installer.  The installation of TurboVNC should be
        self-explanatory.  The only configuration option is the directory into
        which you want the files to be installed.
    </li>
</ol>


<h2 id="hd005004">5.4&nbsp;Installing TurboVNC from Source</h2>

<p>If you are using a non-RPM-based distribution of Linux or another platform
for which there is not a pre-built TurboVNC binary package available,
then log in as root, download the TurboVNC source tarball (<code>turbovnc-{version}.tar.gz</code>)
from the
<span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
area</a></span><a name="idx0058"></a> of the
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
SourceForge web-site</a></span><a name="idx0059"></a>, uncompress it,
<code>cd&nbsp;vnc/vnc_unixsrc</code>, and read the contents of <code>BUILDING.txt</code>
for further instructions on how to build and install TurboVNC from
source.</p>


<h2 id="hd005005">5.5&nbsp;Uninstalling TurboVNC</h2>


<h3 id="hd005005001">Linux</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
rpm&nbsp;-e&nbsp;turbovnc
</pre>


<h3 id="hd005005002">Solaris</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
pkgrm&nbsp;SUNWtvnc
</pre>

<p>Answer &ldquo;yes&rdquo; when prompted.</p>


<h3 id="hd005005003">Windows</h3>

<p>Use the <em>Add or Remove Programs</em> applet in the Control Panel.</p>

<hr class="break" />


<h1 id="hd006"><a name="file006"></a>6&nbsp;Configuring a Linux Machine as a VirtualGL Server</h1>


<h2 id="hd006001">6.1&nbsp;Granting Access to the Server&rsquo;s X Display</h2>

<p>VirtualGL requires access to the server&rsquo;s 3D graphics card so
that it can create off-screen pixel buffers (Pbuffers) and redirect
the 3D rendering from applications into these Pbuffers.  Unfortunately,
accessing a 3D graphics card on Linux currently requires going through
an X server.  So the only way to share the server’s 3D graphics card
among multiple users is to grant those users access to the X server
that is running on the 3D graphics card.</p>

<p>It is important to understand the security risks associated with this.
Once X display access is granted to a user, there is nothing that would
prevent that user from logging keystrokes or reading back images from
the X display. Using <code>xauth</code>, one can obtain “untrusted”
X authentication keys which prevent such exploits, but unfortunately,
those untrusted keys also disallow access to the 3D hardware.  So it
is necessary to grant full trusted X access to any users that will
need to run VirtualGL.  Unless you fully trust the users to whom you
are granting this access, you should avoid logging in locally to the
server’s X display as root unless absolutely necessary.</p>

<p>This section will explain how to configure a VirtualGL server such
that select users can run VirtualGL, even if the server is sitting
at the login prompt. The basic idea is to call a script (<code>vglgenkey</code>)
from the display manager&rsquo;s startup script.  <code>vglgenkey</code>
invokes <code>xauth</code> to generate an authorization key for the
server&rsquo;s X display, and it stores this key under <code>/etc/opt/VirtualGL</code>.
The VirtualGL launcher script (<code>vglrun</code>) then attempts to
read this key and merge it into the user&rsquo;s <code>.Xauthority</code>
file, thus granting the user access to the server&rsquo;s X display.
Therefore, you can control who has access to the server&rsquo;s X display
simply by controlling who has read access to the <code>/etc/opt/VirtualGL</code>
directory.</p>

<p>If you prefer, you can also grant access to every authenticated user
on the server by replacing the references to <code>vglgenkey</code>
below with <code>xhost&nbsp;+localhost</code>.</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        If the server machine is configured to boot into runlevel 5 (graphical
        login), then temporarily shut down its X server by issuing
<pre class="verbatim">
init&nbsp;3
</pre>

        as root
    </li>
    <li class="Ordered">
        Log in as root from the text console.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        Create a new directory <code>/etc/opt/VirtualGL</code> and make it
        readable by the <code>vglusers</code> group.  For example: <br />
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/opt/VirtualGL
chgrp&nbsp;vglusers&nbsp;/etc/opt/VirtualGL
chmod&nbsp;750&nbsp;/etc/opt/VirtualGL
</pre>

    </li>
    <li class="Ordered">
        If the server machine is configured to boot into runlevel 3 (text login),
        then configure it to boot into a graphical login by changing the first
        line of <code>/etc/inittab</code> from<br /> <br />
        <code>id:3:initdefault:</code><br /> <br /> to<br /> <br /> <code>id:5:initdefault:</code>
    </li>
    <li class="Ordered">
        Add
<pre class="verbatim">
vglgenkey
</pre>

        at the top of the display manager&rsquo;s startup script.  The location
        of this script varies depending on the particular Linux distribution
        and display manager being used.  The following table lists some common
        locations for this file: <br /><br />
        <div class="table">
        <table class="standard" align="center">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard"></th>
            <th class="head standard">xdm or kdm</th>
            <th class="head standard">gdm<br /><sub>(default display manager on most Linux systems)</sub></th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="high standard">RedHat 7/8/9<br />Enterprise Linux 2.1/3</td>
            <td class="standard"><code>/etc/X11/xdm/Xsetup_0</code><br /> <br /> (replace &ldquo;0&rdquo; with the display number of the X server you are configuring)</td>
            <td class="standard"><code>/etc/X11/gdm/Init/Default</code><br /> <br /> (usually this is just symlinked to <code>/etc/X11/xdm/Xsetup_0</code>)</td>
          </tr>
          <tr class="standard">
            <td class="high standard">Enterprise Linux 4<br />Fedora Core 1/2/3</td>
            <td class="standard"><code>/etc/X11/xdm/Xsetup_0</code><br /> <br /> (replace &ldquo;0&rdquo; with the display number of the X server you are configuring)</td>
            <td class="standard"><code>/etc/X11/gdm/Init/:0</code><br /> <br /> (usually this is just symlinked to <code>/etc/X11/xdm/Xsetup_0</code>)</td>
          </tr>
          <tr class="standard">
            <td class="high standard">SuSE/United Linux</td>
            <td class="standard"><code>/etc/X11/xdm/Xsetup</code></td>
            <td class="standard"><code>/etc/opt/gnome/gdm/Init/Default</code></td>
          </tr>
        </table>
        </div>
        
    </li>
    <li class="Ordered">
        If the server is running gdm (the factory default on most Linux systems),
        then you&rsquo;ll need to set up gdm to allow TCP connections to the
        X server. To do this, edit the <code>gdm.conf</code> file and add the
        following line under the <code>[security]</code> section (or change
        it if it already exists):
<pre class="verbatim">
DisallowTCP=false
</pre>

        See the table below for the location of gdm.conf on various systems.
    </li>
    <li class="Ordered">
        Unless you know that you absolutely need it, disable the XTEST extension.
        Disabling XTEST will not prevent a user from logging keystrokes or
        reading images from the X display, but it will prevent them from inserting
        key and mouse events and thus hijacking a local X session.<br />
        <br /> Disabling XTEST is accomplished by passing an argument of <code>-tst</code>
        on the command line used to launch the X server.  The location of this
        command line varies depending on the particular Linux distribution
        and display manager being used.   The following table lists some common
        locations:<br /> <br />
        <div class="table">
        <table class="standard" align="center">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard"></th>
            <th class="head standard">xdm</th>
            <th class="head standard">gdm<br /><sub>(default on most Linux systems)</sub></th>
            <th class="head standard">kdm</th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="high standard">RedHat (or equivalent)</td>
            <td class="standard"><code>/etc/X11/xdm/Xservers</code></td>
            <td class="standard"><code>/etc/X11/gdm/gdm.conf</code></td>
            <td class="standard"><code>/etc/X11/xdm/Xservers</code></td>
          </tr>
          <tr class="standard">
            <td class="high standard">SuSE/United Linux</td>
            <td class="standard"><code>/etc/X11/xdm/Xservers</code></td>
            <td class="standard"><code>/etc/opt/gnome/gdm/gdm.conf</code></td>
            <td class="standard"><code>/etc/opt/kde3/share/config/kdm/Xservers</code></td>
          </tr>
        </table>
        </div>
        
        <br /> For xdm-style configuration files, add <code>-tst</code> to
        the line corresponding to the display number you are configuring. 
        For example: <br />
<pre class="verbatim">
:0&nbsp;local&nbsp;/usr/X11R6/bin/X&nbsp;:0&nbsp;vt07&nbsp;-tst
</pre>

        For gdm-style configuration files, add <code>-tst</code> to all lines
        that appear to be X server command lines.  For example: <br />
<pre class="verbatim">
StandardXServer=/usr/X11R6/bin/X&nbsp;-tst
</pre>

<pre class="verbatim">
[server-Standard]
command=/usr/X11R6/bin/X&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

<pre class="verbatim">
[server-Terminal]
command=/usr/X11R6/bin/X&nbsp;-tst&nbsp;-audit&nbsp;0&nbsp;-terminate
</pre>

<pre class="verbatim">
[server-Chooser]
command=/usr/X11R6/bin/X&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

    </li>
    <li class="Ordered">
        Restart the X server by issuing
<pre class="verbatim">
init&nbsp;5
</pre>

        as root.
    </li>
    <li class="Ordered">
        To check your work, log out of the server, log back in via. SSh, and
        run
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
xdpyinfo&nbsp;-display&nbsp;:0
</pre>

        In particular, make sure that XTEST doesn&rsquo;t show up in the list
        of extensions if you disabled it above.
    </li>
</ol>


<h2 id="hd006002">6.2&nbsp;Device permissions</h2>

<p>If you are installing VirtualGL on a server which is running version
1.0-71xx or earlier of the NVidia accelerated GLX drivers, follow the
instructions in <code>/usr/share/doc/NVIDIA_GLX-1.0/README</code> regarding
setting the appropriate permissions for <code>/dev/nvidia*</code>.
This is not necessary with more recent versions of the driver.  <code>cat&nbsp;/proc/driver/nvidia/version</code>
to determine which version of the NVidia driver is installed on your
system.</p>

<hr class="break" />


<h1 id="hd007"><a name="file007"></a>7&nbsp;Configuring a Solaris Machine as a VirtualGL Server</h1>


<h2 id="hd007001">7.1&nbsp;GLP: Using VirtualGL Without an X Server</h2>

<p><a name="GLP_Usage"></a></p>

<p>Sun&rsquo;s OpenGL library for Sparc systems has a special extension
called &ldquo;GLP&rdquo; which allows VirtualGL to directly access
a 3D graphics card even if there is no X server running on the card.
Apart from greatly simplifying the process of configuring the VirtualGL
server, GLP also greatly improves the overall security of the VirtualGL
server, since it eliminates the need to grant X server access to VirtualGL
users.  In addition, GLP makes it easy to assign VirtualGL jobs to
any graphics card in a multi-card system.</p>

<p>If your system is running
<span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
OpenGL</a></span><a name="idx0060"></a> 1.5 for Sparc/Solaris, it is
recommended that you configure it to use GLP:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in as root.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        If the <code>/etc/dt/config</code> directory does not exist, create
        it.
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/dt/config
</pre>

        Make sure that <code>/etc/dt/config</code> has global read/execute
        permissions.
    </li>
    <li class="Ordered">
        Create a file called <code>GraphicsDevices</code> under <code>/etc/dt/config</code>
        and add any framebuffer device paths in your system (<code>/dev/fbs/kfb0</code>,
        <code>/dev/fbs/jfb0</code>, etc.) to this file, one device per line.
        For example: <br />
<pre class="verbatim">
touch&nbsp;/etc/dt/config/GraphicsDevices
for&nbsp;i&nbsp;in&nbsp;/dev/fbs/*[0-9];&nbsp;do&nbsp;echo&nbsp;$i&nbsp;&gt;&gt;/etc/dt/config/GraphicsDevices;&nbsp;done
</pre>

        You can choose to include only certain framebuffer devices in this
        file. Only the devices listed in <code>GraphicsDevices</code> will
        be available for use by VirtualGL.
    </li>
    <li class="Ordered">
        Grant read access to this file for the <code>vglusers</code> group.
        For example: <br />
<pre class="verbatim">
chgrp&nbsp;vglusers&nbsp;/etc/dt/config/GraphicsDevices
chmod&nbsp;640&nbsp;/etc/dt/config/GraphicsDevices
</pre>

    </li>
</ol>

<p>If you wish to make GLP the default for all users of the system, you
can add</p>

<pre class="verbatim">
VGL_DISPLAY=glp
export&nbsp;VGL_DISPLAY
</pre>

<p>to <code>/etc/profile</code>.  This will cause VirtualGL to use the
first device specified in <code>/etc/dt/config/GraphicsDevices</code>
as the default rendering device.  Users can override this default by
setting <code>VGL_DISPLAY</code> in one of their startup scripts (such
as <code>~/.profile</code> or <code>~/.login</code>) or by passing
an argument of <code>-d&nbsp;&lt;device&gt;</code> to <code>vglrun</code>
when invoking VirtualGL.  See Chapter
<a href="#Advanced_Configuration" class="ref">19</a> for more details.</p>


<h2 id="hd007002">7.2&nbsp;Granting Access to the Server&rsquo;s X Display</h2>

<div class="important"><p class="important">
If you plan to use VirtualGL only with <a href="#GLP_Usage">GLP</a><a name="idx0061"></a>, then you can skip this section.
</p></div>

<p>VirtualGL requires access to the server&rsquo;s 3D graphics card so
that it can create off-screen pixel buffers (Pbuffers) and redirect
the 3D rendering from applications into these Pbuffers.  Unfortunately,
accessing a 3D graphics card on Solaris/x86 systems or on Solaris/Sparc
systems without <a href="#GLP_Usage">GLP</a><a name="idx0062"></a>
requires going through an X server.  On such systems, the only way
to share the server&rsquo;s 3D graphics card among multiple users is
to grant those users access to the X server that is running on the
3D graphics card.</p>

<p>It is important to understand the security risks associated with this.
Once X display access is granted to a user, there is nothing that would
prevent that user from logging keystrokes or reading back images from
the X display. Using <code>xauth</code>, one can obtain &ldquo;untrusted&rdquo;
X authentication keys which prevent such exploits, but unfortunately,
those untrusted keys also disallow access to the 3D hardware.  So it
is necessary to grant full trusted X access to any users that will
need to run VirtualGL.  Unless you fully trust the users to whom you
are granting this access, you should avoid logging in locally to the
server&rsquo;s X display as root unless absolutely necessary.</p>

<p>This section will explain how to configure a VirtualGL server such
that select users can run VirtualGL, even if the server is sitting
at the login prompt. The basic idea is to call a script (<code>vglgenkey</code>)
from the display manager&rsquo;s startup script.  <code>vglgenkey</code>
invokes <code>xauth</code> to generate an authorization key for the
server&rsquo;s X display, and it stores this key under <code>/etc/opt/VirtualGL</code>.
The VirtualGL launcher script (<code>vglrun</code>) then attempts to
read this key and merge it into the user&rsquo;s <code>.Xauthority</code>
file, thus granting the user access to the server&rsquo;s X display.
Therefore, you can control who has access to the server&rsquo;s X display
simply by controlling who has read access to the <code>/etc/opt/VirtualGL</code>
directory.</p>

<p>If you prefer, you can also grant access to every authenticated user
on the server by replacing the references to <code>vglgenkey</code>
below with <code>xhost&nbsp;+localhost</code>.</p>


<h3 id="hd007002001">If your system is using dtlogin as a display manager:</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in as root.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        Create a new directory <code>/etc/opt/VirtualGL</code> and make it
        readable by the <code>vglusers</code> group.  For example: <br />
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/opt/VirtualGL
chgrp&nbsp;vglusers&nbsp;/etc/opt/VirtualGL
chmod&nbsp;750&nbsp;/etc/opt/VirtualGL
</pre>

    </li>
    <li class="Ordered">
        If the <code>/etc/dt/config</code> directory does not exist, create
        it.
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/dt/config
</pre>

    </li>
    <li class="Ordered">
        If <code>/etc/dt/config/Xsetup</code> does not exist, then copy the
        default <code>Xsetup</code> file from <code>/usr/dt/config</code> to
        that location:
<pre class="verbatim">
cp&nbsp;/usr/dt/config/Xsetup&nbsp;/etc/dt/config/Xsetup
</pre>

    </li>
    <li class="Ordered">
        Edit <code>/etc/dt/config/Xsetup</code>, and add the following lines
        to the bottom of the file:
<pre class="verbatim">
/opt/SUNWvgl/bin/vglgenkey
</pre>

    </li>
    <li class="Ordered">
        If <code>/etc/dt/config/Xconfig</code> does not exist, then copy the
        default <code>Xconfig</code> file from <code>/usr/dt/config</code>
        to that location:
<pre class="verbatim">
cp&nbsp;/usr/dt/config/Xconfig&nbsp;/etc/dt/config/Xconfig
</pre>

    </li>
    <li class="Ordered">
        Edit <code>/etc/dt/config/Xconfig</code>, and add (or uncomment) the
        following line:
<pre class="verbatim">
Dtlogin*grabServer:&nbsp;False
</pre>

        <dl class="Description">
            <dt class="Description">Explanation</dt>
            <dd class="Description">
                The <code>Dtlogin*grabServer</code> option restricts X display access
                to only the <code>dtlogin</code> process.  This is an added security
                measure, since it prevents a user from attaching any kind of sniffer
                program to the X display even if they have display access.  But <code>Dtlogin*grabServer</code>
                also prevents VirtualGL from using the X display to access the 3D graphics
                hardware, so this option must be disabled for VirtualGL to work properly.
            </dd>
        </dl>
        <div class="important"><p class="important">
        If the system you are configuring as a VirtualGL server is also being used as a Sun Ray server, then make these same modifications to <code>/etc/dt/config/Xconfig.SUNWut.prototype</code>.  Otherwise, the modifications you just made to <code>/etc/dt/config/Xconfig</code> will be overwritten the next time the system is restarted.
        </p></div>
    </li>
    <li class="Ordered">
        Unless you know that you absolutely need it, disable the XTEST extension.
        Disabling XTEST will not prevent a user from logging keystrokes or
        reading images from the X display, but it will prevent them from inserting
        key and mouse events and thus hijacking a local X session.
        <ol class="Ordered alpha" type="a">
            <li class="Ordered" value="1">
                If <code>/etc/dt/config/Xservers</code> does not exist, then copy the
                default <code>Xservers</code> file from <code>/usr/dt/config</code>
                to that location:
<pre class="verbatim">
cp&nbsp;/usr/dt/config/Xservers&nbsp;/etc/dt/config/Xservers
</pre>

            </li>
            <li class="Ordered" value="2">
                Edit <code>/etc/dt/config/Xservers</code> and add an argument of <code>-tst</code>
                to the line corresponding to the display number you are configuring.
                For example: <br />
<pre class="verbatim">
:0&nbsp;&nbsp;Local&nbsp;local_uid@console&nbsp;root&nbsp;/usr/openwin/bin/Xsun&nbsp;:0&nbsp;-nobanner&nbsp;-tst
</pre>

                <div class="important"><p class="important">
                If the system you are configuring as a VirtualGL server is also being used as a Sun Ray server, then make these same modifications to <code>/etc/dt/config/Xservers.SUNWut.prototype</code>.  Otherwise, the modifications you just made to <code>/etc/dt/config/Xservers</code> will be overwritten the next time the system is restarted.
                </p></div>
            </li>
        </ol>
    </li>
    <li class="Ordered">
        Verify that <code>/etc/dt/config</code> and <code>/etc/dt/config/Xsetup</code>
        can be executed by all users, and verify that <code>/etc/dt/config/Xconfig</code>
        and <code>/etc/dt/config/Xservers</code> can be read by all users.
    </li>
    <li class="Ordered">
        Restart the X server by issuing
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;stop;&nbsp;/etc/init.d/dtlogin&nbsp;start
</pre>

    </li>
    <li class="Ordered">
        To check your work, log out of the server, log back in via. SSh, and
        run
<pre class="verbatim">
/usr/openwin/bin/xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/usr/openwin/bin/xdpyinfo&nbsp;-display&nbsp;:0
</pre>

        In particular, make sure that XTEST doesn&rsquo;t show up in the list
        of extensions if you disabled it above.
    </li>
</ol>


<h3 id="hd007002002">If your system is using gdm as a display manager (gdm is available only on Solaris 10 or later):</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in as root.
    </li>
    <li class="Ordered">
        Create a new group called <code>vglusers</code> and add any users that
        need to run VirtualGL to this group.
    </li>
    <li class="Ordered">
        Create a new directory <code>/etc/opt/VirtualGL</code> and make it
        readable by the <code>vglusers</code> group.  For example: <br />
<pre class="verbatim">
mkdir&nbsp;-p&nbsp;/etc/opt/VirtualGL
chgrp&nbsp;vglusers&nbsp;/etc/opt/VirtualGL
chmod&nbsp;750&nbsp;/etc/opt/VirtualGL
</pre>

    </li>
    <li class="Ordered">
        Add
<pre class="verbatim">
/opt/SUNWvgl/bin/vglgenkey
</pre>

        to the top of the <code>/etc/X11/gdm/Init/Default</code> file.
    </li>
    <li class="Ordered">
        Edit <code>/etc/X11/gdm/gdm.conf</code> and add the following line
        under the <code>[security]</code> section (or change it if it already
        exists):
<pre class="verbatim">
DisallowTCP=false
</pre>

    </li>
    <li class="Ordered">
        Unless you know that you absolutely need it, disable the XTEST extension.
        Disabling XTEST will not prevent a user from logging keystrokes or
        reading images from the X display, but it will prevent them from inserting
        key and mouse events and thus hijacking a local X session.<br />
        <br /> Edit <code>/etc/X11/gdm/gdm.conf</code> and add <code>-tst</code>
        to all lines that appear to be X server command lines.  For example:
        <br />
<pre class="verbatim">
StandardXServer=/usr/X11R6/bin/Xorg&nbsp;-tst
</pre>

<pre class="verbatim">
[server-Standard]
command=/usr/X11R6/bin/Xorg&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

<pre class="verbatim">
[server-Terminal]
command=/usr/X11R6/bin/Xorg&nbsp;-tst&nbsp;-audit&nbsp;0&nbsp;-terminate
</pre>

<pre class="verbatim">
[server-Chooser]
command=/usr/X11R6/bin/Xorg&nbsp;-tst&nbsp;-audit&nbsp;0
</pre>

    </li>
    <li class="Ordered">
        Restart gdm by issuing
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm2-login;&nbsp;svcadm&nbsp;enable&nbsp;gdm2-login
</pre>

    </li>
    <li class="Ordered">
        To check your work, log out of the server, log back in via. SSh, and
        run
<pre class="verbatim">
/usr/openwin/bin/xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/usr/openwin/bin/xdpyinfo&nbsp;-display&nbsp;:0
</pre>

        In particular, make sure that XTEST doesn&rsquo;t show up in the list
        of extensions if you disabled it above.
    </li>
</ol>


<h2 id="hd007003">7.3&nbsp;Device Permissions</h2>

<p>Whether the server&rsquo;s 3D graphics card is being accessed through
GLP or through an X server, you must perform the following procedure
to enable VirtualGL users to access the framebuffer device(s):</p>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Edit <code>/etc/logindevperm</code> and comment out the &ldquo;frame
        buffers&rdquo; line.  For example: <br />
<pre class="verbatim">
#&nbsp;/dev/console&nbsp;&nbsp;&nbsp;&nbsp;0600&nbsp;&nbsp;&nbsp;&nbsp;/dev/fbs/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;frame&nbsp;buffers
</pre>

    </li>
    <li class="Ordered" value="2">
        Change the permissions and group for <code>/dev/fbs/*</code> to allow
        write access to anyone who will need to use VirtualGL.  For example:
        <br />
<pre class="verbatim">
chmod&nbsp;660&nbsp;/dev/fbs/*
chown&nbsp;root&nbsp;/dev/fbs/*
chgrp&nbsp;vglusers&nbsp;/dev/fbs/*
</pre>

    </li>
</ol>
<div class="important"><p class="important">
Explanation: Normally, when someone logs into a Solaris machine, the system will automatically assign ownership of the framebuffer devices to that user and set the permissions for the framebuffer devices to those specified in <code>/etc/logindevperm</code>.  The default setting in <code>/etc/logindevperm</code> disallows anyone from using the framebuffer devices except the user that is logged in.  But in order to run VirtualGL, a user needs write access to the framebuffer devices.  So in order to make the framebuffer a shared resource, it is necessary to disable the login device permissions mechanism for the framebuffer devices and manually set the owner and group for these devices such that any VirtualGL users can write to them.
</p></div>


<h2 id="hd007004">7.4&nbsp;SSh Server Configuration</h2>

<p>The server&rsquo;s SSh daemon should have the <code>X11Forwarding</code>
option enabled and the <code>UseLogin</code> option disabled.  This
is configured in <code>sshd_config</code>, the location of which varies
depending on your distribution of SSh.  Solaris 10 generally keeps
this in <code>/etc/ssh</code>, whereas Blastwave keeps it in <code>/opt/csw/etc</code>
and SunFreeware keeps it in <code>/usr/local/etc</code>.</p>

<hr class="break" />


<h1 id="hd008"><a name="file008"></a>8&nbsp;Configuring a Windows Machine as a VirtualGL Direct Mode Client</h1>

<ol class="Ordered numeric">
    <li class="Ordered">
        Install Hummingbird Exceed if it isn&rsquo;t already installed.
    </li>
    <li class="Ordered">
        Add the Exceed path (example: <code>C:\Program&nbsp;Files\Hummingbird\Connectivity\9.00\Exceed</code>)
        to the system <code>PATH</code> environment if it isn&rsquo;t already
        there.
    </li>
    <li class="Ordered">
        Install a Secure Shell (SSh) client.  If
        <span class="remote"><a href="http://www.cygwin.com/" class="remote">Cygwin</a></span><a name="idx0063"></a>
        is already installed, then you can use the SSh client included in Cygwin.
        Otherwise, download and install
        <span class="remote"><a href="http://sshwindows.sourceforge.net/" class="remote">SSHWindows</a></span><a name="idx0064"></a>
        or
        <span class="remote"><a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/" class="remote">PuTTY</a></span><a name="idx0065"></a>.
        <code>ssh.exe</code> or <code>putty.exe</code> should be somewhere
        in your <code>PATH</code>.
    </li>
</ol>


<h2 id="hd008001">8.1&nbsp;Optimizing Exceed</h2>


<h3 id="hd008001001">Disabling Pixel Format Conversion and Backing Store</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        In the &ldquo;X Server Protocol&rdquo; applet, select the &ldquo;Protocol&rdquo;
        tab and make sure that &ldquo;Use 32 bits per pixel for true color&rdquo;
        is not checked. <br /><br />
        <img src="exceed1.png" alt="exceed1" class="inline" id="imgid_1" name="imgid_1"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
    <li class="Ordered">
        Open the &ldquo;Other Server Settings&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Performance&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        Select the &ldquo;Performance&rdquo; tab and make sure that &ldquo;Default
        Backing Store&rdquo; is set to &ldquo;None.&rdquo; <br /><br />
        <img src="exceed3.png" alt="exceed3" class="inline" id="imgid_2" name="imgid_2"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h3 id="hd008001002">Enabling MIT-SHM</h3>

<p>VirtualGL has the ability to take advantage of the MIT-SHM extension
in Hummingbird Exceed to accelerate image drawing on Windows.  This
can improve the overall performance of the VirtualGL pipeline by as
much as 20% in some cases.</p>

<p>The bad news is that this extension has some issues in earlier versions
of Exceed.  If you are using Exceed 8 or 9, you will need to obtain
the following patches from the Hummingbird support site:</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Product</th>
    <th class="head standard">Patches Required</th>
    <th class="head standard">How to Obtain</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 8.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v8.0.0.28 (or higher)</td>
    <td class="standard">Download all patches from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0066"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 9.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v9.0.0.9 (or higher)</td>
    <td class="standard"><code>exceed.exe</code> can be patched by running Hummingbird Update.<br /> <br /> All other patches must be downloaded from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0067"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
</table>
</div>


<p>No patches should be necessary for Exceed 10 and above.</p>

<p>Next, you need to enable the MIT-SHM extension in Exceed:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        Select the &ldquo;Extensions&rdquo; tab and make sure that &ldquo;MIT-SHM&rdquo;
        is checked. <br /><br />
        <img src="exceed2.png" alt="exceed2" class="inline" id="imgid_3" name="imgid_3"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h2 id="hd008002">8.2&nbsp;Installing the VirtualGL Client as a Windows Service</h2>

<p>The VirtualGL Windows Client can be installed as a Windows service
(and subsequently removed) using the links provided in the &ldquo;VirtualGL
Client&rdquo; start menu group.  Once installed, the service can be
started from the Services applet in the Control Panel (located under
&ldquo;Administrative Tools&rdquo;) or by invoking</p>

<pre class="verbatim">
net&nbsp;start&nbsp;vglclient
</pre>

<p>from a command prompt.  The service can be subsequently stopped by
invoking</p>

<pre class="verbatim">
net&nbsp;stop&nbsp;vglclient
</pre>

<p>If you wish to install the client as a service and have it listen on
a port other than the default (4242 for unencrypted connections or
4243 for SSL connections), then you will need to install the service
manually from the command line.</p>

<pre class="verbatim">
vglclient&nbsp;-?
</pre>

<p>gives a list of the relevant command-line options.</p>

<hr class="break" />


<h1 id="hd009"><a name="file009"></a>9&nbsp;Using VirtualGL in Direct Mode</h1>

<p><a name="Direct_Mode_Usage"></a></p>


<h2 id="hd009001">9.1&nbsp;Direct Mode with X11 Forwarding</h2>

<p><a name="X11_Forwarding"></a></p>


<h3 id="hd009001001">Performance</h3>

<p>Optimal</p>


<h3 id="hd009001002">Security Notes</h3>

<p>X11 traffic is encrypted, but the VirtualGL image stream is left unencrypted
to maximize performance.</p>


<h3 id="hd009001003">Procedure</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the X server/Exceed if it isn&rsquo;t started already.
    </li>
    <li class="Ordered">
        Start the VirtualGL Client program:
        <dl class="Description">
            <dt class="Description">Linux and Solaris clients</dt>
            <dd class="Description">
                Open a terminal window and type
<pre class="verbatim">
/opt/VirtualGL/bin/vglclient
</pre>

            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                If the VirtualGL client has not been started as a service, then start
                it manually by selecting <em>Start VirtualGL Client</em> in the <em>VirtualGL
                Client</em> Start Menu group.
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        Open a new Command Prompt/terminal window.
    </li>
    <li class="Ordered">

        <dl class="Description">
            <dt class="Description">Linux and Solaris clients</dt>
            <dd class="Description">
                In the new terminal window, type
<pre class="verbatim">
echo&nbsp;$DISPLAY
</pre>

        and make a note of the value.
            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                In the new Command Prompt window, type
<pre class="verbatim">
set&nbsp;DISPLAY&nbsp;localhost:{n}.0
</pre>

        Replace <code>{n}</code> with the display number that Exceed is occupying.
        To obtain this, hover over the Exceed icon in the taskbar and make
        a note of the value it displays (usually <code>:0.0</code>, unless
        you have multiple Exceed sessions running.)
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        In the same Command Prompt/terminal window, open a Secure Shell (SSh)
        session into the VirtualGL server by typing:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;{user}@{server}
</pre>

        Replace <code>{user}</code> with your user account name on the VirtualGL
        server and <code>{server}</code> with the hostname or IP address of
        that server.
        <div class="important"><p class="important">
        If using PuTTY, replace <code>ssh</code> with <code>putty</code> in the above example.
        </p></div>
    </li>
    <li class="Ordered">
        If the X server on your client machine is using a display number of
        0 (usually the case), then you can skip this step.  Otherwise, set
        the <code>VGL_CLIENT</code> environment variable on the VirtualGL server
        to point to the client&rsquo;s X display: <br />
<pre class="verbatim">
export&nbsp;VGL_CLIENT={client}:{n}.0
</pre>

        or
<pre class="verbatim">
setenv&nbsp;VGL_CLIENT&nbsp;{client}:{n}.0
</pre>

        Replace <code>{client}</code> with the hostname or IP address of your
        client machine (<code>echo&nbsp;$SSH_CLIENT</code> if you don&rsquo;t
        know this) and <code>{n}</code> with the display number of the client
        machine&rsquo;s X display (obtained in Step 4.)
    </li>
    <li class="Ordered">
        In the SSh session, start the 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h2 id="hd009002">9.2&nbsp;Direct Mode with a Direct X11 Connection</h2>

<p><a name="Direct_X11_Connection"></a></p>


<h3 id="hd009002001">Performance</h3>

<p>Optimal</p>


<h3 id="hd009002002">Security Notes</h3>

<ul class="Itemize">
    <li class="Itemize dash">
        Both the X11 traffic and the VirtualGL image stream are unencrypted.
    </li>
    <li class="Itemize dash">
        Some newer Linux and Solaris distributions ship with default settings
        that do not allow TCP connections into the X server.  Such systems
        cannot be used as clients with this procedure unless they are reconfigured
        to allow X11 TCP connections.
    </li>
</ul>


<h3 id="hd009002003">Procedure</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the X server/Exceed if it isn&rsquo;t started already.
    </li>
    <li class="Ordered">
        Start the VirtualGL Client program:
        <dl class="Description">
            <dt class="Description">Linux and Solaris clients</dt>
            <dd class="Description">
                Open a terminal window and type
<pre class="verbatim">
/opt/VirtualGL/bin/vglclient
</pre>

            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                If the VirtualGL client has not been started as a service, then start
                it manually by selecting <em>Start VirtualGL Client</em> in the <em>VirtualGL
                Client</em> Start Menu group.
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        Open a new Command Prompt/terminal window.
    </li>
    <li class="Ordered">

        <dl class="Description">
            <dt class="Description">Linux and Solaris clients</dt>
            <dd class="Description">
                In the new terminal window, type
<pre class="verbatim">
echo&nbsp;$DISPLAY
</pre>

        and make a note of the value.
            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                Hover over the Exceed icon in the taskbar, and make a note of the display
                number that Exceed is occupying (usually <code>:0.0</code>, unless
                you have multiple Exceed sessions running.)
            </dd>
        </dl>
    </li>
    <li class="Ordered">

        <dl class="Description">
            <dt class="Description">Linux and Solaris clients</dt>
            <dd class="Description">
                In the same terminal window, type
<pre class="verbatim">
xhost&nbsp;+{server}
</pre>

        Replace <code>{server}</code> with the hostname or IP address of the
        VirtualGL server.
            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                Configure Exceed to grant display access to any VirtualGL servers that
                you plan to use.
                <ol class="Ordered alpha" type="a">
                    <li class="Ordered" value="1">
                        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
                        <em>Tools&ndash;&gt;Configuration</em>.)
                    </li>
                    <li class="Ordered" value="2">
                        In XConfig, open the &ldquo;Security Access Control and System Administration&rdquo;
                        applet (if using Category View) or the &ldquo;Security&rdquo; applet
                        (if using Classic View.)
                    </li>
                    <li class="Ordered" value="3">
                        Select &ldquo;File&rdquo; under &ldquo;Host Access Control List&rdquo;,
                        then click the &ldquo;Edit&rdquo; button.  This opens <code>xhost.txt</code>
                        in Notepad.
                        <img src="exceed5.png" alt="exceed5" class="inline" id="imgid_4" name="imgid_4"/>
                    </li>
                    <li class="Ordered" value="4">
                        Add the hostnames or IP addresses of any VirtualGL servers you plan
                        to use to this file (one per line), save the file, and exit Notepad.
                    </li>
                    <li class="Ordered" value="5">
                        Back in XConfig, click &ldquo;Validate and Apply Changes.&rdquo;  If
                        prompted to reset the X server, click &ldquo;Yes.&rdquo;
                    </li>
                </ol>
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        In the Command Prompt/terminal window, open a Secure Shell (SSh) session
        into the VirtualGL server by typing:
<pre class="verbatim">
ssh&nbsp;{user}@{server}
</pre>

        Replace <code>{user}</code> with your user account name on the VirtualGL
        server and <code>{server}</code> with the hostname or IP address of
        that server.
        <div class="important"><p class="important">
        If using PuTTY, replace <code>ssh</code> with <code>putty</code> in the above example.
        </p></div>
    </li>
    <li class="Ordered">
        If the X server on your client machine is using a display number of
        0 (usually the case), then you can skip this step.  Otherwise, set
        the <code>DISPLAY</code> environment variable on the VirtualGL server
        to point to the client&rsquo;s X display: <br />
<pre class="verbatim">
export&nbsp;DISPLAY={client}:{n}.0
</pre>

        or
<pre class="verbatim">
setenv&nbsp;DISPLAY&nbsp;{client}:{n}.0
</pre>

        Replace <code>{client}</code> with the hostname or IP address of your
        client machine (<code>echo&nbsp;$SSH_CLIENT</code> if you don&rsquo;t
        know this) and <code>{n}</code> with the display number of the client
        machine&rsquo;s X display (obtained in Step 4.)
    </li>
    <li class="Ordered">
        In the SSh session, start the 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h2 id="hd009003">9.3&nbsp;Direct Mode with SSL Encryption</h2>


<h3 id="hd009003001">Performance</h3>

<p>On high-speed networks such as Ethernet, VirtualGL&rsquo;s performance
is reduced by as much as 20% by enabling SSL encryption.</p>


<h3 id="hd009003002">Security Notes</h3>

<ul class="Itemize">
    <li class="Itemize dash">
        The VirtualGL image stream is encrypted.
    </li>
    <li class="Itemize dash">
        When used in conjunction with X11 Forwarding, this provides a completely
        secure solution.
    </li>
</ul>


<h3 id="hd009003003">Procedure</h3>

<p>Pass an argument of <code>+s</code> to <code>vglrun</code> when launching
VirtualGL, or set the environment variable <code>VGL_SSL</code> to
<code>1</code> on the VirtualGL server. (see Chapter
<a href="#Advanced_Configuration" class="ref">19</a> for more details.)</p>


<h2 id="hd009004">9.4&nbsp;Direct Mode with X11 Forwarding and SSh Tunneling</h2>


<h3 id="hd009004001">Performance</h3>

<ul class="Itemize">
    <li class="Itemize dash">
        On high-speed networks such as Ethernet, VirtualGL&rsquo;s performance
        is reduced by as much as 20% by enabling SSh Tunneling.
    </li>
    <li class="Itemize dash">
        SSh tunneling using OpenSSH (Cygwin or SSHWindows on Windows machines)
        generally performs about the same as VirtualGL&rsquo;s built-in SSL
        encryption.
    </li>
    <li class="Itemize dash">
        SSh tunneling using PuTTY generally performs about 30% slower than
        OpenSSH or VirtualGL&rsquo;s built-in SSL encryption.
    </li>
</ul>


<h3 id="hd009004002">Security Notes</h3>

<ul class="Itemize">
    <li class="Itemize dash">
        Both the X11 traffic and the VirtualGL image stream are encrypted.
    </li>
    <li class="Itemize dash">
        Use SSh Tunneling if a firewall separates the client and server machines,
        thus making it impossible for the VirtualGL server to make a Direct
        Mode connection to the VirtualGL client.
    </li>
</ul>


<h3 id="hd009004003">Procedure</h3>

<p>The procedure is the same as for the <a href="#X11_Forwarding">X11
Forwarding</a><a name="idx0068"></a> case, except that the following
additional steps need to be taken:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Once connected to the VirtualGL server via. SSh, execute the following
        command:
<pre class="verbatim">
/opt/VirtualGL/bin/nettest&nbsp;-findport
</pre>

        This program will allocate a free TCP port number and print the number
        to the console.  Make a note of it.
    </li>
    <li class="Ordered">
        Close the SSh session and re-open it using the following command line:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;-R&nbsp;{port}:localhost:4242&nbsp;{user}@{server}
</pre>

        Replace <code>{port}</code> with the port number you obtained in Step
        1.
        <div class="important"><p class="important">
        If you are using an OpenSSH client, you can also type the following key sequence: <code>&lt;ENTER&gt;&nbsp;~&nbsp;C</code> (that&rsquo;s the Enter key, followed by a tilde, followed by a capital C), which will bring up an <code>ssh&gt;</code> prompt at which you can enter <code>-R&nbsp;{port}:localhost:4242</code>.  This allows you to set up the tunnel without closing and re-opening the SSh session.
        </p></div>
    </li>
    <li class="Ordered">
        Once connected to the server for the second time, set the <code>VGL_PORT</code>
        environment variable to match the port number you obtained above.
    </li>
    <li class="Ordered">
        Set the <code>VGL_CLIENT</code> environment variable on the VirtualGL
        server to <code>localhost:{n}.0</code>, where <code>{n}</code> is the
        display number of the X server running on the client machine.
        <div class="important"><p class="important">
        Explanation: When you established the SSh connection using the <code>-R</code> argument, it created a listener on the VirtualGL server.  That listener will accept a connection from VirtualGL and forward the connection over the SSh tunnel to port 4242 on the client machine.  Thus, you need to set <code>VGL_PORT</code> and <code>VGL_CLIENT</code> on the VirtualGL server to tell VirtualGL to make a connection to the SSh listener rather than the &ldquo;real&rdquo; VirtualGL client program.
        </p></div>
        <hr class="break" />
    </li>
</ol>


<h1 id="hd0010"><a name="file010"></a>10&nbsp;Using VirtualGL in Raw Mode with TurboVNC</h1>

<p><a name="TurboVNC_Usage"></a></p>

<p>Referring to Chapter <a href="#Overview" class="ref">2</a>, Raw Mode
is a mode in which VirtualGL bypasses its internal image compressor
and instead sends the rendered 3D images to an X server as uncompressed
bitmaps.  Raw Mode is designed to be used with an &ldquo;X Proxy&rdquo;,
which is a virtual X server that intercepts X-Windows commands from
an application, renders them into images, compresses the images, and
sends them over the network to a client.</p>

<p>Thus, in Raw Mode, VirtualGL relies on the X proxy to compress the
rendered 3D images, and since VirtualGL is sending those images to
the X proxy at a very fast rate, the proxy must be able to compress
the images very quickly in order to keep up.  But, unfortunately, most
X proxies can&rsquo;t.  They simply aren&rsquo;t designed for the types
of full-screen video workloads that VirtualGL generates.  Therefore,
the VirtualGL Project provides an optimized X proxy known as TurboVNC,
which is based on the
<span class="remote"><a href="http://www.realvnc.com/" class="remote">Virtual
Network Computing (VNC)</a></span><a name="idx0069"></a> standard (more
specifically, on the
<span class="remote"><a href="http://www.tightvnc.com" class="remote">TightVNC</a></span><a name="idx0070"></a>
variant thereof.)</p>

<p>On the surface, TurboVNC behaves very similarly to its parent project,
but TurboVNC has been tuned to provide interactive performance for
the types of full-screen video workloads that VirtualGL produces. 
On these types of image workloads, TurboVNC performs as much as an
order of magnitude faster than TightVNC, uses more than an order of
magnitude less CPU time to compress each frame, and it produces comparable
compression ratios.  Part of this speedup comes from the use of TurboJPEG,
the same high-speed vector-optimized JPEG codec used by VirtualGL.
Another large part of the speedup comes from bypassing the color compression
features of TightVNC.  TightVNC performs very CPU-intensive analysis
on each image tile to determine whether the tile will compress better
using color compression or JPEG.  But for the types of images that
a 3D application generates, it is almost never the case that color
compression compresses better than JPEG, so TurboVNC bypasses this
analysis to improve performance.  TurboVNC also has the ability to
hide network latency by decompressing and drawing a frame on the client
while the next frame is being fetched from the server, thus improving
performance dramatically on high-latency connections.  TurboVNC additionally
provides client-side double buffering, full support for Solaris, and
other tweaks.</p>

<p>There are several reasons why one might prefer to use Raw Mode + TurboVNC
over Direct Mode (and several reasons why one might not.)</p>


<h3 id="hd0010000001">Advantages of Raw Mode + TurboVNC</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        TurboVNC eliminates the need to send X11 traffic over the network,
        thus it performs very well on low-bandwidth, high-latency connections
        (such as broadband or long-haul T1 lines.)  The application GUI will
        load and render much faster (perhaps even orders of magnitude faster)
        with TurboVNC than with Direct Mode on such connections.
    </li>
    <li class="Itemize asterisk">
        TurboVNC provides rudimentary collaboration capabilities.  Multiple
        clients can simultaneously view the same server session and pass around
        control of the keyboard and mouse.
    </li>
    <li class="Itemize asterisk">
        The TurboVNC client is stateless.  If the network hiccups or the client
        is otherwise disconnected, the session remains running on the server
        and can be rejoined from any machine on the network.
    </li>
    <li class="Itemize asterisk">
        No X server is required on the client machine.  This reduces the deployment
        cost and complexity for Windows clients.
    </li>
    <li class="Itemize asterisk">
        TurboVNC is generally easier to set up and use.
    </li>
</ul>


<h3 id="hd0010000002">Advantages of Direct Mode</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        Direct Mode performs significantly faster (generally about 25-30% faster)
        than TurboVNC on local-area networks.
    </li>
    <li class="Itemize asterisk">
        Direct Mode provides seamless windows, whereby each application window
        appears as a separate window on the user&rsquo;s desktop.  TurboVNC,
        on the other hand, displays the entire virtual desktop in a single
        window, which does not create a seamless experience.
    </li>
    <li class="Itemize asterisk">
        Direct Mode consumes fewer server CPU resources.  TurboVNC will generally
        require about 20% more server CPU cycles to maintain the same frame
        rate as Direct Mode, both because it has to compress more pixels in
        each frame (an entire desktop rather than a single window) and because
        it has to perform 2D (X11) rendering as well as 3D rendering.  In Direct
        Mode, the 2D (X11) rendering is offloaded to the client machine.
    </li>
    <li class="Itemize asterisk">
        Direct Mode supports stereographic rendering and transparent overlays.
    </li>
</ul>


<h2 id="hd0010001">10.1&nbsp;Using Raw Mode When TurboVNC and VirtualGL Are Running on the Same Machine</h2>

<div class="figure">
<img src="rawmodetoxproxy.png" alt="rawmodetoxproxy" class="figure" id="imgid_18" name="imgid_18"/>
</div>

<ol class="Ordered numeric">
    <li class="Ordered">
        Open a new Command Prompt/terminal window on your client machine.
    </li>
    <li class="Ordered">
        In the new Command Prompt/terminal window, open a Secure Shell (SSh)
        session into the VirtualGL/TurboVNC server machine by typing:
<pre class="verbatim">
ssh&nbsp;{user}@{server}
</pre>

        Replace <code>{user}</code> with your user account name on the VirtualGL
        server and <code>{server}</code> with the hostname or IP address of
        that server.
        <div class="important"><p class="important">
        If using PuTTY, replace <code>ssh</code> with <code>putty</code> in the above example.
        </p></div>
    </li>
    <li class="Ordered">
        In the SSh session, start a TurboVNC server session:
<pre class="verbatim">
/opt/TurboVNC/bin/vncserver
</pre>

    </li>
    <li class="Ordered">
        Make a note of the X display number that the TurboVNC server process
        prints out, for instance: <br /><br /> <code>New&nbsp;'X'&nbsp;desktop&nbsp;is&nbsp;my_server:1</code>
        <br /><br /> If this is the first time that a TurboVNC server session
        has ever been run under this user account, TurboVNC will prompt for
        a VNC session password.
    </li>
    <li class="Ordered">
        The SSh session can now be exited, if desired.
    </li>
    <li class="Ordered">
        On the client machine, start the TurboVNC Viewer.
        <dl class="Description">
            <dt class="Description">Linux and Solaris clients</dt>
            <dd class="Description">
                 Open a terminal and type
<pre class="verbatim">
/opt/TurboVNC/bin/vncviewer
</pre>

            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                 Select <em>TurboVNC Viewer</em> in the <em>TurboVNC</em> Start Menu
                 group.
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        A small dialog box will appear. <br /><br />
        <div class="table">
        <table class="standard">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard">Windows TurboVNC viewer</th>
            <th class="head standard">Linux/Solaris TurboVNC viewer</th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="standard"><img src="turbovnc1.png" alt="turbovnc1" class="inline" id="imgid_5" name="imgid_5"/></td>
            <td class="standard"><img src="turbovnc2.png" alt="turbovnc2" class="inline" id="imgid_6" name="imgid_6"/></td>
          </tr>
        </table>
        </div>
        
        <br /> Enter the X display name (hostname/IP address and display number)
        of the TurboVNC server in the &ldquo;VNC Server&rdquo; field, then
        click &ldquo;Connect&rdquo; (Windows) or press Enter (Linux/Solaris.)
    </li>
    <li class="Ordered">
        Another dialog box appears, prompting for the VNC session password.
        <br /><br />
        <div class="table">
        <table class="standard">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard">Windows TurboVNC viewer</th>
            <th class="head standard">Linux/Solaris TurboVNC viewer</th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="standard"><img src="turbovnc3.png" alt="turbovnc3" class="inline" id="imgid_7" name="imgid_7"/></td>
            <td class="standard"><img src="turbovnc4.png" alt="turbovnc4" class="inline" id="imgid_8" name="imgid_8"/></td>
          </tr>
        </table>
        </div>
        
        <br /> Enter the TurboVNC session password and click &ldquo;OK&rdquo;
        (Windows) or press Enter (Linux/Solaris.) <br /><br /> A TurboVNC desktop
        window should appear on your client machine.  This window contains
        a virtual X server with which you can interact to launch X-Windows
        applications on the TurboVNC server machine.
    </li>
    <li class="Ordered">
        Open a new terminal inside the TurboVNC desktop.
    </li>
    <li class="Ordered">
        In the terminal, start the 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h2 id="hd0010002">10.2&nbsp;Using Raw Mode When TurboVNC and VirtualGL Are Running on Different Machines</h2>

<div class="figure">
<img src="rawmodeoverservernetwork.png" alt="rawmodeoverservernetwork" class="figure" id="imgid_19" name="imgid_19"/>
</div>

<p>If TurboVNC and VirtualGL are running on different servers, then it
is desirable to use Raw Mode to send images from the VirtualGL server
to the TurboVNC server.  Otherwise, the images would have to be compressed
by the VirtualGL server, decompressed by the VirtualGL client, then
recompressed by the TurboVNC server, which is a waste of CPU resources.
However, sending images uncompressed over a network requires a fast
network (generally, Gigabit Ethernet or faster.)  So there needs to
be a fast link between the VirtualGL server and the TurboVNC server
for this procedure to perform well.</p>

<p>The procedure for using Raw Mode to transmit images from a VirtualGL
server to a TurboVNC server is essentially the same as the procedure
for using Direct Mode with a <a href="#Direct_X11_Connection">Direct
X11 Connection</a><a name="idx0071"></a> &ndash; with the following
notable differences:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        The &ldquo;client&rdquo; in this case is really the TurboVNC server
        machine.
    </li>
    <li class="Ordered">
        The &ldquo;X server&rdquo; is really the TurboVNC server session.
    </li>
    <li class="Ordered">
        It is not necessary to start the VirtualGL client.
    </li>
    <li class="Ordered">
        Once connected to the VirtualGL server via. SSh, it is necessary to
        either set the environment variable <code>VGL_COMPRESS</code> to <code>0</code>
        or pass an argument of <code>-c&nbsp;0</code> to <code>vglrun</code>
        when launching VirtualGL.  Otherwise, VirtualGL will detect that the
        connection to the X server is remote, and it will automatically try
        to enable Direct Mode.  Setting <code>VGL_COMPRESS</code> to <code>0</code>
        forces the use of Raw Mode, regardless of whether the X server is local
        or remote.
    </li>
</ol>


<h2 id="hd0010003">10.3&nbsp;Disconnecting and Killing the TurboVNC Session</h2>

<p>Closing the TurboVNC viewer disconnects from the TurboVNC server session,
but the TurboVNC server session (and any applications that you may
have started in it) is still running on the server machine, and you
can reconnect to it at any time.</p>

<p>To kill a TurboVNC server session:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in to the TurboVNC server using SSh.
    </li>
    <li class="Ordered">
        Type the following command:
        <dl class="Description">
            <dt class="Description">Linux server</dt>
            <dd class="Description">
<pre class="verbatim">
/opt/TurboVNC/bin/vncserver&nbsp;-kill&nbsp;:{n}
</pre>

            </dd>
            <dt class="Description">Solaris</dt>
            <dd class="Description">
<pre class="verbatim">
/opt/SUNWtvnc/bin/vncserver&nbsp;-kill&nbsp;:{n}
</pre>

            </dd>
        </dl>
        Replace <code>{n}</code> with the X display number of the TurboVNC
        server session you wish to kill.
    </li>
</ol>

<p>To list the X display numbers and process ID&rsquo;s of all TurboVNC
server sessions that are currently running under your user account
on this machine, run</p>

<dl class="Description">
    <dt class="Description">Linux server</dt>
    <dd class="Description">
<pre class="verbatim">
/opt/TurboVNC/bin/vncserver&nbsp;-list
</pre>

    </dd>
    <dt class="Description">Solaris server</dt>
    <dd class="Description">
<pre class="verbatim">
/opt/SUNWtvnc/bin/vncserver&nbsp;-list
</pre>

    </dd>
</dl>


<h2 id="hd0010004">10.4&nbsp;Using TurboVNC in a Web Browser</h2>

<p>When a TurboVNC server session is created, it automatically launches
a miniature web server that serves up a Java TurboVNC viewer applet.
This Java TurboVNC viewer can be used to connect to the TurboVNC server
from a machine that does not have a native TurboVNC viewer installed
(or a machine for which no native TurboVNC viewer is available.)  The
Java viewer is significantly slower than the native viewer on high-speed
networks, but on low-speed networks the Java viewer and native viewers
have comparable performance.  The Java viewer does not currently support
double buffering.</p>

<p>To use the Java TurboVNC viewer, point your web browser to:</p>

<p><code>http://turbovnc_server:{5800+n}</code></p>

<p>where <code>{turbovnc_server}</code> is the hostname or IP address
of the TurboVNC server machine, and <code>n</code> is the X display
number of the TurboVNC server session to which you want to connect.</p>

<p><em>Example:</em> If the TurboVNC server is running on X display <code>my_server:1</code>,
then point your web browser to:</p>

<p><code>http://my_server:5801</code></p>


<h2 id="hd0010005">10.5&nbsp;Connection Profiles: Optimizing TurboVNC&rsquo;s Performance for Different Network Types</h2>

<p>To get the peak performance out of TurboVNC, you must give it a hint
about the type of network that separates your client machine from the
TurboVNC server.  To do this, select a Connection Profile when launching
the TurboVNC viewer.</p>

<p>In the Windows TurboVNC viewer, there are three buttons in the TurboVNC
Connection dialog box that allow you to easily select the connection
profile. In the Java viewer, the same thing is accomplished by clicking
the &ldquo;Options&rdquo; button at the top of the browser window.
With the Linux/Solaris TurboVNC viewer, you can either use command
line options to set the connection profile prior to connecting, or
you can press the F8 key after connecting to pop up a menu from which
you can select the connection profile.</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Linux/Solaris TurboVNC viewer</th>
    <th class="head standard">Windows &amp; Java TurboVNC viewers</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">High-bandwidth, low-latency network</td>
    <td class="standard">No action necessary</td>
    <td class="standard">Select &ldquo;High-Speed Network&rdquo; Connection Profile.</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Low-bandwidth, high-latency network (favor performance over image quality)</td>
    <td class="standard">Pass argument of <code>-broadband</code> to <code>vncviewer</code> or select &ldquo;Preset: Broadband (favor performance)&rdquo; from the F8 popup menu</td>
    <td class="standard">Select &ldquo;Broadband (favor performance)&rdquo; Connection Profile.</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Low-bandwidth, high-latency network (favor image quality over performance)</td>
    <td class="standard">Pass argument of <code>-wan</code> to <code>vncviewer</code> or select &ldquo;Preset: Broadband (favor image quality)&rdquo; from the F8 popup menu</td>
    <td class="standard">Select &ldquo;Broadband (favor image quality)&rdquo; Connection Profile.</td>
  </tr>
</table>
</div>


<p>The &ldquo;High-Speed Network&rdquo; and &ldquo;Broadband (favor image
quality)&rdquo; connection profiles set the JPEG compression quality
to a high enough level that the compression loss is not perceivable
by the human eye.  The &ldquo;Broadband (favor performance)&rdquo;
connection profile sets the image quality to a very low (but still
usable) level which will achieve interactive performance on typical
broadband connections.</p>


<h2 id="hd0010006">10.6&nbsp;Securing a TurboVNC Connection</h2>

<p>Normally, the connection between the TurboVNC server and the TurboVNC
viewer is completely unencrypted, but securing that connection can
be easily accomplished by using the port forwarding feature of Secure
Shell (SSh.)  After you have started a TurboVNC server session on the
server machine, open a new SSh connection into the server machine using
the following command line:</p>

<pre class="verbatim">
ssh&nbsp;-L&nbsp;{5900+n}:localhost:{5900+n}&nbsp;{user}@{server}
</pre>

<div class="important"><p class="important">
If using PuTTY, replace <code>ssh</code> with <code>putty</code> in the above example.
</p></div>

<p>Replace <code>{user}</code> with your user account name on the TurboVNC
server and <code>{server}</code> with the hostname or IP address of
that server.  Replace <code>n</code> with the X display number of the
TurboVNC server session to which you want to connect.</p>

<p>For instance, if you wish to connect to display <code>:1</code> on
server <code>my_server</code> using user account <code>my_user</code>,
you would type</p>

<pre class="verbatim">
ssh&nbsp;-L&nbsp;5901:localhost:5901&nbsp;my_user@my_server
</pre>

<p>After the SSh connection has been established, you can then launch
the TurboVNC viewer and point it to <code>localhost:{n}</code> (<code>localhost:1</code>
in the above example.)</p>


<h3 id="hd0010006001">Performance Notes</h3>

<p>For LAN connections and other high-speed networks, tunneling the TurboVNC
connection over SSh will reduce performance by as much as 20% (50%
if using PuTTY.)  But for wide-area networks, broadband, etc., there
is no performance penalty for using SSh tunneling with TurboVNC.</p>


<h2 id="hd0010007">10.7&nbsp;Further Reading</h2>

<p>For more detailed instructions on the usage of TurboVNC:</p>

<dl class="Description">
    <dt class="Description">Linux</dt>
    <dd class="Description">
        Refer to the TurboVNC man pages:
<pre class="verbatim">
man&nbsp;-M&nbsp;/opt/TurboVNC/man&nbsp;{vncserver&nbsp;|&nbsp;Xvnc&nbsp;|&nbsp;vncviewer&nbsp;|&nbsp;vncconnect&nbsp;|&nbsp;vncpasswd}
</pre>

    </dd>
    <dt class="Description">Solaris</dt>
    <dd class="Description">
        Refer to the TurboVNC man pages:
<pre class="verbatim">
man&nbsp;-M&nbsp;/opt/SUNWtvnc/man&nbsp;{vncserver&nbsp;|&nbsp;Xvnc&nbsp;|&nbsp;vncviewer&nbsp;|&nbsp;vncconnect&nbsp;|&nbsp;vncpasswd}
</pre>

    </dd>
    <dt class="Description">Windows</dt>
    <dd class="Description">
        Use the embedded help feature (the question mark button in the upper
        right of the TurboVNC Viewer window.)
    </dd>
</dl>

<p>The TightVNC documentation:</p>

<p><a href="http://www.tightvnc.com/docs.html">http://www.tightvnc.com/docs.html</a></p>

<p>might also be helpful, since TurboVNC is based on TightVNC and shares
many of its features.</p>

<hr class="break" />


<h1 id="hd0011"><a name="file011"></a>11&nbsp;Using VirtualGL in Raw Mode with Other X Servers and Proxies</h1>


<h3 id="hd0011000001">Other X Proxies</h3>

<p>The <a href="#TurboVNC_Usage">previous chapter</a><a name="idx0072"></a>
described how to use VirtualGL in Raw Mode with TurboVNC, but much
of this information is also applicable to other X proxies, such as
RealVNC, NX, etc.  Generally, none of these other solutions will provide
anywhere near the performance of TurboVNC, but some of them have capabilities
that TurboVNC lacks (NX, for instance, can do seamless windows.)</p>

<p>VirtualGL reads the value of the <code>DISPLAY</code> environment variable
to determine whether to enable Raw Mode by default.  If <code>DISPLAY</code>
begins with a colon (&ldquo;<code>:</code>&rdquo;) or with &ldquo;<code>unix:</code>&rdquo;,
then VirtualGL will enable Raw Mode as the default.  This should effectively
make Raw Mode the default for most X proxies, but if for some reason
it doesn&rsquo;t, then you can force the use of Raw Mode by setting
<code>VGL_COMPRESS</code> to <code>0</code> or passing an argument
of <code>-c&nbsp;0</code> to <code>vglrun</code>.</p>


<h3 id="hd0011000002">Raw Mode Over a Network</h3>

<p><a name="Raw_Mode_Over_Network"></a></p>

<div class="figure">
<img src="rawmodeovernetwork.png" alt="rawmodeovernetwork" class="figure" id="imgid_20" name="imgid_20"/>
</div>

<p>The <a href="#TurboVNC_Usage">previous chapter</a><a name="idx0073"></a>
described how to use Raw Mode over a server network to send uncompressed
pixels from a VirtualGL server to a TurboVNC server.  But Raw Mode
can also be used to send uncompressed pixels to a client machine. 
There are two main reasons why you might want to do this:</p>

<ul class="Itemize">
    <li class="Itemize dash">
        Raw Mode may perform better than Direct Mode if the client or server
        CPU is extremely slow but the network is extremely fast (Gigabit or
        faster.)
    </li>
    <li class="Itemize dash">
        Raw Mode uses about half the server CPU cycles to maintain the same
        frame rate as Direct Mode.  This can allow smaller servers to accommodate
        more users.
    </li>
</ul>

<p>The procedure for using Raw Mode over a network is the same as the
procedure for using Direct Mode with a <a href="#Direct_X11_Connection">Direct
X11 Connection</a><a name="idx0074"></a> &ndash; with the following
notable differences:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        It is not necessary to install or run the VirtualGL client.
    </li>
    <li class="Ordered">
        Once connected to the VirtualGL server via. SSh, it is necessary to
        either set the environment variable <code>VGL_COMPRESS</code> to <code>0</code>
        or pass an argument of <code>-c&nbsp;0</code> to <code>vglrun</code>
        when launching VirtualGL.  Otherwise, VirtualGL will detect that the
        connection to the X server is remote, and it will automatically try
        to enable Direct Mode.  Setting <code>VGL_COMPRESS</code> to <code>0</code>
        forces the use of Raw Mode, regardless of whether the X server is local
        or remote.
    </li>
</ol>


<h3 id="hd0011000003">WORD OF CAUTION</h3>

<p>Do not use SSh X11 tunneling with Raw Mode, as this will reduce the
performance by 80% or more.  It is necessary to use a direct X11 connection
to sustain an interactive frame rate with Raw Mode on Gigabit networks.</p>

<hr class="break" />


<h1 id="hd0012"><a name="file012"></a>12&nbsp;<code>vglrun</code> and Solaris Shell Scripts</h1>

<p><code>vglrun</code> can be used to launch either binary executables
or shell scripts, but there are a few things to keep in mind when using
<code>vglrun</code> to launch a shell script on Solaris.  When you
<code>vglrun</code> a shell script, the VirtualGL faker library will
be preloaded into every executable that the script launches. Normally
this is innocuous, but if the script calls any executables that are
setuid root, then Solaris will refuse to load those executables because
you are attempting to preload a library (VirtualGL) that is not in
a &ldquo;secure path.&rdquo; Solaris keeps a tight lid on what goes
into <code>/usr/lib</code> and <code>/lib</code>, and by default, it
will only allow libraries in those paths to be preloaded into an executable
that is setuid root.  Generally, 3rd party packages are verboden from
installing anything into <code>/usr/lib</code> or <code>/lib</code>.
But you can use the <code>crle</code> utility to add other directories
to the operating system&rsquo;s list of secure paths.  In the case
of VirtualGL, you would execute the following commands (as root):</p>

<pre class="verbatim">
crle&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib
crle&nbsp;-64&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib/64
</pre>

<p>But please be aware of the security ramifications of this before you
do it. You are essentially telling Solaris that you trust the security
and stability of the VirtualGL code as much as you trust the security
and stability of the operating system.  And while we&rsquo;re flattered,
we&rsquo;re not sure that we&rsquo;re necessarily deserving of that
accolade, so if you are in a security critical environment, apply the
appropriate level of paranoia here.</p>

<p>An easier, and perhaps more secure, approach is to simply edit the
application script and make it store the value of the <code>LD_PRELOAD</code>
environment variables until right before the actual executable is run.
For instance, take the following application script (please):</p>

<p>Contents of <code>application.sh</code>:</p>

<pre class="verbatim">
#!/bin/sh
some_setuid_binary
some_application_binary
</pre>

<p>You would modify the script as follows:</p>

<p>Contents of <code>application.sh</code>:</p>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_32_SAVE=$LD_PRELOAD_32
LD_PRELOAD_64_SAVE=$LD_PRELOAD_64
LD_PRELOAD_32=
LD_PRELOAD_64=
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_setuid_binary

LD_PRELOAD_32=$LD_PRELOAD_32_SAVE
LD_PRELOAD_64=$LD_PRELOAD_64_SAVE
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_application_binary
</pre>

<p><code>vglrun</code> on Solaris has two options that are relevant to
launching scripts:</p>

<pre class="verbatim">
vglrun&nbsp;-32&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 32-bit executables called by a script,
whereas</p>

<pre class="verbatim">
vglrun&nbsp;-64&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 64-bit executables.  So if, for instance,
the setuid binary that the script is calling is a 32-bit executable
and the application is a 64-bit executable, then you could use <code>vglrun&nbsp;-64</code>
to launch the application script.</p>

<hr class="break" />


<h1 id="hd0013"><a name="file013"></a>13&nbsp;Using VirtualGL with Applications That Manually Load OpenGL</h1>

<p><a name="dlopen"></a></p>

<p>The lion&rsquo;s share of OpenGL applications are dynamically linked
against <code>libGL.so</code>, and thus <code>libGL.so</code> is automatically
loaded whenever the application loads.  Whenever <code>vglrun</code>
is used to launch such applications, VirtualGL is loaded ahead of <code>libGL.so</code>,
meaning that OpenGL and GLX symbols are resolved from VirtualGL first
and the &ldquo;real&rdquo; OpenGL library second.</p>

<p>However, some applications (particularly games) are not dynamically
linked against <code>libGL.so</code>.  These applications typically
call <code>dlopen()</code> and <code>dlsym()</code> later on in the
program&rsquo;s execution to manually load OpenGL and GLX symbols from
<code>libGL.so</code>.  Such applications also generally provide a
mechanism (usually either an environment variable or a command line
argument) which allows the user to specify a library that can be loaded
instead of <code>libGL.so</code>.</p>

<p>So let&rsquo;s assume that you just downloaded the latest version of
the Linux game Foo Wars from the Internet, and (for whatever reason)
you want to run the game in a VNC session.  The game provides a command
line switch <code>-g</code> which can be used to specify an OpenGL
library to load other than <code>libGL.so</code>.  You would launch
the game using a command line such as this:</p>

<pre class="verbatim">
vglrun&nbsp;foowars&nbsp;-g&nbsp;/usr/lib/librrfaker.so
</pre>

<p>You still need to use <code>vglrun</code> to launch the game, because
VirtualGL must also intercept a handful of X11 calls.  Using <code>vglrun</code>
allows VGL to intercept these calls, whereas using the game&rsquo;s
built-in mechanism for loading a substitute OpenGL library allows VirtualGL
to intercept the GLX and OpenGL calls.</p>

<p>In some cases, the application doesn&rsquo;t provide an override mechanism
such as the above.  In these cases, you should pass an argument of
<code>-dl</code> to <code>vglrun</code> when starting the application.
For example:</p>

<pre class="verbatim">
vglrun&nbsp;-dl&nbsp;foowars
</pre>

<p>Passing <code>-dl</code> to <code>vglrun</code> forces another library
to be loaded ahead of VirtualGL and <code>libGL.so</code>.  This new
library intercepts any calls to <code>dlopen()</code> and forces the
application to open VirtualGL instead of <code>libGL.so</code>.</p>

<p>Chapter <a href="#Application_Recipes" class="ref">15</a> contains
specific recipes for getting a variety of games and other applications
to work with VirtualGL.</p>

<hr class="break" />


<h1 id="hd0014"><a name="file014"></a>14&nbsp;Using VirtualGL with Chromium and ModViz VGP</h1>

<p><a name="Chromium"></a></p>

<p>Chromium is a powerful framework for performing various types of parallel
OpenGL rendering.  It is usually used on clusters of commodity Linux
PC&rsquo;s to divide up the task of rendering scenes with large geometries
or large pixel counts (such as when driving a display wall.)  Chromium
is most often used in one of three configurations:</p>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Sort-First Rendering (Image-Space Decomposition)
    </li>
    <li class="Ordered" value="2">
        Sort-First Rendering (Image-Space Decomposition) with Readback
    </li>
    <li class="Ordered" value="3">
        Sort-Last Rendering (Object-Space Decomposition)
    </li>
</ol>


<h2 id="hd0014001">14.1&nbsp;Configuration 1: Sort-First Rendering (Image-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-displaywall.png" alt="chromium-displaywall" class="figure" id="imgid_21" name="imgid_21"/>
</div>

<p>Sort-First Rendering (Image-Space Decomposition) is used to overcome
the fill-rate limitations of individual graphics cards.  When configured
to use sort-first rendering, Chromium divides up the scene based on
which polygons will be visible in a particular section of the final
image.  It then instructs each node of the cluster to render only the
polygons that are necessary to generate the image section (&ldquo;tile&rdquo;)
for that node.  This is primarily used to drive high-resolution displays
that would be impractical to drive from a single graphics card due
to limitations in the card&rsquo;s framebuffer memory, processing power,
or both.  Configuration 1 could be used, for instance, to drive a CAVE,
video wall, or even an extremely high-resolution monitor.  In this
configuration, each Chromium node generally uses all of its screen
real estate to render a section of the multi-screen image.</p>

<p>VirtualGL is generally not very useful with Configuration 1.  You could
theoretically install a separate copy of VirtualGL on each display
node and use it to redirect the output of each <code>crserver</code>
instance to a multi-screen X server running elsewhere on the network.
But there would be no way to synchronize the screens on the remote
end.  Chromium uses DMX to synchronize the screens in a multi-screen
configuration, and VirtualGL would have to be made DMX-aware for it
to perform the same job.  Maybe at some point in the future &hellip;
If you have a need for such a configuration,
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">let
us know</a></span><a name="idx0075"></a>.</p>


<h2 id="hd0014002">14.2&nbsp;Configuration 2: Sort-First Rendering (Image-Space Decomposition) with Readback</h2>

<div class="figure">
<img src="chromium-sortfirst.png" alt="chromium-sortfirst" class="figure" id="imgid_22" name="imgid_22"/>
</div>

<p>Configuration 2 uses the same sort-first principle as Configuration
1, except that each tile is only a fraction of a single screen, and
the tiles are recombined into a single window on Node 0.  This configuration
is perhaps the least often used of the three, but it is useful in cases
where the scene contains a large amount of textures (such as in volume
rendering) and thus rendering the whole scene on a single node would
be prohibitively slow due to fill-rate limitations.</p>

<p>In this configuration, the application is allowed to choose a visual,
create an X window, and manage the window as it would normally do.
But all other OpenGL and GLX activity is intercepted by the Chromium
App Faker (CrAppFaker) so that the rendering task can be split up among
the rendering nodes.  Once each node has rendered its section of the
final image, the tiles get passed back to a Chromium Server (CrServer)
process running on Node 0.  This CrServer process attaches to the previously-created
application window and draws the pixels into it using <code>glDrawPixels()</code>.</p>

<p>The general strategy for making this work with VirtualGL is to first
make it work without VirtualGL and then insert VirtualGL only into
the processes that run on Node 0.  VirtualGL must be inserted into
the CrAppFaker process to prevent CrAppFaker from sending <code>glXChooseVisual()</code>
calls to the X server (which would fail if the X server is a VNC server
or otherwise does not provide GLX.)  VirtualGL must be inserted into
the CrServer process on Node 0 to prevent it from sending <code>glDrawPixels()</code>
calls to the X server (which would effectively send uncompressed images
over the network.)  Instead, VirtualGL forces CrServer to draw into
a Pbuffer, and VGL takes charge of transmitting those pixels to the
destination X server in the most efficient way possible.</p>

<p>Since Chromium uses <code>dlopen()</code> to load the system&rsquo;s
OpenGL library, preloading VirtualGL into the CrAppFaker and CrServer
processes using <code>vglrun</code> is not sufficient.  Fortunately,
Chromium provides an environment variable, <code>CR_SYSTEM_GL_PATH</code>,
which allows one to specify an alternate path in which it will search
for the system&rsquo;s <code>libGL.so</code>.  The VirtualGL packages
for Linux and Solaris include a symbolic link named <code>libGL.so</code>
which really points to the VirtualGL faker library (<code>librrfaker.so</code>)
instead.  This symbolic link is located in its own isolated directory,
so that directory can be passed to Chromium in the <code>CR_SYSTEM_GL_PATH</code>
environment variable, thus causing Chromium to load VirtualGL rather
than the &ldquo;real&rdquo; OpenGL library. Refer to the following
table:</p>

<p><a name="CR_SYSTEM_GL_PATH_Table"></a></p>

<div class="table">
<table class="standard" align="center">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">32-bit Applications</th>
    <th class="head standard">64-bit Applications</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>/opt/VirtualGL/fakelib</code></td>
    <td class="standard"><code>/opt/VirtualGL/fakelib/64</code></td>
  </tr>
</table>
<div class="tableNote" style="text-align=center;"><code>CR_SYSTEM_GL_PATH</code> setting required to use VirtualGL with Chromium</div>
</div>


<p>Running the CrServer in VirtualGL is simply a matter of setting this
environment variable and then invoking <code>crserver</code> with <code>vglrun</code>.
For example:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
vglrun&nbsp;crserver
</pre>

<p>In the case of CrAppFaker, it is also necessary to set <code>VGL_GLLIB</code>
to the location of the &ldquo;real&rdquo; OpenGL library (example:
<code>/usr/lib/libGL.so.1</code>.) CrAppFaker creates its own fake
version of <code>libGL.so</code> which is really just a copy of Chromium&rsquo;s
<code>libcrfaker.so</code>.  So VirtualGL, if left to its own devices,
will unwittingly try to load <code>libcrfaker.so</code> instead of
the &ldquo;real&rdquo; OpenGL library.  Chromium&rsquo;s <code>libcrfaker.so</code>
will in turn try to load VirtualGL again, and an endless loop will
occur.</p>

<p>So what we want to do is something like this:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
export&nbsp;VGL_GLLIB=/usr/lib/libGL.so.1
crappfaker
</pre>

<p>CrAppFaker will copy the application to a temp directory and then copy
<code>libcrfaker.so</code> to that same directory, renaming it as <code>libGL.so</code>.
So when the application is started, it loads <code>libcrfaker.so</code>
instead of <code>libGL.so</code>. <code>libcrfaker.so</code> will then
load VirtualGL instead of the &ldquo;real&rdquo; libGL, because we&rsquo;ve
overridden <code>CR_SYSTEM_GL_PATH</code> to make Chromium find VirtualGL&rsquo;s
fake <code>libGL.so</code> first.  VirtualGL will then use the library
specified in <code>VGL_GLLIB</code> to make any &ldquo;real&rdquo;
OpenGL calls that it needs to make.</p>

<p>Note that <code>crappfaker</code> should not be invoked with <code>vglrun</code>.</p>

<p>So, putting this all together, here is an example of how you might
start a sort-first rendering job using Chromium and VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-first rendering with readback
    </li>
    <li class="Ordered">
        Start <code>crserver</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table above)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered">
        On Node 0, set <code>VGL_GLLIB</code> to the location of the &ldquo;real&rdquo;
        libGL (example: <code>/usr/lib/libGL.so.1</code> or <code>/usr/lib64/libGL.so.1</code>.)
    </li>
    <li class="Ordered">
        On Node 0, launch <code>crappfaker</code> (do not use <code>vglrun</code>
        here)
    </li>
</ol>

<p>Again, it&rsquo;s always a good idea to make sure this works without
VirtualGL before adding VirtualGL into the mix.</p>

<div class="important"><p class="important">
When using VirtualGL with this mode, resizing the application window may not work properly.  This is because the resize event is sent to the application process, and therefore the CrServer process that&rsquo;s actually drawing the pixels has no way of knowing that a window resize has occurred. A possible fix is to modify Chromium such that it propagates the resize event down the render chain so that all of the CrServer processes are aware that a resize event occurred.
</p></div>


<h2 id="hd0014003">14.3&nbsp;Configuration 3: Sort-Last Rendering (Object-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-sortlast.png" alt="chromium-sortlast" class="figure" id="imgid_23" name="imgid_23"/>
</div>

<p>Sort-Last Rendering is used when the scene contains a huge number of
polygons and the rendering bottleneck is processing all of that geometry
on a single graphics card.  In this case, each node runs a separate
copy of the application, and for best results, the application needs
to be at least partly aware that it&rsquo;s running in a parallel environment
so that it can give Chromium hints as to how to distribute the various
objects to be rendered.  Each node generates an image of a particular
portion of the object space, and these images must be composited in
such a way that the front-to-back ordering of pixels is maintained.
This is generally done by collecting Z buffer data from each node to
determine whether a particular pixel on a particular node is visible
in the final image.  The rendered images from each node are often composited
using a &ldquo;binary swap&rdquo;, whereby the nodes combine their
images in a cascading tree so that the overall compositing time is
proportional to log<sub>2</sub>(N) rather than N.</p>

<p>To make this configuration work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-last rendering
    </li>
    <li class="Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table in Section
        <a href="#CR_SYSTEM_GL_PATH_Table" class="ref">14.2</a>.)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h3 id="hd0014003001">CRUT</h3>

<p>The Chromium Utility Toolkit provides a convenient way for graphics
applications to specifically take advantage of Chromium&rsquo;s sort-last
rendering capabilities.  Such applications can use CRUT to explicitly
specify how their object space should be decomposed.  CRUT applications
require an additional piece of software, <code>crutserver</code>, to
be running on Node 0.  So to make such applications work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-last rendering
    </li>
    <li class="Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table in Section
        <a href="#CR_SYSTEM_GL_PATH_Table" class="ref">14.2</a>.)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crutserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h2 id="hd0014004">14.4&nbsp;A Note About Performance</h2>

<p>Chromium&rsquo;s use of X11 is generally not very optimal.  It assumes
a very fast connection between the X server and the Chromium Server.
In certain modes, Chromium polls the X server on every frame to determine
whether windows have been resized, etc.  Thus, we have observed that,
even on a fast network, Chromium tends to perform much better with
VirtualGL running in a TurboVNC session as opposed to VirtualGL running
in Direct Mode.</p>


<h2 id="hd0014005">14.5&nbsp;ModViz VGP and VirtualGL</h2>

<p>ModViz Virtual Graphics Platform<sup>TM</sup> is a polished commercial
clustered rendering framework for Linux which supports all three of
the rendering modes described above and provides a much more straightforward
interface to configure and run these types of parallel rendering jobs.</p>

<p>All VGP jobs, regardless of configuration, are all spawned through
<code>vglauncher</code>, a front-end program which automatically takes
care of starting the appropriate processes on the rendering nodes,
intercepting OpenGL calls from the application instance(s), sending
rendered images back to Node 0, and compositing the images as appropriate.
In a similar manner to VirtualGL&rsquo;s <code>vglrun</code>, VGP&rsquo;s
vglauncher preloads a library (<code>libVGP.so</code>) in place of
<code>libGL.so</code>, and this library intercepts the OpenGL calls
from the application.</p>

<p>So our strategy here is similar to our strategy for loading the Chromium
App Faker.  We want to insert VirtualGL between VGP and the real system
OpenGL library, so that VGP will call VirtualGL and VirtualGL will
call <code>libGL.so</code>. Achieving this with VGP is relatively simple:</p>

<pre class="verbatim">
export&nbsp;VGP_BACKING_GL_LIB=librrfaker.so
vglrun&nbsp;vglauncher&nbsp;--preload=librrfaker.so:/usr/lib/libGL.so&nbsp;{application}
</pre>

<p>Replace <code>/usr/lib/libGL.so</code> with the full path of your system&rsquo;s
OpenGL library (<code>/usr/lib64/libGL.so</code> if you are launching
a 64-bit application.)</p>

<hr class="break" />


<h1 id="hd0015"><a name="file015"></a>15&nbsp;Other Application Recipes</h1>

<p><a name="Application_Recipes"></a></p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Application</th>
    <th class="head standard">Platform</th>
    <th class="head standard">Recipe</th>
    <th class="head standard">Notes</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">ANSA v12.1.0</td>
    <td class="standard">Linux/x86</td>
    <td class="standard">Add <br /><br /> <code>LD_PRELOAD_SAVE=$LD_PRELOAD</code><br /> <code>export&nbsp;LD_PRELOAD=</code> <br /><br /> to the top of the <code>ansa.sh</code> script, then add <br /><br /> <code>export&nbsp;LD_PRELOAD=$LD_PRELOAD_SAVE</code> <br /><br /> just prior to the <code>${ANSA_EXEC_DIR}bin/ansa_linux${ext2}</code> line.</td>
    <td class="standard">The ANSA startup script directly invokes <code>/lib/libc.so.6</code> to query the glibc version.  Since the VirtualGL faker depends on libc, preloading VirtualGL when directly invoking <code>libc.so.6</code> creates an infinite loop. So it is necessary to disable the preloading of VirtualGL in the application script and then re-enable it prior to launching the actual application.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Army Ops</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;armyops</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Descent 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;descent3&nbsp;-g&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;descent3</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Doom 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;doom3&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;doom3</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Enemy Territory (Return to Castle Wolfenstein)</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;et&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;et</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heretic II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;heretic2&nbsp;+set&nbsp;gl_driver&nbsp;/usr/lib/librrfaker.so&nbsp;+set&nbsp;vid_ref&nbsp;glx</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;heretic2&nbsp;+set&nbsp;vid_ref&nbsp;glx</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heavy Gear II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;hg2&nbsp;-o&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;hg2</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">I-deas Master Series 9, 10, &amp; 11</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">When running I-deas with VirtualGL on a Solaris/Sparc server, remotely displaying to a non-Sparc client machine or to an X proxy such as VNC, it may be necessary to set the <code>SDRC_SUN_IGNORE_GAMMA</code> environment variable to <code>1</code>.</td>
    <td class="standard">I-deas normally aborts if it detects that the X visual assigned to it is not gamma-corrected.  But gamma-corrected X visuals only exist on Solaris/Sparc X servers, so if you are displaying the application to another type of X server or X proxy which doesn&rsquo;t provide gamma-corrected X visuals, then it is necessary to override the gamma detection mechanism in I-deas.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Java2D applications that use OpenGL</td>
    <td class="standard">Linux, Solaris</td>
    <td class="standard">Java2D will use OpenGL to perform its rendering if <code>sun.java2d.opengl</code> is set to <code>True</code>.  For example: <br /><br /> <code>java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /> In order for this to work in VirtualGL, it is necessary to invoke <code>vglrun</code> with the <code>-dl</code> switch.  For example: <br /><br /> <code>vglrun&nbsp;-dl&nbsp;java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /> If you are using Java v6 b92 or later, you can also set the environment variable <code>J2D_ALT_LIBGL_PATH</code> to the path of <code>librrfaker.so</code>.  For example: <br /><br /> <code>setenv&nbsp;J2D_ALT_LIBGL_PATH&nbsp;/opt/VirtualGL/lib/librrfaker.so</code><br /> <code>vglrun&nbsp;java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Java2D applications that use OpenGL</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">When VirtualGL is used in conjunction with Java v5.0 (also known as Java 1.5.0) to remotely display Java2D applications using the OpenGL pipeline (see above), certain Java2D applications will cause the OpenGL subsystem to crash with the following error: <br /><br /> <code>thread&nbsp;tries&nbsp;to&nbsp;access&nbsp;GL&nbsp;context&nbsp;current&nbsp;to&nbsp;another&nbsp;thread</code> <br /><br /> If you encounter this error, try setting the <code>SUN_OGL_IS_MT</code> environment variable to <code>1</code> and re-running the application.</td>
    <td class="standard">Java 5.0 should call <code>glXInitThreadsSUN()</code> since it is using multiple OpenGL threads, but it doesn&rsquo;t.  Purely by chance, this doesn&rsquo;t cause any problems when the application is displayed locally.  But VirtualGL changes things up enough that the luck runs out.  This issue does not exist in Java 6.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Pro/ENGINEER Wildfire v2.0</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">Add <br /><br /> <code>graphics&nbsp;opengl</code> <br /><br /> to <code>~/config.pro</code>.  You may also need to set the <code>VGL_XVENDOR</code> environment variable to <code>&quot;Sun&nbsp;Microsystems,&nbsp;Inc.&quot;</code> if you are running Pro/ENGINEER 2.0 over a remote X connection to a Linux or Windows VirtualGL client.</td>
    <td class="standard">Pro/E 2.0 for Solaris will disable OpenGL if it detects a remote connection to a non-Sun X server.</td>
  </tr>
  <tr class="standard">
    <td class="standard">QGL (OpenGL Qt Widget)</td>
    <td class="standard">Linux</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;{application}</code></td>
    <td class="standard">Qt can be built such that it either resolves symbols from libGL automatically or uses <code>dlopen()</code> to manually resolve those symbols from libGL.  As of Qt v3.3, the latter behavior is the default, so OpenGL programs built with later versions of libQt will not work with VirtualGL unless the <code>-dl</code> switch is used with <code>vglrun</code>. <br /><br /> See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Quake 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;quake3&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;quake3</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Soldier of Fortune</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;sof&nbsp;+set&nbsp;gl_driver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;sof</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Unreal Tournament 2004</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;ut2004</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">VisConcept</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">Set the environment variable <code>VGL_GUI_XTTHREADINIT</code> to <code>0</code>.</td>
    <td class="standard">Popping up the VirtualGL configuration dialog may cause the application to hang unless you set this environment variable.  See Section <a href="#VGL_GUI_XTTHREADINIT" class="ref">19.1</a> for more details.</td>
  </tr>
</table>
</div>


<hr class="break" />


<h1 id="hd0016"><a name="file016"></a>16&nbsp;Advanced OpenGL Features</h1>

<p><a name="Advanced_OpenGL"></a></p>


<h2 id="hd0016001">16.1&nbsp;Stereographic Rendering</h2>

<p>The general idea behind VirtualGL is to offload the 3D rendering work
to the server so that the client only has to draw 2D images.  Normally,
the VirtualGL and TurboVNC clients use 2D image drawing commands to
display the rendered 3D images from the VirtualGL server, thus eliminating
the need for a 3D graphics card on the client machine.  But drawing
stereo images requires a 3D graphics card, so such a card must be present
in any client machine that will use VirtualGL with stereographic rendering.
Since the 3D graphics card is only being used to draw images, it need
not necessarily be a high-end card.  Generally, the least expensive
3D graphics card that has stereo capabilities will work fine in a VirtualGL
client.</p>

<p>The server must also have a 3D graphics card that supports stereo,
since this is the only way that VirtualGL can obtain a stereo Pbuffer.
When an application requests a stereo visual, VirtualGL will return
a stereo visual to the application only if:</p>

<ul class="Itemize">
    <li class="Itemize dash">
        The client supports OpenGL (Exceed 3D is required for Windows clients.)
    </li>
    <li class="Itemize dash">
        The client has a stereo visual available.
    </li>
    <li class="Itemize dash">
        The server has a stereo visual available that supports Pbuffer rendering.
    </li>
</ul>

<p>It is usually necessary to explicitly enable stereo visuals in the
graphics card configuration for both the client and server machines.
The <a href="#Troubleshooting">Troubleshooting</a><a name="idx0076"></a>
section below lists a way to verify that both client and server have
stereo visuals available.</p>

<p>If, for any given frame, VirtualGL detects that the application has
drawn anything to the right eye buffer, VGL will read back both eye
buffers and send the contents as a pair of compressed images (one for
each eye) to the VirtualGL client.  The VGL client then decompresses
the stereo image pair and draws it as a single stereo frame to the
client&rsquo;s display using <code>glDrawPixels()</code>.  It should
thus be no surprise that stereo performs, at best, only half as fast
as mono, since VirtualGL must compress twice as much data on the server
and use twice as much network bandwidth to send the stereo images to
the client.</p>

<div class="important"><p class="important">
Stereo requires Direct Mode.  If VirtualGL is running in Raw Mode and the application renders something in stereo, only the contents of the left eye buffer will be sent to the X display.
</p></div>


<h2 id="hd0016002">16.2&nbsp;Transparent Overlays</h2>

<p>Transparent overlays have similar requirements and restrictions as
stereo.  In this case, VirtualGL completely bypasses its own GLX faker
and uses indirect OpenGL rendering to render the transparent overlay
on the client machine&rsquo;s 3D graphics card.  The underlay is still
rendered on the server, as always.  Using indirect rendering to render
the overlay is unfortunately necessary, because there is no reliable
way to draw to an overlay using 2D (X11) functions, there are severe
performance issues (on some cards) with using <code>glDrawPixels()</code>
to draw to the overlay, and there is no reasonable way to composite
the overlay and underlay on the VirtualGL server.</p>

<p>The use of overlays is becoming more and more infrequent, and when
they are used, it is generally only for drawing small, simple, static
shapes and text. We have found that it is often faster to send the
overlay geometry over to the client rather than rendering it as an
image and sending the image.  So even if it were possible to implement
overlays without using indirect rendering, it&rsquo;s likely that indirect
rendering of overlays would still be the fastest approach for most
applications.</p>

<p>As with stereo, overlays must sometimes be explicitly enabled in the
graphics card&rsquo;s configuration.  In the case of overlays, however,
they need only be supported and enabled on the client machine.</p>

<p>Indexed color (8-bit) overlays have been tested and are known to work
with VirtualGL.  True color (24-bit) overlays work in theory but have
not been tested.  Use <code>glxinfo</code> (see
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0077"></a>
below) to verify whether your client&rsquo;s X display supports overlays
and whether they are enabled.  In Exceed 3D, make sure that the &ldquo;Overlay
Support&rdquo; option is checked in the &ldquo;Exceed 3D and GLX&rdquo;
applet:</p>

<p><img src="exceed6.png" alt="exceed6" class="inline" id="imgid_9" name="imgid_9"/></p>

<div class="important"><p class="important">
Overlays do not work with X proxies (including TurboVNC.)  VirtualGL must be displaying to a real X server on the client machine (either using Direct Mode or Raw Mode.)
</p></div>


<h2 id="hd0016003">16.3&nbsp;Indexed (PseudoColor) Rendering</h2>

<p>In a PseudoColor visual, each pixel is represented by an index which
refers to a location in a color table.  The color table stores the
actual color values (256 of them in the case of 8-bit PseudoColor)
which correspond to each index. An application merely tells the X server
which color index to use when drawing, and the X server takes care
of mapping that index to an actual color from the color table.  OpenGL
allows for rendering to Pseudocolor visuals, and it does so by being
intentionally ignorant of the relationship between indices and actual
colors.  As far as OpenGL is concerned, each color index value is just
a meaningless number, and it is only when the final image is drawn
by the X server that these numbers take on meaning.  As a result, many
pieces of OpenGL&rsquo;s core functionality, such as lighting and shading,
either have undefined behavior or do not work at all with PseudoColor
rendering. PseudoColor rendering used to be a common technique to visualize
scientific data, because such data often only contained 8 bits per
sample to begin with. Applications could manipulate the color table
to allow the user to dynamically control the relationship between sample
values and colors.  As more and more graphics cards drop support for
PseudoColor rendering, however, the applications which use it are becoming
a vanishing breed.</p>

<p>VirtualGL supports PseudoColor rendering if a PseudoColor visual is
available on the client&rsquo;s display.  A PseudoColor visual need
not be present on the server.  On the server, VirtualGL uses the red
channel of a standard RGB Pbuffer to store the color index.  Upon receiving
an end of frame trigger, VirtualGL reads back the red channel of the
Pbuffer and uses <code>XPutImage()</code> to draw the color indices
into the appropriate X window.  To put this another way, PseudoColor
rendering in VirtualGL always uses Raw Mode.  However, since there
is only 1 byte per pixel in a PseudoColor &ldquo;image&rdquo;, the
images can still be sent to the client reasonably quickly even though
they are uncompressed.</p>

<p>PseudoColor rendering should work in VNC, provided that the VNC server
is configured with an 8-bit color depth.  TurboVNC does not support
PseudoColor, but RealVNC and other VNC flavors do.  Note, however,
that VNC cannot provide both PseudoColor and TrueColor visuals at the
same time.</p>


<h2 id="hd0016004">16.4&nbsp;Troubleshooting</h2>

<p><a name="Troubleshooting"></a></p>

<p>VirtualGL includes a modified version of <code>glxinfo</code> that
can be used to determine whether or not the client and server have
stereo, overlay, or Pseudocolor visuals enabled.</p>

<p>Run one of the following command sequences on the VirtualGL server
to determine whether the server has a suitable visual for stereographic
rendering:</p>

<dl class="Description">
    <dt class="Description">Solaris servers (using GLP)</dt>
    <dd class="Description">
<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-d&nbsp;{glp_device}&nbsp;-v
</pre>

    </dd>
    <dt class="Description">Linux and Solaris servers (not using GLP)</dt>
    <dd class="Description">
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c&nbsp;-v
</pre>

    </dd>
</dl>

<p>One or more of the visuals should say &ldquo;stereo=1&rdquo; and should
list &ldquo;Pbuffer&rdquo; as one of the &ldquo;Drawable Types.&rdquo;</p>

<p>Run the following command sequence on the VirtualGL server to determine
whether the X display on the client has a suitable visual for stereographic
rendering, transparent overlays, or Pseudocolor.</p>

<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/opt/VirtualGL/bin/glxinfo&nbsp;-v
</pre>

<p>In order to use stereo, one or more of the visuals should say &ldquo;stereo=1&rdquo;.
In order to use transparent overlays, one or more of the visuals should
say &ldquo;level=1&rdquo;, should list a &ldquo;Transparent Index&rdquo;
(non-transparent visuals will say &ldquo;Opaque&rdquo; instead), and
should have a class of &ldquo;PseudoColor.&rdquo;  In order to use
PseudoColor (indexed) rendering, one of the visuals should have a class
of &ldquo;PseudoColor.&rdquo;</p>

<hr class="break" />


<h1 id="hd0017"><a name="file017"></a>17&nbsp;Performance Measurement</h1>

<p><a name="Perf_Measurement"></a></p>


<h2 id="hd0017001">17.1&nbsp;VirtualGL&rsquo;s Built-In Profiling System</h2>

<p>The easiest way to uncover bottlenecks in the VirtualGL pipeline is
to set the <code>VGL_PROFILE</code> environment variable to <code>1</code>
on both server and client (passing an argument of <code>+pr</code>
to <code>vglrun</code> on the server has the same effect.)  This will
cause VirtualGL to measure and report the throughput of the various
stages in its pipeline.  For example, here are some measurements from
a dual Pentium 4 server communicating with a Pentium III client on
a 100 Megabit LAN:</p>

<dl class="Description">
    <dt class="Description">Server</dt>
    <dd class="Description">
<pre class="verbatim">
Readback&nbsp;&nbsp;&nbsp;-&nbsp;43.27&nbsp;Mpixels/sec&nbsp;-&nbsp;34.60&nbsp;fps
Compress&nbsp;0&nbsp;-&nbsp;33.56&nbsp;Mpixels/sec&nbsp;-&nbsp;26.84&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.02&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.41&nbsp;fps&nbsp;-&nbsp;10.19&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
    <dt class="Description">Client</dt>
    <dd class="Description">
<pre class="verbatim">
Decompress&nbsp;-&nbsp;10.35&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;8.28&nbsp;fps
Blit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;35.75&nbsp;Mpixels/sec&nbsp;-&nbsp;28.59&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.00&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.40&nbsp;fps&nbsp;-&nbsp;10.18&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
</dl>

<p>The total throughput of the pipeline is 8.0 Megapixels/sec, or 6.4
frames/sec, indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels
in size (a little less than 1280 x 1024 pixels.)  The readback and
compress stages, which occur in parallel on the server, are obviously
not slowing things down.  And we&rsquo;re only using 1/10 of our available
network bandwidth.  So we look to the client and discover that its
slow decompression speed (10.35 Megapixels/second) is the primary bottleneck.
Decompression and blitting on the client do not occur in parallel,
so the aggregate performance is the harmonic mean of the decompression
and blitting rates:  <em>[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec</em>.</p>


<h2 id="hd0017002">17.2&nbsp;Frame Spoiling</h2>

<p>By default, VirtualGL will only send a frame to the client if the client
is ready to receive it.  If a rendered frame arrives at the server&rsquo;s
queue and a previous frame is still being processed, the new frame
is dropped (&ldquo;spoiled.&rdquo;) This prevents a backlog of frames
on the server, which would cause a perceptible delay in the responsiveness
of interactive applications.  But when running non-interactive applications,
particularly benchmarks, it is desirable to disable frame spoiling.
With frame spoiling disabled, the server will render frames only as
quickly as VirtualGL can send those frames to the client, which will
conserve server resources as well as allow OpenGL benchmarks to accurately
measure the frame rate of the VirtualGL system.  With frame spoiling
enabled, these benchmarks will report meaningless data, since they
are measuring the rate at which the server can render frames, and that
frame rate is decoupled from the rate at which VirtualGL can send those
frames to the client.</p>

<p>In a VNC environment, there is another layer of frame spoiling, since
the server only sends updates to the client when the client requests
them.  So even if frame spoiling is disabled in VirtualGL, OpenGL benchmarks
will still report meaningless data if they are run in a VNC session.</p>

<p>There are only two ways to accurately benchmark an application in VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Disable frame spoiling and use Direct Mode or Raw Mode with a &ldquo;real&rdquo;
        X server.
    </li>
    <li class="Ordered">
        Use TCBench (see below.)
    </li>
</ol>

<p>To disable frame spoiling, set the <code>VGL_SPOIL</code> environment
variable to <code>0</code> on the server or pass an argument of <code>-sp</code>
to <code>vglrun</code>.  See Section <a href="#VGL_SPOIL" class="ref">19.1</a>
for more details.</p>


<h2 id="hd0017003">17.3&nbsp;VirtualGL Diagnostic Tools</h2>

<p>VirtualGL includes several tools which can be useful in diagnosing
performance problems with the system.</p>


<h3 id="hd0017003001">NetTest</h3>

<p>NetTest is a network benchmark that uses the same network I/O classes
as VirtualGL.  It can be used to test the latency and throughput of
any TCP/IP connection, with or without SSL encryption.  <code>nettest</code>
can be found in <code>/opt/VirtualGL/bin</code> on Linux or Solaris
or in <code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code>
on Windows.</p>

<p>To use NetTest, first start up the nettest server on one end of the
connection:</p>

<pre class="verbatim">
nettest&nbsp;-server&nbsp;[-ssl]
</pre>

<p>(use <code>-ssl</code> if you want to test the performance of SSL encryption
over this particular connection.)</p>

<p>Next, start the client on the other end of the connection:</p>

<pre class="verbatim">
nettest&nbsp;-client&nbsp;{server}&nbsp;[-ssl]
</pre>

<p>Replace <code>{server}</code> with the hostname or IP address of the
machine where the NetTest server is running.  Use <code>-ssl</code>
if the NetTest server is running in SSL mode.)</p>

<p>The nettest client will produce output similar to the following:</p>

<pre class="verbatim">
TCP&nbsp;transfer&nbsp;performance&nbsp;between&nbsp;localhost&nbsp;and&nbsp;{server}:

Transfer&nbsp;size&nbsp;&nbsp;1/2&nbsp;Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput
(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(msec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MB/sec)
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.176896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.005391
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.179391&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.010632
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.021006
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181292&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.042083
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181694&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.083981
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.181690&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.167965
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.182010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.335339
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.182197&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.669991
256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183593&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.329795
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.656586
1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.186189&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.245015
2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.379702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.143834
4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.546805&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.143778
8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.908712&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.597335
16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.643810&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.505359
32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.961701&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.551368
65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.769007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.833754
131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.313003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.049232
262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22.412990&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.154246
524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44.760510&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.170561
1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89.294810&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.198859
2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;178.426602&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.209091
4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;356.547194&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.218711
</pre>

<p>We can see that the throughput peaks at about 11.2 MB/sec.  1 MB =
1048576 bytes, so 11.2 MB/sec = 94 million bits per second, which is
pretty good for a 100 Megabit connection.  We can also see that, for
small transfer sizes, the round-trip time is dominated by latency.
The &ldquo;latency&rdquo; is the same thing as the 1/2 round-trip time
for a zero-byte packet, which is about 0.18 milliseconds in this case.</p>


<h3 id="hd0017003002">CPUstat</h3>

<p>CPUstat is available only in the VirtualGL Linux packages and is located
in the same place as NetTest (<code>/opt/VirtualGL/bin</code>.)  It
measures the average, minimum, and peak CPU usage for all processors
combined and for each processor individually.  On Windows, this same
functionality is provided in the Windows Performance Monitor, which
is part of the operating system.  On Solaris, the same data can be
obtained through <code>vmstat</code>.</p>

<p>CPUstat measures the CPU usage over a given sample period (a few seconds)
and continuously reports how much the CPU was utilized since the last
sample period.  Output for a particular sample looks something like
this:</p>

<pre class="verbatim">
ALL&nbsp;:&nbsp;&nbsp;51.0&nbsp;(Usr=&nbsp;47.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;3.5)&nbsp;/&nbsp;Min=&nbsp;47.4&nbsp;Max=&nbsp;52.8&nbsp;Avg=&nbsp;50.8
cpu0:&nbsp;&nbsp;20.5&nbsp;(Usr=&nbsp;19.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;1.0)&nbsp;/&nbsp;Min=&nbsp;19.4&nbsp;Max=&nbsp;88.6&nbsp;Avg=&nbsp;45.7
cpu1:&nbsp;&nbsp;81.5&nbsp;(Usr=&nbsp;75.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;6.0)&nbsp;/&nbsp;Min=&nbsp;16.6&nbsp;Max=&nbsp;83.5&nbsp;Avg=&nbsp;56.3
</pre>

<p>The first column indicates what percentage of time the CPU was active
since the last sample period (this is then broken down into what percentage
of time the CPU spent running user, nice, and system/kernel code.)
&ldquo;ALL&rdquo; indicates the average utilization across all CPU&rsquo;s
since the last sample period.  &ldquo;Min&rdquo;, &ldquo;Max&rdquo;,
and &ldquo;Avg&rdquo; indicate a running minimum, maximum, and average
of all samples since cpustat was started.</p>

<p>Generally, if an application&rsquo;s CPU usage is fairly steady, you
can run CPUstat for a bit and wait for the Max. and Avg. for the &ldquo;ALL&rdquo;
category to stabilize, then that will tell you what the application&rsquo;s
peak and average % CPU utilization is.</p>


<h3 id="hd0017003003">TCBench</h3>

<p>TCBench was born out of the need to compare VirtualGL&rsquo;s performance
to other thin client packages, some of which had frame spoiling features
that couldn&rsquo;t be disabled.  TCBench measures the frame rate of
a thin client system as seen from the client&rsquo;s point of view.
It does this by attaching to one of the client windows and continuously
reading back a small area at the center of the window.  While this
may seem to be a somewhat non-rigorous test, experiments have shown
that if care is taken to make sure that the application is updating
the center of the window on every frame (such as in a spin animation),
TCBench can produce quite accurate results.  It has been sanity checked
with VirtualGL&rsquo;s internal profiling mechanism and with a variety
of system-specific techniques, such as monitoring redraw events on
the client&rsquo;s windowing system.</p>

<p>TCBench can be found in <code>/opt/VirtualGL/bin</code> on Linux or
Solaris or in <code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code>
on Windows.  Run <code>tcbench</code> from the command line, and it
will prompt you to click in the window you want to measure.   That
window should already have an automated animation of some sort running
before you launch TCBench.</p>

<p>TCBench can also be used to measure the frame rate of applications
that are running on the local console, although for extremely fast
applications (those that exceed 40 fps on the local console), you may
need to increase the sampling rate of TCBench to get accurate results.
The default sampling rate of 50 samples/sec should be fine for measuring
the throughput of VirtualGL and other thin client systems.</p>

<pre class="verbatim">
tcbench&nbsp;-?
</pre>

<p>gives the relevant command line switches that can be used to adjust
the benchmark time, the sampling rate, and the x and y offset of the
sampling area within the window.</p>

<hr class="break" />


<h1 id="hd0018"><a name="file018"></a>18&nbsp;The VirtualGL Configuration Dialog</h1>

<p><a name="Config_Dialog"></a></p>

<p>Several of VirtualGL&rsquo;s configuration parameters can be changed
on the fly once an application has started.  This is accomplished by
using the VirtualGL configuration dialog, which can be activated by
holding down the <code>CTRL</code> and <code>SHIFT</code> keys and
pressing the <code>F9</code> key while any one of the application&rsquo;s
windows is active.  This displays a dialog box similar to the following:</p>

<p><img src="configdialog.gif" alt="configdialog" class="inline" id="imgid_10" name="imgid_10"/></p>

<p>You can use this dialog to enable or disable frame spoiling or to adjust
the JPEG quality and subsampling.  Changes are reflected immediately
in the application.</p>

<dl class="Description">
    <dt class="Description">Frame Spoiling</dt>
    <dd class="Description">
        Clicking on this button will toggle frame spoiling on and off.  If
        the button is highlighted (black), then frame spoiling is enabled.
    </dd>
    <dt class="Description">Qual Preset: Broadband/T1</dt>
    <dd class="Description">
        Clicking on this button will set the JPEG quality to 30 and the JPEG
        subsampling to 4:1:1, settings which will produce good performance
        on broadband connections (but at the expense of image quality.)
    </dd>
    <dt class="Description">Qual Preset: LAN</dt>
    <dd class="Description">
        Clicking on this button will set the JPEG quality to 95 and the JPEG
        subsampling to 4:4:4, settings which will produce perceptually lossless
        image quality (100 Mbit/sec switched LAN recommended.)
    </dd>
    <dt class="Description">JPEG Quality</dt>
    <dd class="Description">
        Click and drag the slider to change the JPEG quality to an arbitrary
        value between 1 and 100.
    </dd>
    <dt class="Description">JPEG Subsampling</dt>
    <dd class="Description">
        Click on any of the three buttons to change the JPEG subsampling. 
        The highlighted (black) button indicates the current value.
    </dd>
    <dt class="Description">Close Dialog</dt>
    <dd class="Description">
        Close the dialog (you can also use the close gadget on the dialog window)
    </dd>
</dl>
<div class="important"><p class="important">
The JPEG quality and subsampling gadgets will only be shown if VirtualGL is running in direct mode.  In raw mode, the only setting that can be changed with this dialog is frame spoiling.
</p></div>

<p>The <code>VGL_GUI</code> environment variable can be used to change
the key sequence used to pop up the dialog box.  If the default of
<code>CTRL-SHIFT-F9</code> is not suitable, then set <code>VGL_GUI</code>
to any combination of <code>ctrl</code>, <code>shift</code>, <code>alt</code>,
and one of <code>{f1,&nbsp;f2,...,&nbsp;f12}</code> (these are not
case sensitive.)  For example:</p>

<pre class="verbatim">
export&nbsp;VGL_GUI=CTRL-F9
</pre>

<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code> is
pressed.</p>

<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code>
to <code>none</code>.</p>

<div class="important"><p class="important">
VirtualGL monitors the application&rsquo;s X event loop to determine whenever a particular key sequence has been pressed.  If an application is not monitoring key press events in its X event loop, then the VirtualGL configuration dialog might not pop up at all.  There is unfortunately no workaround for this, but it should be a rare occurrence.
</p></div>

<hr class="break" />


<h1 id="hd0019"><a name="file019"></a>19&nbsp;Advanced Configuration</h1>

<p><a name="Advanced_Configuration"></a></p>


<h2 id="hd0019001">19.1&nbsp;Server Settings</h2>

<p>You can control the operation of the VirtualGL faker in four different
ways. Each method of configuration takes precedence over the previous
method:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Setting a configuration environment variable globally (for instance,
        in <code>/etc/profile</code>)
    </li>
    <li class="Ordered">
        Setting a configuration environment variable on a per-user basis (for
        instance, in <code>~/.bashrc</code>)
    </li>
    <li class="Ordered">
        Setting a configuration environment variable only for the current shell
        session (for instance, <code>export&nbsp;VGL_XXX={whatever}</code>)
    </li>
    <li class="Ordered">
        Passing a configuration option as an argument to <code>vglrun</code>.
        This effectively overrides any previous environment variable setting
        corresponding to that configuration option.
    </li>
</ol>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Environment Variable Name</th>
    <th class="head standard"><code>vglrun</code> Command-Line Override</th>
    <th class="head standard">Description</th>
    <th class="head standard">Default Value</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>VGL_CLIENT</code></td>
    <td class="standard"><code>-cl&nbsp;&lt;client</code><br /><code>display&gt;</code></td>
    <td class="standard"><em>The X display where VirtualGL should send its image stream</em> <br /><br /> When running in Direct Mode, VirtualGL uses a dedicated TCP/IP connection to transmit compressed images of an application&rsquo;s OpenGL rendering area from the VirtualGL server to the VirtualGL client.  Thus, the VirtualGL server needs to know on which machine the VirtualGL client software is running, and it needs to know which X display on that machine will be used to draw the application&rsquo;s GUI.  VirtualGL can normally surmise this by reading the <code>DISPLAY</code> environment variable (which lists the hostname and X display where all X11 traffic will be sent.)  But in cases where X11 traffic is tunneled through SSh or another type of indirect X11 connection, the <code>DISPLAY</code> environment variable on the VirtualGL server may not point to the client machine.  In these cases, set <code>VGL_CLIENT</code> to the display where the application&rsquo;s GUI will end up.  For example: <br /><br /> <code>export&nbsp;VGL_CLIENT=my_client:0.0</code> <br /><br /> If you are connecting to the VirtualGL server using SSh with X11 forwarding enabled, VirtualGL will try to guess an appropriate value for <code>VGL_CLIENT</code> based on the IP address of the SSh client, so you would only need to set <code>VGL_CLIENT</code> in this case if your configuration is unusual (such as if your client machine&rsquo;s X server is occupying a display number other than 0 or if you are trying to forward VirtualGL&rsquo;s image stream over SSh.  See Chapter <a href="#Direct_Mode_Usage" class="ref">9</a> for more details.) <br /><br /> <em>** This option has no effect in Raw Mode. **</em></td>
    <td class="standard">If SSh X11 forwarding is being used, VirtualGL will automatically set <code>VGL_CLIENT</code> to <code>{ssh_client}:0.0</code>, where <code>{ssh_client}</code> is the IP address of the machine from which the SSh connection was initiated. Otherwise, <code>VGL_CLIENT</code> is unset, which tells VirtualGL to read the client hostname and X display from the <code>DISPLAY</code> environment variable instead.</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_COMPRESS=0</code><br /><code>VGL_COMPRESS=1</code></td>
    <td class="standard"><code>-c&nbsp;&lt;0,&nbsp;1&gt;</code></td>
    <td class="standard"><em>0 = Raw Mode (send rendered images uncompressed via. X11),</em><br /> <em>1 = Direct Mode (compress rendered images as JPEG &amp; send on a separate socket)</em> <br /><br /> When this option is set to 0, VirtualGL will bypass its internal image compression pipeline and instead use <code>XPutImage()</code> to composite the rendered 3D images into the appropriate application window.  This mode (&ldquo;Raw Mode&rdquo;) is primarily useful in conjunction with VNC, NX, or other remote display software that performs X11 rendering on the server and uses its own mechanism for compressing and transporting images to the client.  Enabling Raw Mode on a remote X11 connection will result in uncompressed images being sent over the network, so it is unadvisable except on very fast networks (see Section <a href="#Raw_Mode_Over_Network" class="ref">11.0.2</a>.) <br /><br /> If this option is not specified, then VirtualGL&rsquo;s default behavior is to use Direct Mode when the application is being displayed to a remote X server and to use Raw Mode otherwise.  VirtualGL assumes that if the <code>DISPLAY</code> environment variable begins with a colon or with &ldquo;<code>unix:</code>&rdquo; (example: &ldquo;<code>:0.0</code>&rdquo;, &ldquo;<code>unix:1000.0</code>&rdquo;, etc.), then the X11 connection is local and thus doesn&rsquo;t require image compression.  Otherwise, it assumes that the X11 connection is remote and that compression is required.  If the display string begins with &ldquo;<code>localhost</code>&rdquo; or with the server&rsquo;s hostname, VGL assumes that the display is being tunneled through SSh, and its default behavior is to use Direct Mode in this case. <br /><br /> It is normally not necessary to set this configuration parameter unless you want to do something unusual (such as use Raw Mode over a remote X11 connection.) See Chapter <a href="#TurboVNC_Usage" class="ref">10</a> for more details. <br /><br /> <em>NOTE:  Stereo does not work with Raw Mode.</em> <br /><br /></td>
    <td class="standard">Compression enabled (&ldquo;Direct Mode&rdquo;) if the application is displaying to a remote X server, disabled (&ldquo;Raw Mode&rdquo;) otherwise.</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_DISPLAY</code></td>
    <td class="standard"><code>-d&nbsp;&lt;display&nbsp;or</code><br /><code>GLP&nbsp;device&gt;</code></td>
    <td class="standard"><em>The display or GLP device to use for 3D rendering</em> <br /><br /> If your server has multiple 3D graphics cards and you want the OpenGL rendering to be redirected to a display other than :0, set <code>VGL_DISPLAY=:1.0</code> or whatever.  This could be used, for instance, to support many application instances on a beefy multi-pipe graphics server. <br /><br /> <em>GLP mode (Solaris/Sparc only):</em> <br /><br /> Setting this option to <code>glp</code> will enable GLP mode and use the first framebuffer device listed in <code>/etc/dt/config/GraphicsDevices</code> to perform 3D rendering.  You can also set this option to the pathname of a specific GLP device (example: <code>/dev/fbs/jfb0</code>.)  See Section <a href="#GLP_Usage" class="ref">7.1</a> for more details.</td>
    <td class="standard">:0</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_FPS</code></td>
    <td class="standard"><code>-fps&nbsp;&lt;floating</code><br /><code>point&nbsp;number</code><br /><code>greater&nbsp;than&nbsp;0&gt;</code></td>
    <td class="standard"><em>Limit the client/server frame rate to the specified number of frames per second</em> <br /><br /> Setting <code>VGL_FPS</code> or passing <code>-fps</code> as an argument to <code>vglrun</code> will enable VirtualGL&rsquo;s frame rate governor.  When enabled, the frame rate governor will attempt to limit the overall throughput of the VirtualGL pipeline to the specified number of frames/second.  If frame spoiling is disabled, this effectively limits the server&rsquo;s 3D rendering frame rate as well.  This option works regardless of whether VirtualGL is being run in Direct Mode (with compression enabled) or in Raw Mode (with compression disabled.)</td>
    <td class="standard">Frame rate governor disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_GAMMA=0</code><br /><code>VGL_GAMMA=1</code><br /><code>VGL_GAMMA=&lt;gamma</code><br /> <code>correction</code><br /><code>factor</code>&gt;</td>
    <td class="standard"><code>-g</code><br />or<br /><code>+g</code><br />or<br /><code>-gamma&nbsp;&lt;gamma</code><br /><code>correction</code> <br /><code>factor&gt;</code></td>
    <td class="standard">&ldquo;Gamma&rdquo; refers to the relationship between the intensity of light which your computer&rsquo;s monitor is instructed to display and the intensity which it actually displays.  The curve is an exponential curve of the form <em>Y = X<sup>G</sup></em>, where X is between 0 and 1.  G is called the &ldquo;gamma&rdquo; of the monitor.  PC monitors and TV&rsquo;s usually have a gamma of around 2.2. <br /><br /> Some of the math involved in 3D rendering assumes a linear gamma (G = 1.0), so technically speaking, 3D applications will not display with mathematical correctness unless the pixels are &ldquo;gamma corrected&rdquo; to counterbalance the non-linear response curve of the monitor.  But some systems do not have any form of built-in gamma correction, and thus the applications developed for such systems have usually been designed to display properly without gamma correction.  Gamma correction involves passing pixels through a function of the form <em>X = W<sup>1/G</sup></em>, where G is the &ldquo;gamma correction factor&rdquo; and should be equal to the gamma of the monitor.  So the final output is <em>Y = X<sup>G</sup> = (W<sup>1/G</sup>)<sup>G</sup> = W</em>, which describes a linear relationship between the intensity of the pixels drawn by the application and the intensity of the pixels displayed by the monitor. <br /><br /> <em><code>VGL_GAMMA=1</code> or <code>vglrun&nbsp;+g</code> : Enable gamma correction with default settings</em> <br /><br /> This option tells VirtualGL to enable gamma correction using the best available method.  If VirtualGL is remotely displaying to a Solaris/Sparc X server which has gamma-corrected X visuals, then VGL will attempt to assign one of these visuals to the application.  This causes the 3D output of the application to be gamma corrected by the factor specified in <code>fbconfig</code> on the client machine (default: 2.22.)  Otherwise, if the X server does not have gamma-corrected X visuals or if the gamma-corrected visuals it has do not match the application&rsquo;s needs, then VirtualGL performs gamma correction internally and uses a default gamma correction factor of 2.22.  This option emulates the default behavior of OpenGL applications running locally on Sparc machines. <br /><br /> <em><code>VGL_GAMMA=0</code> or <code>vglrun&nbsp;-g</code> : Disable gamma correction</em> <br /><br /> This option tells VGL not to use gamma-corrected visuals, even if they are available on the X server, and disables VGL&rsquo;s internal gamma correction system as well.  This emulates the default behavior of OpenGL applications running locally on Linux or Solaris/x86 machines. <br /><br /> <em><code>VGL_GAMMA={gamma&nbsp;correction&nbsp;factor}</code> or <code>vglrun&nbsp;-gamma&nbsp;{gamma&nbsp;correction&nbsp;factor}</code> : Enable VGL&rsquo;s internal gamma correction system with the specified gamma correction factor</em> <br /><br /> If <code>VGL_GAMMA</code> is set to an arbitrary floating point value, then VirtualGL performs gamma correction internally using the specified value as the gamma correction factor.  You can also specify a negative value to apply a &ldquo;de-gamma&rdquo; function.  Specifying a gamma correction factor of G (where G &lt; 0) is equivalent to specifying a gamma correction factor of -1/G.</td>
    <td class="standard"><code>VGL_GAMMA=1</code> on Solaris/Sparc VGL servers, <code>VGL_GAMMA=0</code> otherwise</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_GLLIB</code></td>
    <td class="standard"></td>
    <td class="standard"><em> The location of an alternate OpenGL library</em> <br /><br /> Normally, VirtualGL loads the first OpenGL dynamic library that it finds in the dynamic linker path (usually <code>/usr/lib/libGL.so.1</code>, <code>/usr/lib64/libGL.so.1</code>,  or <code>/usr/lib/64/libGL.so.1</code>.)  You can use this setting to explicitly specify another OpenGL dynamic library to load. <br /><br /> Normally, you shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t work.  However, this setting is necessary when using VirtualGL with <a href="#Chromium">Chromium</a><a name="idx0078"></a>.</td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_GUI</code></td>
    <td class="standard"></td>
    <td class="standard"><em>Key sequence used to invoke the configuration dialog</em> <br /><br /> VirtualGL will normally monitor an application&rsquo;s X event queue and pop up the VirtualGL configuration dialog whenever <code>CTRL-SHIFT-F9</code> is pressed. In the event that this interferes with a key sequence that the application is already using, you can redefine the key sequence used to pop up VGL&rsquo;s configuration dialog by setting <code>VGL_GUI</code> to some combination of <code>shift</code>, <code>ctrl</code>, <code>alt</code>, and one of <code>{f1,&nbsp;f2,&nbsp;...,&nbsp;f12}</code>.  You can also set <code>VGL_GUI</code> to <code>none</code> to disable the configuration dialog altogether.  See Chapter <a href="#Config_Dialog" class="ref">18</a> for more details.</td>
    <td class="standard">shift-ctrl-f9</td>
  </tr>
  <tr class="standard">
    <td class="standard"><a name="VGL_GUI_XTTHREADINIT"></a> <code>VGL_GUI_XTTHREADINIT</code></td>
    <td class="standard"></td>
    <td class="standard"><em>0 to prevent VGL from calling <code>XtToolkitThreadInitialize()</code></em> <br /><br /> Xt &amp; Motif applications are supposed to call <code>XtToolkitThreadInitialize()</code> if they plan to access Xt functions from two or more threads simultaneously.  But rarely, a multi-threaded Xt/Motif application may avoid calling <code>XtToolkitThreadInitialize()</code> and rely on the fact that avoiding this call disables application and process locks.  This behavior is generally considered errant on the part of the application, but the application developers have probably figured out other ways around the potential instability that this situation creates. <br /><br /> The problem arises whenever VirtualGL pops up its configuration dialog (which is written using Xt.)  In order to create this dialog, VirtualGL creates a new Xt thread and calls <code>XtToolkitThreadInitialize()</code> as it is supposed to do to guarantee thread safety.  But if the application into which VGL is loaded exhibits the errant behavior described above, suddenly enabling application and process locks may cause the application to deadlock.  Setting <code>VGL_GUI_XTTHREADINIT</code> to <code>0</code> will remove VGL&rsquo;s call to <code>XtToolkitThreadInitialize()</code> and should thus eliminate the deadlock.<br /><br /> In short, if you try to pop up the VirtualGL config dialog and notice that it hangs the application, try setting <code>VGL_GUI_XTTHREADINIT</code> to <code>0</code>.</td>
    <td class="standard">1</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_NPROCS&nbsp;</code></td>
    <td class="standard"><code>-np&nbsp;&lt;#&nbsp;of&nbsp;CPUs&gt;</code><br />or<br /><code>-np&nbsp;0</code><br /> (automatically determine the optimal number of CPUs to use)</td>
    <td class="standard"><em>Specify the number of CPUs to use for multi-threaded compression</em> <br /><br /> VirtualGL can divide the task of compressing each frame among multiple server CPUs.  This might speed up the overall throughput if the compression stage of the pipeline is the primary bottleneck.  The default behavior (equivalent to setting <code>VGL_NPROCS=0</code>) is to use all but one of the available CPUs, up to a maximum of 3 total.  On a large multiprocessor system, the speedup is almost linear up to 3 processors, but the algorithm scales very little past that point.  VirtualGL will not allow more than 4 processors total to be used for compression, nor will it allow you to assign more processors than are available in the system. <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">1P system: 1<br /> 2P system: 1<br /> 3P system: 2<br /> 4P &amp; larger: 3</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_PORT</code></td>
    <td class="standard"><code>-p&nbsp;&lt;port&gt;</code></td>
    <td class="standard"><em>The TCP port to use when connecting to the client</em> <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">4242 for unencrypted connections, 4243 for SSL connections</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_PROFILE=0</code><br /><code>VGL_PROFILE=1</code></td>
    <td class="standard"><code>-pr</code><br />or<br /><code>+pr</code></td>
    <td class="standard"><em>Enable/disable profiling output</em> <br /><br /> If enabled, this will cause the VirtualGL faker to continuously benchmark itself and periodically print out the throughput of reading back, compressing, and sending pixels to the client. <br /><br /> See Chapter <a href="#Perf_Measurement" class="ref">17</a> for more details.</td>
    <td class="standard">Profiling disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_QUAL</code></td>
    <td class="standard"><code>-q&nbsp;&lt;1-100&gt;</code></td>
    <td class="standard"><em>An integer between 1 and 100 (inclusive)</em> <br /><br /> This setting allows you to specify the quality of the JPEG compression. Lower is faster but also grainier.  The default setting should produce perceptually lossless image quality. <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">95</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_READBACK=0</code><br /><code>VGL_READBACK=1</code></td>
    <td class="standard"></td>
    <td class="standard"><em>Enable/disable readback</em> <br /><br /> On rare occasions, it might be desirable to have VirtualGL redirect OpenGL rendering from an application into a Pbuffer but not automatically read back and send the rendered pixels.  Some applications have their own mechanisms for reading back the buffer, so disabling VirtualGL&rsquo;s readback mechanism prevents duplication of effort. <br /><br /> This feature was developed initially to support running <span class="remote"><a href="http://www.paraview.org/" class="remote">ParaView</a></span><a name="idx0079"></a> in parallel using MPI.  ParaView MPI normally uses MPI processes 1 through N as rendering servers, each drawing a portion of the geometry into a separate window on a separate X display.  ParaView reads back these server windows and composites the pixels into the main application window, which is controlled by MPI process 0.  By creating a script which passes a different value of <code>VGL_DISPLAY</code> and <code>VGL_READBACK</code> to each MPI process, it is possible to make all of the ParaView server processes render to off-screen buffers on different graphics cards while preventing VirtualGL from displaying any pixels except those generated by process 0.</td>
    <td class="standard">Readback enabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><a name="VGL_SPOIL"></a><code>VGL_SPOIL=0</code><br /><code>VGL_SPOIL=1</code></td>
    <td class="standard"><code>-sp</code><br />or<br /><code>+sp</code></td>
    <td class="standard"><em>Enable/disable frame spoiling</em> <br /><br /> By default, VirtualGL will drop frames so as not to slow down the rendering rate of the server&rsquo;s graphics engine.  This should produce the best results with interactive applications, but it may be desirable to turn off frame spoiling when running benchmarks or other non-interactive applications.  Turning off frame spoiling will force one frame to be read back and sent on each end-of-frame event, so that the frame rate reported by OpenGL benchmarks will accurately reflect the frame rate seen by the user.  Disabling frame spoiling also prevents non-interactive applications from wasting graphics resources by rendering frames that will never be seen.  With frame spoiling turned off, the 3D rendering pipeline behaves as if it is fill-rate limited to about 30 or 40 Megapixels/second, the maximum throughput of the VirtualGL system on current CPU&rsquo;s.</td>
    <td class="standard">Spoiling enabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_SSL=0</code><br /><code>VGL_SSL=1</code></td>
    <td class="standard"><code>-s</code><br />or<br /><code>+s</code></td>
    <td class="standard"><em>Tunnel the VirtualGL compressed image stream inside a secure socket layer</em> <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">SSL disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_SUBSAMP</code></td>
    <td class="standard"><code>-samp&nbsp;&lt;411|422|444&gt;</code></td>
    <td class="standard"><em>411, 422, or 444</em> <br /><br /> This allows you to manually specify the level of chrominance subsampling in the JPEG compressor. <br /><br /> By default, VirtualGL uses no chrominance subsampling (AKA &ldquo;4:4:4 subsampling&rdquo;) when it compresses images for delivery to the client. Subsampling is premised on the fact that the human eye is more sensitive to changes in brightness than to changes in color.  Since the JPEG image format uses a colorspace in which brightness (luminance) and color (chrominance) are separated into different channels, one can sample the brightness for every pixel and the color for every other pixel and produce an image which has 16 million colors but uses an average of only 16 bits per pixel instead of 24.  This is called &ldquo;4:2:2 subsampling&rdquo;, since for every 4 pixels of luminance, there are only 2 pixels of each chrominance component.  Likewise, one can sample every fourth chrominance component to produce a 16-million color image with only 12 bits per pixel.  The latter is called &ldquo;4:1:1 subsampling.&rdquo;  Subsampling decreases the amount of image data and thus increases the performance and decreases the network bandwidth usage, but subsampling can produce some visible artifacts.  Subsampling artifacts are rarely observed with volume data, since it usually only contains 256 colors to begin with.  But narrow, aliased lines and other sharp features on a black background will tend to produce artifacts when subsampling is enabled. <br /><br /> The Axis Indicator from a Popular Visualization App displayed with 4:4:4, 4:2:2, and 4:1:1 subsampling (respectively):<br /> <img src="444.gif" alt="444" class="inline" id="imgid_11" name="imgid_11"/><img src="422.gif" alt="422" class="inline" id="imgid_12" name="imgid_12"/><img src="411.gif" alt="411" class="inline" id="imgid_13" name="imgid_13"/> <br /><br /> <em>NOTE:  If you select 4:1:1 subsampling, VirtualGL will in fact try to use 4:2:0 instead.  4:2:0 samples every other pixel both horizontally and vertically rather than sampling every fourth pixel horizontally.  But not all JPEG codecs support 4:2:0, so 4:1:1 is used when 4:2:0 is not available.</em> <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">444</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_SYNC=0</code><br /><code>VGL_SYNC=1</code></td>
    <td class="standard"><code>-sync</code><br />or<br /><code>+sync</code></td>
    <td class="standard"><em>Enable/disable strict 2D/3D synchronization (necessary to pass GLX conformance tests)</em> <br /><br /> Normally, VirtualGL&rsquo;s operation is asynchronous from the point of view of the application.  The application swaps the buffers or calls <code>glFinish()</code> or <code>glFlush()</code> or <code>glXWaitGL()</code>, and VirtualGL reads back the framebuffer and sends the pixels to the client&rsquo;s display &hellip; eventually.  This will work fine for the vast majority of applications, but it is not strictly conformant.  Technically speaking, when an application calls <code>glXWaitGL()</code> or <code>glFinish()</code>, it is well within its rights to expect the OpenGL-rendered pixels to be immediately available in the X window.  Fortunately, very few applications actually do expect this, but on rare occasions, an application may try to use <code>XGetImage()</code> or other X11 functions to obtain a bitmap of the pixels that were rendered by OpenGL.  Enabling <code>VGL_SYNC</code> is a somewhat extreme measure that may be needed to get such applications to work properly.  It was developed primarily as a way to pass the GLX conformance suite (<code>conformx</code>, specifically.)  When <code>VGL_SYNC</code> is enabled, every call to <code>glFinish()</code> or <code>glXWaitGL()</code> will cause the contents of the server&rsquo;s framebuffer to be read back and <em>synchronously</em> drawn into the client&rsquo;s window <em>without compression or frame spoiling</em>. The call to <code>glFinish()</code> or <code>glXWaitGL()</code> will not return until VirtualGL has verified that the pixels have been delivered into the client&rsquo;s window.  As such, enabling this mode can have potentially dire effects on performance.</td>
    <td class="standard">Synchronization disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_TILESIZE</code></td>
    <td class="standard"></td>
    <td class="standard"><em>A number between 8 and 1024 (inclusive)</em> <br /><br /> Normally, in Direct Mode, VirtualGL will divide an OpenGL window into tiles of 256x256 pixels, compare each tile vs. the previous frame, and only compress &amp; send the tiles which have changed.  It will also divide up the task of compressing these tiles among the available CPUs in a round robin fashion, if multi-threaded compression is enabled.  There are several tradeoffs that must be considered when choosing a tile size: <br /><br /> Smaller tile sizes: <ul class="Itemize"><li>
    Better parallel scalability
</li>
<li>
    Worse compression efficiency
</li>
<li>
    Better inter-frame optimization
</li>
<li>
    Worse network efficiency
</li></ul> Larger tile sizes: <ul class="Itemize"><li>
    Worse parallel scalability
</li>
<li>
    Better compression efficiency
</li>
<li>
    Worse inter-frame optimization
</li>
<li>
    Better network efficiency
</li></ul> <br /> Smaller tiles can more easily be divided up among multiple CPUs, but they compress less efficiently (and less quickly) on an individual basis.  Using larger tiles can reduce traffic to the client by allowing the server to send only one frame update instead of many.  But on the flip side, using larger tiles decreases the chance that a tile will be unchanged from the previous frame.  Thus, the server may only send one or two packets per frame, but the cumulative size of those packets may be much larger than if a smaller tile size was used. <br /><br /> 256x256 was chosen as the default because, in experiments, it provided the best balance between scalability and efficiency on the platforms that VirtualGL supports. <br /><br /> <em>** This option has no effect in &ldquo;Raw&rdquo; Mode. **</em></td>
    <td class="standard">256</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_TRACE=0</code><br /><code>VGL_TRACE=1</code></td>
    <td class="standard"><code>-tr</code><br />or<br /><code>+tr</code></td>
    <td class="standard"><em>Enable/disable tracing</em> <br /><br /> When tracing is enabled, VirtualGL will log all calls to the GLX and X11 functions it is intercepting, as well as the arguments, return values, and execution times for those functions.  This is useful when diagnosing interaction problems between VirtualGL and a particular OpenGL application.</td>
    <td class="standard">Tracing disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_VERBOSE=0</code><br /><code>VGL_VERBOSE=1</code></td>
    <td class="standard"><code>-v</code><br />or<br /><code>+v</code></td>
    <td class="standard"><em>Enable/disable verbosity</em> <br /><br /> When in verbose mode, VirtualGL will reveal some of the decisions it makes behind the scenes, such as which code path it is using to compress JPEG images, which type of X11 drawing it is using, etc.  This can be helpful when diagnosing performance problems.</td>
    <td class="standard">Verbosity disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_X11LIB</code></td>
    <td class="standard"></td>
    <td class="standard"><em>the location of an alternate X11 library</em> <br /><br /> Normally, VirtualGL loads the first X11 dynamic library that it finds in the dynamic linker path (usually <code>/usr/lib/libX11.so.?</code>, <code>/usr/lib/64/libX11.so.?</code>, <code>/usr/X11R6/lib/libX11.so.?</code>, or <code>/usr/X11R6/lib64/libX11.so.?</code>.)  You can use this setting to explicitly specify another X11 dynamic library to load. <br /><br /> Normally, you shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t work.</td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_XVENDOR</code></td>
    <td class="standard"></td>
    <td class="standard"><em>Return a fake X11 vendor string when the application calls <code>XServerVendor()</code></em> <br /><br /> Some applications expect <code>XServerVendor()</code> to return a particular value, which the application (sometimes erroneously) uses to figure out whether it&rsquo;s running locally or remotely.  This setting allows you to fool such applications into thinking they&rsquo;re running on a &ldquo;local&rdquo; X server rather than a remote connection.</td>
    <td class="standard"></td>
  </tr>
</table>
</div>



<h2 id="hd0019002">19.2&nbsp;Client Settings</h2>


<h3 id="hd0019002001">Environment Variables</h3>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Environment Variable Name</th>
    <th class="head standard">Description</th>
    <th class="head standard">Default Value</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>VGL_PROFILE=0</code><br /><code>VGL_PROFILE=1</code></td>
    <td class="standard"><em>Enable/disable profiling output</em> <br /><br /> If enabled, this will cause the VirtualGL client to continuously benchmark itself and periodically print out the throughput of decompressing and drawing pixels into the application window. <br /><br /> See Chapter <a href="#Perf_Measurement" class="ref">17</a> for more details.</td>
    <td class="standard">Profiling disabled</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>VGL_VERBOSE=0</code><br /><code>VGL_VERBOSE=1</code></td>
    <td class="standard"><em>Enable/disable verbosity</em> <br /><br /> When in verbose mode, VirtualGL will reveal some of the decisions it makes behind the scenes, such as which code path it is using to decompress JPEG images, which type of X11 drawing it is using, etc. This can be helpful when diagnosing performance problems.</td>
    <td class="standard">Verbosity disabled</td>
  </tr>
</table>
</div>



<h3 id="hd0019002002"><code>vglclient</code> Command-Line Arguments</h3>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"><code>vglclient</code> Argument</th>
    <th class="head standard">Description</th>
    <th class="head standard">Default</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>-port&nbsp;&lt;port</code><br /><code>number&gt;</code></td>
    <td class="standard">Causes the client to listen for unencrypted connections on the specified TCP port</td>
    <td class="standard">4242</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-sslport&nbsp;&lt;port</code><br /><code>number&gt;</code></td>
    <td class="standard">Causes the client to listen for SSL connections on the specified TCP port</td>
    <td class="standard">4243</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-sslonly</code></td>
    <td class="standard">Causes the client to reject all unencrypted connections</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-nossl</code></td>
    <td class="standard">Causes the client to reject all SSL connections</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-l&nbsp;&lt;log&nbsp;file&gt;</code></td>
    <td class="standard">Redirect all output from the client to the specified file</td>
    <td class="standard">Output goes to stderr</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-x</code></td>
    <td class="standard">Use X11 functions to draw pixels into the application window</td>
    <td class="standard">Use OpenGL on Solaris/Sparc or if stereo is enabled; use X11 otherwise</td>
  </tr>
  <tr class="standard">
    <td class="standard"><code>-gl</code></td>
    <td class="standard">Use OpenGL functions to draw pixels into the application window</td>
    <td class="standard">Use OpenGL on Solaris/Sparc or if stereo is enabled; use X11 otherwise</td>
  </tr>
</table>
</div>


<hr class="break" />

</body>
</html>

