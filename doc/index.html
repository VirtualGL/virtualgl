<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="language" content="en">
<meta name="date" content="2009-09-13T21:16:10">
<meta name="generator" content="deplate.rb 0.8.4">
<title>User&rsquo;s Guide for VirtualGL 2.1.4</title>
<link rel="start" href="index.html" title="Frontpage">
<link rel="chapter" href="index.html#hd001" title="1 Legal Information">
<link rel="chapter" href="index.html#hd002" title="2 Overview">
<link rel="chapter" href="index.html#hd003" title="3 System Requirements">
<link rel="chapter" href="index.html#hd004" title="4 Obtaining and Installing VirtualGL">
<link rel="chapter" href="index.html#hd005" title="5 Configuring a Linux or Solaris Machine as a VirtualGL Server">
<link rel="chapter" href="index.html#hd006" title="6 Configuring a Windows Machine as a Client for the VGL Image Transport">
<link rel="chapter" href="index.html#hd007" title="7 Using VirtualGL with the VGL Image Transport">
<link rel="chapter" href="index.html#hd008" title="8 Using VirtualGL with X Proxies Such as VNC">
<link rel="chapter" href="index.html#hd009" title="9 Using VirtualGL in a Sun Ray Environment">
<link rel="chapter" href="index.html#hd0010" title="10 Using VirtualGL with setuid/setgid Executables">
<link rel="chapter" href="index.html#hd0011" title="11 Using VirtualGL with Chromium and ModViz VGP">
<link rel="chapter" href="index.html#hd0012" title="12 Using VirtualGL with VirtualBox">
<link rel="chapter" href="index.html#hd0013" title="13 Other Application Recipes">
<link rel="chapter" href="index.html#hd0014" title="14 Advanced OpenGL Features">
<link rel="chapter" href="index.html#hd0015" title="15 Performance Measurement">
<link rel="chapter" href="index.html#hd0016" title="16 The VirtualGL Configuration Dialog">
<link rel="chapter" href="index.html#hd0017" title="17 Advanced Configuration">
<link rel="stylesheet" type="text/css" href="virtualgl.css" title="virtualgl">
</head>
<body >
<a name="#pagetop"></a>
<div class="title">
<p class="title">User&rsquo;s Guide for VirtualGL 2.1.4</p>
</div>
<a name="file000"></a>
<p><em>Intended audience:</em> System Administrators, Graphics Programmers, 
Researchers, and others with knowledge of the Linux or Solaris operating 
systems, OpenGL and GLX, and X windows.</p>

<div id="Table_of_Contents">
<div id="Table_of_ContentsBlock" class="toc">
<h1 class="toc">Table of Contents</h1>
<ul class="toc">
    <li class="Itemize-1 toc">
        <a href="#hd001" class="toc">1 Legal Information</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd002" class="toc">2 Overview</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd003" class="toc">3 System Requirements</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd003001" class="toc">3.1 Linux/x86</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003002" class="toc">3.2 Linux/Itanium</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003003" class="toc">3.3 Solaris/x86</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003004" class="toc">3.4 Solaris/SPARC</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003005" class="toc">3.5 Mac/x86</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003006" class="toc">3.6 Windows</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003007" class="toc">3.7 Additional Requirements for 
                Stereographic Rendering</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd003008" class="toc">3.8 Additional Requirements for 
                Transparent Overlays</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd004" class="toc">4 Obtaining and Installing VirtualGL</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd004001" class="toc">4.1 Installing VirtualGL on Linux</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd004002" class="toc">4.2 Installing VirtualGL on Solaris</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd004003" class="toc">4.3 Installing VirtualGL on Mac (Client 
                Only)</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd004004" class="toc">4.4 Installing VirtualGL on Windows 
                (Client Only)</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd004005" class="toc">4.5 Installing VirtualGL from Source</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd004006" class="toc">4.6 Obtaining and Installing the Sun Ray 
                Plugin</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd004007" class="toc">4.7 Uninstalling VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd005" class="toc">5 Configuring a Linux or Solaris Machine as 
        a VirtualGL Server</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd005001" class="toc">5.1 GLP: Using VirtualGL Without a 3D X 
                Server</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd005002" class="toc">5.2 Granting Access to the 3D X 
                Server</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd005003" class="toc">5.3 SSh Server Configuration</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd005004" class="toc">5.4 Un-Configuring the Server</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd006" class="toc">6 Configuring a Windows Machine as a Client 
        for the VGL Image Transport</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd006001" class="toc">6.1 Optimizing Exceed</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd007" class="toc">7 Using VirtualGL with the VGL Image 
        Transport</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd007001" class="toc">7.1 VGL Image Transport with X11 
                Forwarding</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd007002" class="toc">7.2 VGL Image Transport with a Direct 
                X11 Connection</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd007003" class="toc">7.3 VGL Image Transport with SSL 
                Encryption</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd007004" class="toc">7.4 VGL Image Transport with X11 
                Forwarding and SSh Tunneling</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd007005" class="toc">7.5 VGL Image Transport over Gigabit 
                Networks</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd007006" class="toc">7.6 VGL Image Transport with XDMCP</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd007007" class="toc">7.7 The VirtualGL Client Application: 
                Nuts and Bolts</a>
                <ul class="toc">
                    <li class="Itemize-5 toc">
                        <a href="#hd007007001" class="toc">7.7.1 The VirtualGL Client and 
                        Firewalls</a>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd008" class="toc">8 Using VirtualGL with X Proxies Such as 
        VNC</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd008001" class="toc">8.1 Using VirtualGL with an X Proxy on 
                the Same Server</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd008002" class="toc">8.2 Using VirtualGL with an X Proxy on a 
                Different Machine</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd009" class="toc">9 Using VirtualGL in a Sun Ray 
        Environment</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0010" class="toc">10 Using VirtualGL with setuid/setgid 
        Executables</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0011" class="toc">11 Using VirtualGL with Chromium and 
        ModViz VGP</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd0011001" class="toc">11.1 Configuration 1: Sort-First 
                Rendering (Image-Space Decomposition)</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0011002" class="toc">11.2 Configuration 2: Sort-First 
                Rendering (Image-Space Decomposition) with Readback</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0011003" class="toc">11.3 Configuration 3: Sort-Last 
                Rendering (Object-Space Decomposition)</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0011004" class="toc">11.4 A Note About Performance</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0011005" class="toc">11.5 ModViz VGP v1.x and VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0012" class="toc">12 Using VirtualGL with VirtualBox</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0013" class="toc">13 Other Application Recipes</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0014" class="toc">14 Advanced OpenGL Features</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd0014001" class="toc">14.1 Stereographic Rendering</a>
                <ul class="toc">
                    <li class="Itemize-5 toc">
                        <a href="#hd0014001001" class="toc">14.1.1 Quad-Buffered Stereo</a>
                    </li>
                    <li class="Itemize-5 toc">
                        <a href="#hd0014001002" class="toc">14.1.2 Anaglyphic Stereo</a>
                    </li>
                    <li class="Itemize-5 toc">
                        <a href="#hd0014001003" class="toc">14.1.3 Selecting a Stereo Mode</a>
                    </li>
                </ul>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0014002" class="toc">14.2 Transparent Overlays</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0014003" class="toc">14.3 Indexed (PseudoColor) Rendering</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0014004" class="toc">14.4 Troubleshooting</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0015" class="toc">15 Performance Measurement</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd0015001" class="toc">15.1 VirtualGL&rsquo;s Built-In 
                Profiling System</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0015002" class="toc">15.2 Frame Spoiling</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0015003" class="toc">15.3 VirtualGL Diagnostic Tools</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0016" class="toc">16 The VirtualGL Configuration Dialog</a>
    </li>
    <li class="Itemize-1 toc">
        <a href="#hd0017" class="toc">17 Advanced Configuration</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a href="#hd0017001" class="toc">17.1 Server Settings</a>
            </li>
            <li class="Itemize-3 toc">
                <a href="#hd0017002" class="toc">17.2 Client Settings</a>
            </li>
        </ul>
    </li>
</ul>
</div></div>
<p><br /></p>

<hr class="break" />


<h1 id="hd001"><a name="file001"></a>1&nbsp;Legal Information</h1>

<p><img src="somerights20.png" alt="somerights20" class="inline" id="imgid_0" name="imgid_0"/></p>

<p>This document and all associated illustrations are licensed under the 
<span class="remote"><a href="http://creativecommons.org/licenses/by/2.5/" class="remote">Creative 
Commons Attribution 2.5 License</a></span><a name="idx001"></a>.  Any 
works which contain material derived from this document must cite The 
VirtualGL Project as the source of the material and list the current URL 
for the VirtualGL web site.</p>

<p>This product includes software developed by the 
<span class="remote"><a href="http://www.openssl.org" class="remote">OpenSSL 
Project</a></span><a name="idx002"></a> for use in the OpenSSL Toolkit. 
Further information is contained in 
<a href="LICENSE-OpenSSL.txt"><code>LICENSE-OpenSSL.txt</code></a><a name="idx003"></a>, 
which can be found in the same directory as this documentation.</p>

<p>The VirtualGL server components include software developed by the 
<span class="remote"><a href="http://www.fltk.org/" class="remote">FLTK 
Project</a></span><a name="idx004"></a> and distributed under the terms 
of the <a href="LICENSE-FLTK.txt">FLTK License</a><a name="idx005"></a>.</p>

<p>The VirtualGL Windows packages include 
<span class="remote"><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" class="remote">PuTTY</a></span><a name="idx006"></a>, 
which is released under <a href="LICENSE-PuTTY.txt">this 
license</a><a name="idx007"></a>.</p>

<p>VirtualGL includes portions of 
<span class="remote"><a href="http://www.x.org" class="remote">X.org</a></span><a name="idx008"></a>, 
which is released under <a href="LICENSE-xauth.txt">this 
license</a><a name="idx009"></a>.</p>

<p>VirtualGL is licensed under the <a href="LICENSE.txt">wxWindows Library 
License, v3.1</a><a name="idx0010"></a>, a derivative of the 
<a href="LGPL.txt">GNU Lesser General Public License 
(LGPL)</a><a name="idx0011"></a>.</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd002"><a name="file002"></a>2&nbsp;Overview</h1>

<p><a name="Overview"></a></p>

<p>VirtualGL is an open source package which gives any Unix or Linux remote 
display software the ability to run OpenGL applications with full 3D 
hardware acceleration.  Some remote display software, such as VNC, lacks 
the ability to run OpenGL applications at all.  Other remote display 
software forces OpenGL applications to use a slow software-only OpenGL 
renderer, to the detriment of performance as well as compatibility.  The 
traditional method of displaying OpenGL applications to a remote X 
server (indirect rendering) supports 3D hardware acceleration, but this 
approach causes all of the OpenGL commands and 3D data to be sent over 
the network to be rendered on the client machine.  This is not a tenable 
proposition unless the data is relatively small and static, unless the 
network is very fast, and unless the OpenGL application is specifically 
tuned for a remote X-Windows environment.</p>

<p>With VirtualGL, the OpenGL commands and 3D data are instead redirected 
to a 3D graphics accelerator on the application server, and only the 
rendered 3D images are sent to the client machine.  VirtualGL thus 
&ldquo;virtualizes&rdquo; 3D graphics hardware, allowing it to be 
co-located in the &ldquo;cold room&rdquo; with compute and storage 
resources.  VirtualGL also allows 3D graphics hardware to be shared 
among multiple users, and it provides &ldquo;workstation-like&rdquo; 
levels of performance on even the most modest of networks.  This makes 
it possible for large, noisy, hot 3D workstations to be replaced with 
laptops or even thinner clients.  More importantly, however, VirtualGL 
eliminates the workstation and the network as barriers to data size.  
Users can now visualize gigabytes and gigabytes of data in real time 
without needing to copy any of the data over the network or sit in front 
of the machine that is rendering the data.</p>

<p>Normally, a Unix OpenGL application would send all of its drawing 
commands and data, both 2D and 3D, to an X-Windows server, which may be 
located across the network from the application server.  VirtualGL, 
however, employs a technique called &ldquo;split rendering&rdquo; to 
force the 3D commands from the application to go to a 3D graphics card 
in the application server.  VGL accomplishes this by pre-loading a 
dynamic shared object (DSO) into the application at run time.  This DSO 
intercepts a handful of GLX, OpenGL, and X11 commands necessary to 
perform split rendering.  Whenever a window is created by the 
application, VirtualGL creates a corresponding 3D pixel buffer 
(&ldquo;Pbuffer&rdquo;) on a 3D graphics card in the application server.  
Whenever the application requests that an OpenGL rendering context be 
created for the window, VirtualGL intercepts the request and creates the 
context on the corresponding Pbuffer instead.  Whenever the  application 
swaps or flushes the drawing buffer to indicate that it has finished 
rendering a frame, VirtualGL reads back the Pbuffer and sends the 
rendered 3D image to the client.</p>

<p>The beauty of this approach is its non-intrusiveness.  VirtualGL 
monitors a few X11 commands and events to determine when windows have 
been resized, etc., but it does not interfere in any way with the 
delivery of 2D X11 commands to the X server.  For the most part, VGL 
does not interfere with the delivery of OpenGL commands to the graphics 
card, either (there are some exceptions, such as its handling of color 
index rendering.)  VGL merely forces the OpenGL commands to be delivered 
to a server-side graphics card rather than a client-side graphics card.  
Once the OpenGL rendering context has been established in a server-side 
Pbuffer, everything (including esoteric OpenGL extensions, 
fragment/vertex programs, etc.) should &ldquo;just work.&rdquo;  In most 
cases, if an application runs locally on a 3D server/workstation, that 
same application will run remotely from that same machine using 
VirtualGL.  However, if it were really as simple as that, we could all 
turn out the lights and go home.  Most of the time spent developing 
VirtualGL has been spent working around &ldquo;stupid application 
tricks.&rdquo;</p>

<p>VirtualGL can currently use one of three &ldquo;image transports&rdquo; 
to send rendered 3D images to the client machine:</p>

<p><a name="VGL_Image_Transport"></a></p>

<dl class="Description">
    <dt class="Description-1 Description">1. VGL Image Transport (Formerly &ldquo;Direct Mode&rdquo;)</dt>
    <dd class="Description-1 Description">
        The VGL Image Transport is most often used whenever the 2D X server (the 
        X server used to draw the application&rsquo;s GUI and transmit keyboard 
        and mouse events back to the application server) is located across the 
        network from the application server, for instance if the 2D X server is 
        running on the user&rsquo;s desktop machine.  VirtualGL uses its own 
        protocol on a dedicated TCP socket to send the rendered 3D images to the 
        client machine, and the VirtualGL Client application decodes the images 
        and composites them into the appropriate X window.  The VGL Transport 
        can either deliver uncompressed images (RGB encoded), or it can compress 
        images in real time using a high-speed JPEG codec.  It also supports the 
        delivery of stereo image pairs, which can be reconstructed into a stereo 
        image by the VirtualGL Client.
    </dd>
</dl>

<a name="fig002001"></a>
<div class="figure">
<p class="caption">Figure 2.1: The VGL Image Transport with a Remote 2D X Server</p>
<img src="vgltransport.png" alt="vgltransport" class="figure" id="imgid_9" name="imgid_9"/>
</div>

<p><a name="X11_Image_Transport"></a></p>

<dl class="Description">
    <dt class="Description-1 Description">2. X11 Image Transport (Formerly &ldquo;Raw Mode&rdquo;)</dt>
    <dd class="Description-1 Description">
        The X11 Image Transport simply draws the rendered 3D images into the 
        appropriate X window using XPutImage() and similar X-Windows commands.  
        This is most useful in conjunction with an &ldquo;X Proxy&rdquo;, which 
        can be one of any number of Unix remote display applications, such as 
        VNC.  These X proxies are essentially &ldquo;virtual&rdquo; X servers.  
        They appear to the application as a normal X server, but they perform 
        X11 rendering to a virtual framebuffer in main memory	rather than to a 
        real framebuffer on a graphics card.  This allows the X proxy to send 
        only images to the client machine rather than chatty X-Windows rendering 
        commands.  When using the X11 Transport, VirtualGL does not perform any 
        image compression or encoding itself.  It instead relies upon an X proxy 
        to encode and deliver the images to the client(s).  Since the use of an 
        X proxy eliminates the need to send X-Windows commands over the network, 
        this is the best means of using VirtualGL over high-latency or 
        low-bandwidth networks. The VirtualGL Project provides an accelerated 
        version of VNC, called &ldquo;TurboVNC&rdquo;, which is meant to be used 
        with VirtualGL&rsquo;s X11 Transport.  The combination of the two 
        provides a highly-performant remote 3D	solution, even on slow networks.  
        TurboVNC also provides rudimentary collaboration capabilities, allowing 
        multiple users to simultaneously interact with the same 3D application.
    </dd>
</dl>

<a name="fig002002"></a>
<div class="figure">
<p class="caption">Figure 2.2: The X11 Image Transport with an X Proxy</p>
<img src="x11transport.png" alt="x11transport" class="figure" id="imgid_10" name="imgid_10"/>
</div>

<dl class="Description">
    <dt class="Description-1 Description">3. Sun Ray Image Transport</dt>
    <dd class="Description-1 Description">
        The Sun Ray thin client environment from Sun Microsystems consists of an 
        X proxy (the Sun Ray Server Software) and a series of ultra-thin 
        hardware clients that connect to this proxy over a network.  It is 
        similar in concept to VNC, in that a virtual X server is created for 
        every user and that only images, not rendering commands, are sent to the 
        client.  Unlike VNC, however, the client is not a piece of software 
        running on a workstation or laptop.  The client is a fanless, diskless 
        little box with only a monitor port, USB ports, a network jack, and a 
        smart card slot (used for authentication.)<br /> <br /> This environment 
        presents unique challenges to VirtualGL.  The first challenge is that 
        the Sun Ray 1 and Sun Ray 2 series clients contain relatively slow CPUs, 
        so they are not fast enough to decompress JPEG in real time.  The second 
        challenge is that Sun Ray servers are generally provisioned to handle a 
        lot of simultaneous users, so using VirtualGL&rsquo;s X11 Transport 
        would put undue stress on both the Sun Ray servers and the network on 
        which they reside.  Thus, Sun Microsystems designed a plugin for 
        VirtualGL which allows VGL to compress images using a protocol that can 
        be sent directly to the Sun Ray hardware client without having to pass 
        through the Sun Ray server first. Since the plugin uses the proprietary 
        Sun Ray image compression technology, it is closed source, but the 
        binary packages can be downloaded for free as part of the Sun Shared 
        Visualization product.  Sun Shared Visualization was discontinued in 
        early 2009, but as of this writing, it is still available in the 
        <span class="remote"><a href="https://cds.sun.com/is-bin/INTERSHOP.enfinity/WFS/CDS-CDS_SMI-Site/en_US/-/USD/ViewProductDetail-Start?ProductRef=SharedViz-1.1.1-SP-F@CDS-CDS_SMI" class="remote">Sun 
        Download Center</a></span><a name="idx0012"></a>.
    </dd>
</dl>

<a name="fig002003"></a>
<div class="figure">
<p class="caption">Figure 2.3: The Sun Ray Image Transport</p>
<img src="sunray.png" alt="sunray" class="figure" id="imgid_11" name="imgid_11"/>
</div>

<p><br /></p>

<hr class="break" />


<h1 id="hd003"><a name="file003"></a>3&nbsp;System Requirements</h1>


<h2 id="hd003001">3.1&nbsp;Linux/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (x86)</th>
    <th class="head standard">Server (x86-64)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4, 1.7 GHz or faster (or equivalent) <ul class="Itemize"><li class="Itemize-0">
    For optimal performance, the processor should support SSE2 extensions.
</li>
<li class="Itemize-0">
    Dual processors or dual cores recommended
</li></ul></td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li class="Itemize-0">
    For optimal performance with 64-bit VirtualGL, the processor should 
    support SSE3 extensions.  AMD 64-bit processors manufactured prior to 
    2005 do not support SSE3.
</li>
<li class="Itemize-0">
    Dual processors or dual cores recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard" colspan="2">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li class="Itemize-0">
    Install the vendor drivers for the server&rsquo;s 3D graphics card. Do 
    not use the drivers that ship with Linux, as these do not provide 3D 
    acceleration or Pbuffer support.
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance <ul class="Itemize"><li class="Itemize-0">
    If using a 3D graphics card, install the vendor drivers for that 3D 
    graphics card.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Recommended O/S</td>
    <td class="standard" colspan="3"><ul class="Itemize"><li class="Itemize-0">
    Any distribution in the 
    <span class="remote"><a href="http://www.redhat.com/" class="remote">RedHat</a></span><a name="idx0013"></a> 
    or 
    <span class="remote"><a href="http://www.novell.com/linux/" class="remote">SuSE</a></span><a name="idx0014"></a> 
    families which contains GLIBC 2.3.2 or later (including 
    <span class="remote"><a href="http://fedora.redhat.com/" class="remote">Fedora</a></span><a name="idx0015"></a>, 
    <span class="remote"><a href="http://www.centos.org/" class="remote">CentOS</a></span><a name="idx0016"></a> 
    3 and later, and 
    <span class="remote"><a href="http://www.whiteboxlinux.org/" class="remote">White 
    Box</a></span><a name="idx0017"></a>)
</li>
<li class="Itemize-0">
    Ubuntu Linux v6.0 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard" colspan="3">X server configured to export True Color (24-bit or 32-bit) visuals</td>
  </tr>
</table>
</div>



<h2 id="hd003002">3.2&nbsp;Linux/Itanium</h2>

<p>VirtualGL should build and run on Itanium Linux, but it has not been 
thoroughly tested.  
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">Contact 
us</a></span><a name="idx0018"></a> if you encounter any difficulties.  
A pre-built TurboJPEG binary package is not available for Linux/Itanium, 
so it will be necessary to build TurboJPEG from source using the Intel 
Integrated Performance Primitives for Itanium processors.</p>


<h2 id="hd003003">3.3&nbsp;Solaris/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li class="Itemize-0">
    Dual processors or dual cores recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">nVidia 3D graphics card</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard" colspan="3"><ul class="Itemize"><li class="Itemize-0">
    Solaris 10 (or newer)
</li>
<li class="Itemize-0">
    OpenSolaris 2008.11 (or newer)
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun 
    mediaLib</a></span><a name="idx0019"></a> (v2.5 or higher recommended *)
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Solaris 
    Patch</a></span><a name="idx0020"></a> 118345-04 (or later)
</li>
<li class="Itemize-0">
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun 
    mediaLib</a></span><a name="idx0021"></a> (v2.5 or higher recommended *)
</li>
<li class="Itemize-0">
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
  </tr>
</table>
</div>


<div class="important"><p class="important">
* mediaLib 2.5 is included in Solaris 10 update 4 and newer.  If you are running an older version of Solaris, it is recommended that you download and install the mediaLib 2.5 upgrade from the link above.  mediaLib 2.5 improves the performance of VirtualGL significantly on Solaris/x86 systems, when compared to mediaLib 2.4.
</p></div>


<h2 id="hd003004">3.4&nbsp;Solaris/SPARC</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">UltraSPARC III 900 MHz or faster <ul class="Itemize"><li class="Itemize-0">
    Dual processors or dual cores recommended
</li></ul></td>
    <td class="standard">UltraSPARC III 900 MHz or faster</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li class="Itemize-0">
    Tested with 
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr600/" class="remote">XVR-600</a></span><a name="idx0022"></a>, 
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr1200/" class="remote">XVR-1200</a></span><a name="idx0023"></a> 
    (&ldquo;jfb&rdquo;), and 
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0024"></a> 
    (&ldquo;kfb&rdquo;)
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard" colspan="2"><ul class="Itemize"><li class="Itemize-0">
    Solaris 8 (or newer)
</li>
<li class="Itemize-0">
    OpenSolaris 2008.11 (or newer)
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun 
    mediaLib</a></span><a name="idx0025"></a> (pre-installed on Solaris 10 
    and higher)
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun 
    OpenGL</a></span><a name="idx0026"></a> 1.3 or later (1.5 or later 
    required for <a href="#GLP_Usage">GLP</a><a name="idx0027"></a>)
</li>
<li class="Itemize-0">
    If your system does not ship with SSh pre-installed (older Solaris 8 and 
    9 systems don&rsquo;t), then download and install an OpenSSH package 
    from 
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0028"></a> 
    or 
    <span class="remote"><a href="http://www.sunfreeware.com/." class="remote">http://www.sunfreeware.com/.</a></span>
</li>
<li class="Itemize-0">
    X server configured to export True Color (24-bit or 32-bit) visuals (if 
    not using <a href="#GLP_Usage">GLP</a><a name="idx0029"></a>)
</li></ul> Recommended <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patches</a></span><a name="idx0030"></a> <ul class="Itemize"><li class="Itemize-0">
    <em>OpenGL 1.5</em>: 120812-15 (or later)
</li>
<li class="Itemize-0">
    <em>XVR-2500 driver</em>: 120928-25 (or later)
</li>
<li class="Itemize-0">
    <em>OpenGL 1.3, 32-bit:</em> 113886-41 (or later)
</li>
<li class="Itemize-0">
    <em>OpenGL 1.3, 64-bit:</em> 113887-41 (or later)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun 
    mediaLib</a></span><a name="idx0031"></a> (pre-installed on Solaris 10 
    and higher)
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun 
    OpenGL</a></span><a name="idx0032"></a> 1.3 or later recommended if the 
    client has a 3D graphics card installed.  If available, the VirtualGL 
    Client will use OpenGL to draw images, which improves the client&rsquo;s 
    performance on Sun 3D graphics cards.
</li>
<li class="Itemize-0">
    If your system does not ship with SSh pre-installed (older Solaris 8 and 
    9 systems don&rsquo;t), then download and install an OpenSSH package 
    from 
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0033"></a> 
    or 
    <span class="remote"><a href="http://www.sunfreeware.com/." class="remote">http://www.sunfreeware.com/.</a></span>
</li>
<li class="Itemize-0">
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003005">3.5&nbsp;Mac/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Any Intel-based Mac</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">OS X 10.4 (&ldquo;Tiger&rdquo;) or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <em>VGL Image Transport Only</em>: Mac X11 application (in the 
    &ldquo;Optional Installs&rdquo; package on the OS X install discs)
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003006">3.6&nbsp;Windows</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Windows 2000 or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <em>VGL Image Transport Only</em>: 
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0034"></a> 
    Exceed 8 or newer required
</li>
<li class="Itemize-0">
    Client display must have a 24-bit or 32-bit color depth (True Color.)
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003007">3.7&nbsp;Additional Requirements for Stereographic Rendering</h2>

<div class="important"><p class="important">
The client requirements do not apply to anaglyphic stereo.  See Chapter <a href="#Advanced_OpenGL" class="ref">14</a> for more details.
</p></div>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard" colspan="2" rowspan="2">3D graphics card that supports stereo (example: nVidia Quadro, ATI FirePro) and is configured to export stereo visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Mac/x86</td>
    <td class="standard">N/A</td>
    <td class="standard">3D graphics card that supports stereo (example: nVidia Quadro) and is configured to export stereo visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/SPARC</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0035"></a> 
    graphics card
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun 
    OpenGL</a></span><a name="idx0036"></a> 1.5 or later
</li>
<li class="Itemize-0">
    OpenGL 
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patch</a></span><a name="idx0037"></a> 
    120812-14 (or later)
</li>
<li class="Itemize-0">
    XVR-2500 driver 
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patch</a></span><a name="idx0038"></a> 
    120928-10 (or later)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    3D graphics card that supports stereo (examples: XVR-1200, XVR-2500) and 
    is configured to export stereo visuals
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun 
    OpenGL</a></span><a name="idx0039"></a> 1.3 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard">N/A</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    3D graphics card that supports stereo (examples: nVidia Quadro, 3D Labs 
    Wildcat Realizm, ATI FirePro) and is configured to export stereo pixel 
    formats
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0040"></a> 
    Exceed 3D v8 or newer
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003008">3.8&nbsp;Additional Requirements for Transparent Overlays</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard" rowspan="3">3D graphics card that supports transparent overlays (example: nVidia Quadro, ATI FirePro) and is configured to export overlay visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Mac/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/SPARC</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    3D graphics card that supports transparent overlays (examples: XVR-1200, 
    XVR-2500) and is configured to export overlay visuals
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun 
    OpenGL</a></span><a name="idx0041"></a> 1.3 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    3D graphics card that supports transparent overlays (examples: nVidia 
    Quadro, 3D Labs Wildcat Realizm, ATI FirePro) and is configured to 
    export overlay pixel formats
</li>
<li class="Itemize-0">
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0042"></a> 
    Exceed 3D v8 or newer
</li></ul></td>
  </tr>
</table>
</div>


<p><br /></p>

<hr class="break" />


<h1 id="hd004"><a name="file004"></a>4&nbsp;Obtaining and Installing VirtualGL</h1>

<div class="important"><p class="important">
VirtualGL must be installed on any machine that will act as a VirtualGL server or as a client for the <a href="#VGL_Image_Transport">VGL Image Transport</a><a name="idx0043"></a>. It is not necessary to install VirtualGL on the client machine if using VNC or another type of X proxy.
</p></div>


<h2 id="hd004001">4.1&nbsp;Installing VirtualGL on Linux</h2>


<h3 id="hd004001001">Installing TurboJPEG</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered" value="1">
        Download the appropriate TurboJPEG binary package (v1.11 or later) for 
        your system from the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl/files/TurboJPEG/" class="remote">Files 
        area</a></span><a name="idx0044"></a> of the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL 
        SourceForge web-site</a></span><a name="idx0045"></a>. <br />
        <div class="important"><p class="important">
        The &ldquo;i386&rdquo; RPM and DEB packages are for 32-bit-only systems.  The &ldquo;x86_64&rdquo; RPM and &ldquo;amd64&rdquo; DEB packages are for 64-bit systems.  The 64-bit packages contain both 32-bit and 64-bit libraries.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the binary 
        package, and issue one of the following commands:
        <dl class="Description">
            <dt class="Description-3 Description">RPM-based systems</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbojpeg*.rpm
</pre>

            </dd>
            <dt class="Description-3 Description">Debian-based systems</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
dpkg&nbsp;-i&nbsp;turbojpeg*.deb
</pre>

            </dd>
        </dl>
    </li>
</ol>


<h3 id="hd004001002">Installing VirtualGL</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered" value="1">
        Download the appropriate VirtualGL binary package for your system from 
        the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/" class="remote">Files 
        area</a></span><a name="idx0046"></a> of the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL 
        SourceForge web-site</a></span><a name="idx0047"></a>. <br />
        <div class="important"><p class="important">
        The &ldquo;i386&rdquo; RPM and DEB packages are for 32-bit-only systems.  The &ldquo;x86_64&rdquo; RPM and &ldquo;amd64&rdquo; DEB packages are for 64-bit systems.  The 64-bit packages contain both 32-bit and 64-bit VirtualGL components.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the binary 
        package, and issue the following commands:
        <dl class="Description">
            <dt class="Description-3 Description">RPM-based systems</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
rpm&nbsp;-i&nbsp;VirtualGL*.rpm
</pre>

            </dd>
            <dt class="Description-3 Description">Debian-based systems</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
dpkg&nbsp;-r&nbsp;VirtualGL
dpkg&nbsp;-i&nbsp;VirtualGL*.deb
</pre>

            </dd>
        </dl>
    </li>
</ol>


<h2 id="hd004002">4.2&nbsp;Installing VirtualGL on Solaris</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered" value="1">
        Download the VirtualGL Solaris package 
        (<code>SUNWvgl-</code><em><code>{version}</code></em><code>.pkg.bz2</code> 
        for SPARC or 
        <code>SUNWvgl-</code><em><code>{version}</code></em><code>-x86.pkg.bz2</code> 
        for x86) from the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/" class="remote">Files 
        area</a></span><a name="idx0048"></a> of the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL 
        SourceForge web-site</a></span><a name="idx0049"></a>. <br />
        <div class="important"><p class="important">
        Both packages provide both 32-bit and 64-bit VirtualGL components.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the package, 
        and issue the following commands:
<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

        (answer &ldquo;Y&rdquo; when prompted.)
<pre class="verbatim">
bzip2&nbsp;-d&nbsp;SUNWvgl-{version}.pkg.bz2
pkgadd&nbsp;-d&nbsp;SUNWvgl-{version}.pkg
</pre>

        Select the <code>SUNWvgl</code> package (usually option 1) from the menu.
    </li>
</ol>
<div class="important"><p class="important">
VirtualGL for Solaris installs into <code>/opt/SUNWvgl</code>.
</p></div>


<h2 id="hd004003">4.3&nbsp;Installing VirtualGL on Mac (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Download the VirtualGL Mac disk image 
        (<code>VirtualGL-</code><em><code>{version}</code></em><code>.dmg</code>) 
        from the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/" class="remote">Files 
        area</a></span><a name="idx0050"></a> of the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL 
        SourceForge web-site</a></span><a name="idx0051"></a>.
    </li>
    <li class="Ordered-1 Ordered">
        Open the disk image, then open 
        <code>VirtualGL-</code><em><code>{version}</code></em><code>.pkg</code> 
        inside the disk image.  Follow the instructions to install the Mac 
        client.  The Mac package installs files in the same locations as the 
        Linux packages.
    </li>
</ol>


<h2 id="hd004004">4.4&nbsp;Installing VirtualGL on Windows (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Download the VirtualGL Windows installer package 
        (<code>VirtualGL-</code><em><code>{version}</code></em><code>.exe</code>) 
        from the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/" class="remote">Files 
        area</a></span><a name="idx0052"></a> of the 
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL 
        SourceForge web-site</a></span><a name="idx0053"></a>.
    </li>
    <li class="Ordered-1 Ordered">
        Run the VirtualGL installer.  The installation of VirtualGL should be 
        self-explanatory.  The only configuration option is the directory into 
        which you want the files to be installed.
    </li>
</ol>
<div class="important"><p class="important">
NOTE: The VirtualGL Windows installer does not remove any previous versions of VirtualGL that may be installed on your machine.  If you wish, you can remove these older versions manually by using the &ldquo;Add or Remove Programs&rdquo; applet in the Control Panel (or the &ldquo;Programs and Features&rdquo; applet if you are running Vista.)
</p></div>


<h2 id="hd004005">4.5&nbsp;Installing VirtualGL from Source</h2>

<p>If you are using a platform for which there is not a pre-built VirtualGL 
binary package available, then log in as root, download the VirtualGL 
source tarball 
(<code>VirtualGL-</code><em><code>{version}</code></em><code>.tar.gz</code>) 
from the 
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/" class="remote">Files 
area</a></span><a name="idx0054"></a> of the 
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL 
SourceForge web-site</a></span><a name="idx0055"></a>, uncompress it, 
<code>cd&nbsp;vgl</code>, and read the contents of 
<code>BUILDING.txt</code> for further instructions on how to build and 
install VirtualGL from source.</p>


<h2 id="hd004006">4.6&nbsp;Obtaining and Installing the Sun Ray Plugin</h2>

<p>The VirtualGL Sun Ray plugin is a proprietary add-on developed by Sun 
Microsystems to integrate VirtualGL with the Sun Ray thin client 
environment. This plugin was part of the Sun Shared Visualization 
product, which is now EOL. However, the packages 
(<code>VirtualGL-SunRay.i386.rpm</code> and 
<code>VirtualGL-SunRay.x86_64.rpm</code> for Linux systems, and 
<code>SUNWvglsr</code> for Solaris systems) can be obtained from the Sun 
Shared Visualization 1.1.1 distribution, which, as of this writing, is 
still available for download from the 
<span class="remote"><a href="https://cds.sun.com/is-bin/INTERSHOP.enfinity/WFS/CDS-CDS_SMI-Site/en_US/-/USD/ViewProductDetail-Start?ProductRef=SharedViz-1.1.1-SP-F@CDS-CDS_SMI" class="remote">Sun 
Download Center</a></span><a name="idx0056"></a>.</p>


<h2 id="hd004007">4.7&nbsp;Uninstalling VirtualGL</h2>


<h3 id="hd004007001">Linux</h3>

<p>As root, issue one of the following commands:</p>

<dl class="Description">
    <dt class="Description-1 Description">RPM-based systems</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
</pre>

    </dd>
    <dt class="Description-1 Description">Debian-based systems</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
dpkg&nbsp;-r&nbsp;VirtualGL
</pre>

    </dd>
</dl>


<h3 id="hd004007002">Solaris</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

<p>Answer &ldquo;yes&rdquo; when prompted.</p>


<h3 id="hd004007003">Mac</h3>

<p>Use the &ldquo;Uninstall VirtualGL&rdquo; application provided in the 
VirtualGL disk image, or issue the following command from the Terminal:</p>

<pre class="verbatim">
sudo&nbsp;/opt/VirtualGL/bin/uninstall
</pre>


<h3 id="hd004007004">Windows</h3>

<p>Use the &ldquo;Add or Remove Programs&rdquo; applet in the Control Panel 
(or the &ldquo;Programs and Features&rdquo; applet if you&rsquo;re 
running Vista.)</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd005"><a name="file005"></a>5&nbsp;Configuring a Linux or Solaris Machine as a VirtualGL Server</h1>


<h2 id="hd005001">5.1&nbsp;GLP: Using VirtualGL Without a 3D X Server</h2>

<p><a name="GLP_Usage"></a></p>

<p>Sun&rsquo;s OpenGL library for Solaris/SPARC systems has a special 
extension called &ldquo;GLP&rdquo; which allows VirtualGL to directly 
access a 3D graphics card even if there is no X server running on the 
card.  GLP greatly improves the overall security of the VirtualGL 
server, since it eliminates the need to grant VirtualGL users access to 
the 3D X server running on that machine.  In addition, GLP makes it easy 
to assign VirtualGL jobs to any graphics card in a multi-card system.</p>

<p>When using GLP, the architecture of VirtualGL changes as follows:</p>

<a name="fig005001"></a>
<div class="figure">
<p class="caption">Figure 5.1: The VGL Image Transport with a Remote 2D X Server and GLP</p>
<img src="vgltransportglp.png" alt="vgltransportglp" class="figure" id="imgid_12" name="imgid_12"/>
</div>

<a name="fig005002"></a>
<div class="figure">
<p class="caption">Figure 5.2: The X11 Image Transport with an X Proxy and GLP</p>
<img src="x11transportglp.png" alt="x11transportglp" class="figure" id="imgid_13" name="imgid_13"/>
</div>

<a name="fig005003"></a>
<div class="figure">
<p class="caption">Figure 5.3: The Sun Ray Image Transport with GLP</p>
<img src="sunrayglp.png" alt="sunrayglp" class="figure" id="imgid_14" name="imgid_14"/>
</div>

<p>If the application server is running 
<span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun 
OpenGL</a></span><a name="idx0057"></a> 1.5 for Solaris/SPARC, then it 
is recommended that you configure it to use GLP:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Log in as root.
    </li>
    <li class="Ordered-1 Ordered">
        Run
<pre class="verbatim">
/opt/VirtualGL/bin/vglserver_config
</pre>

    </li>
    <li class="Ordered-1 Ordered">
        Select option 3 
        (<code>Configure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLP&nbsp;mode</code>.)
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Restrict&nbsp;framebuffer&nbsp;device&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Only users in the <code>vglusers</code> group can run OpenGL 
                applications on the VirtualGL server (the configuration script will 
                create the <code>vglusers</code> group if it doesn&rsquo;t already 
                exist.)  This limits the possibility that an unauthorized user could 
                snoop the 3D framebuffer device(s) and thus see (or alter) the output of 
                a 3D application that is being used with VirtualGL.
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                Any authenticated user can run OpenGL applications on the VirtualGL 
                server.  If it is necessary for users outside of the 
                <code>vglusers</code> group to log in locally to this server and run 
                OpenGL applications, then this option must be selected.
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">
        If you chose to restrict framebuffer device access to the 
        <code>vglusers</code> group, then edit <code>/etc/group</code> and add 
        <code>root</code> to the <code>vglusers</code> group.  If you choose, 
        you can also add additional users to the group at this time.  Note that 
        any user you add to <code>vglusers</code>	must log out and back in again 
        before their new group permissions will take effect.
    </li>
    <li class="Ordered-1 Ordered">
        Edit the <code>/etc/dt/config/GraphicsDevices</code> file as necessary.  
        This file contains a list of paths to 3D framebuffer devices (such as 
        <code>/dev/fbs/kfb0</code>, <code>/dev/fbs/jfb0</code>, etc.) that you 
        wish to use with VirtualGL.
    </li>
</ol>


<h3 id="hd005001001">Sanity Check</h3>

<p>To verify that the application server is ready to run VirtualGL, log out 
of the server, log back into the server using SSh, and execute the 
following command in the SSh session:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-d&nbsp;glp
</pre>

<p>This command should output a list of visuals and should complete with no 
errors.</p>


<h3 id="hd005001002">Using GLP by Default in VirtualGL</h3>

<p>If you wish VirtualGL to use GLP by default, then you can add</p>

<pre class="verbatim">
VGL_DISPLAY=glp
export&nbsp;VGL_DISPLAY
</pre>

<p>to <code>/etc/profile</code> on the application server.  This will cause 
VirtualGL to use the first device specified in 
<code>/etc/dt/config/GraphicsDevices</code> as the default rendering 
device.  Users can override this default by setting 
<code>VGL_DISPLAY</code> in one of their startup scripts (such as 
<code>~/.profile</code> or <code>~/.login</code>) or by passing an 
argument of <code>-d&nbsp;&lt;device&gt;</code> to <code>vglrun</code> 
when invoking VirtualGL.  See Chapter 
<a href="#Advanced_Configuration" class="ref">17</a> for more details.</p>


<h2 id="hd005002">5.2&nbsp;Granting Access to the 3D X Server</h2>

<div class="important"><p class="important">
If you plan to use VirtualGL only with <a href="#GLP_Usage">GLP</a><a name="idx0058"></a>, then you can skip this section.
</p></div>

<p>VirtualGL requires access to the application server&rsquo;s 3D graphics 
card so that it can create off-screen pixel buffers (Pbuffers) and 
redirect the 3D rendering from applications into these Pbuffers.  
Unfortunately, accessing a 3D graphics card on Linux and Solaris/x86 
systems or on Solaris/SPARC systems without 
<a href="#GLP_Usage">GLP</a><a name="idx0059"></a> requires going 
through an X server.  On such systems, the only way to share the 
application server&rsquo;s 3D graphics card among multiple users is to 
grant those users access to the 3D X server (the X server attached to 
the application server&rsquo;s 3D graphics card.  Refer to the figures 
in Chapter <a href="#Overview" class="ref">2</a>.)</p>

<p>It is important to understand the security risks associated with this.  
Once a user has access to the 3D X server, there is nothing that would 
prevent the user from logging keystrokes or reading back images from 
that X server. Using <code>xauth</code>, one can obtain 
&ldquo;untrusted&rdquo; X authentication keys which prevent such 
exploits, but unfortunately, those untrusted keys also disallow access 
to the 3D hardware.  Thus, it is necessary to grant full trusted access 
to the 3D X server for any users that will need to run VirtualGL.  
Unless you fully trust the users to whom you are granting this access, 
then you should avoid logging in locally to the 3D X server 
(particularly as root) unless absolutely necessary.</p>

<p>This section will explain how to configure a VirtualGL server such that 
selected users can run VirtualGL, even if the server is sitting at the 
login prompt.</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Shut down the display manager:
        <dl class="Description">
            <dt class="Description-3 Description">Ubuntu Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/gdm&nbsp;stop
</pre>

            </dd>
            <dt class="Description-3 Description">Other Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
init&nbsp;3
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 10 servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm2-login
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 11/OpenSolaris servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris servers running dtlogin</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;stop
</pre>

            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">
        Log in as root from the text console (or remotely using SSh.)
    </li>
    <li class="Ordered-1 Ordered">
        Run
<pre class="verbatim">
/opt/VirtualGL/bin/vglserver_config
</pre>

    </li>
    <li class="Ordered-1 Ordered">
        Select option 1 
        (<code>Configure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>.)
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Restrict&nbsp;local&nbsp;X&nbsp;server&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Only users in the <code>vglusers</code> group can use VirtualGL (the 
                configuration script will create the <code>vglusers</code> group if it 
                doesn&rsquo;t already exist.)  This is the most secure option, since it 
                prevents any users outside of the <code>vglusers</code> group from 
                accessing (and thus exploiting) the 3D X server.
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                VirtualGL can be used by any user that successfully logs into the 
                VirtualGL server.  The 3D X server can also be accessed (and potentially 
                exploited) by any user who is logged into the VirtualGL server.  If you 
                choose this option, it is recommended that you also disable the XTEST 
                extension (see below.)
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Restrict&nbsp;framebuffer&nbsp;device&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Only users in the <code>vglusers</code> group can run OpenGL 
                applications on the VirtualGL server (the configuration script will 
                create the <code>vglusers</code> group if it doesn&rsquo;t already 
                exist.)  This limits the possibility that an unauthorized user could 
                snoop the 3D framebuffer device(s) and thus see (or alter) the output of 
                a 3D application that is being used with VirtualGL.
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                Any authenticated user can run OpenGL applications on the VirtualGL 
                server.  If it is necessary for users outside of the 
                <code>vglusers</code> group to log in locally to this server and run 
                OpenGL applications, then this option must be selected.
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Disable&nbsp;XTEST&nbsp;extension&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Disabling XTEST will not prevent a user from logging keystrokes or 
                reading images from the 3D X server, but if a user has access to the 3D 
                X server, disabling XTEST will prevent them from inserting keystrokes or 
                mouse events and thus hijacking local X sessions on that X server.
                <div class="important"><p class="important">
                On certain Linux distributions, it may be necessary to run <code>gdmsetup</code> first in order to create the X server command line entries in the GDM configuration file.  Until these command line entries have been created, disabling XTEST using <code>vglserver_config</code> will not work.  This is known to be necessary for openSUSE 10 and Enterprise Linux 5.
                </p></div>
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                <code>x11vnc</code> and <code>x0vncserver</code> both require XTEST, so 
                if you need to attach a VNC server to the 3D X server, then it is 
                necessary to answer &ldquo;No&rdquo; (and thus leave XTEST enabled.)
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">
        If you chose to restrict X server or framebuffer device access to the 
        <code>vglusers</code> group, then edit <code>/etc/group</code> and add 
        <code>root</code> to the <code>vglusers</code> group.  If you choose, 
        you can also add additional users to the group at this time.  Note that 
        any user you add to <code>vglusers</code>	must log out and back in again 
        before their new group permissions will take effect.
    </li>
    <li class="Ordered-1 Ordered">
        Restart the display manager:
        <dl class="Description">
            <dt class="Description-3 Description">Ubuntu Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/gdm&nbsp;start
</pre>

            </dd>
            <dt class="Description-3 Description">Other Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
init&nbsp;5
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 10 servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;enable&nbsp;gdm2-login
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 11/OpenSolaris servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;enable&nbsp;gdm
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris servers running dtlogin</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;start
</pre>

            </dd>
        </dl>
    </li>
</ol>


<h3 id="hd005002001">Sanity Check</h3>

<p>To verify that the application server is ready to run VirtualGL, log out 
of the server, log back into the server using SSh, and execute the 
following commands in the SSh session:</p>

<dl class="Description">
    <dt class="Description-1 Description">If you restricted 3D X server access to <code>vglusers</code></dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
xdpyinfo&nbsp;-display&nbsp;:0
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0
</pre>

        <div class="important"><p class="important">
        NOTE: <code>xauth</code> and <code>xdpyinfo</code> are in <code>/usr/openwin/bin</code> on Solaris systems.
        </p></div>
    </dd>
    <dt class="Description-1 Description">If you did not restrict 3D X server access</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
xdpyinfo&nbsp;-display&nbsp;:0
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0
</pre>

    </dd>
</dl>

<p>Both commands should output a list of visuals and should complete with 
no errors.  If you chose to disable the XTEST extension, then check the 
output of <code>xdpyinfo</code> to verify that <code>XTEST</code> does 
not show up in the list of extensions.</p>


<h2 id="hd005003">5.3&nbsp;SSh Server Configuration</h2>

<p>The application server&rsquo;s SSh daemon should have the 
<code>X11Forwarding</code> option enabled and the <code>UseLogin</code> 
option disabled.  This is configured in <code>sshd_config</code>, the 
location of which varies depending on your distribution of SSh.  Linux, 
Solaris 10+, and OpenSolaris systems generally keep this in 
<code>/etc/ssh</code>, whereas Blastwave OpenSSh keeps it in 
<code>/opt/csw/etc</code> and SunFreeware OpenSSh keeps it in 
<code>/usr/local/etc</code>.</p>


<h2 id="hd005004">5.4&nbsp;Un-Configuring the Server</h2>

<p>You can use the <code>vglserver_config</code> script to restore the 
security settings that were in place before VirtualGL was installed.  
Option 2 
(<code>Unconfigure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>) 
will remove any shared access to the 3D X server and thus prevent 
VirtualGL from accessing the 3D hardware in that manner.  Option 2 will 
also re-enable the XTEST extension on the 3D X server.  Both Option 2 
and Option 4 
(<code>Unconfigure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLP&nbsp;mode</code>) 
will restore the framebuffer device permissions to their default (by 
default, only root or the user that is currently logged into the 
application server locally can access the framebuffer devices.)</p>

<div class="important"><p class="important">
NOTE: Unconfiguring the server does not remove the <code>vglusers</code> group or the <code>/etc/dt/config/GraphicsDevices</code> file.
</p></div>

<p>After selecting Option 2, you must restart the display manager before 
the changes will take effect.</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd006"><a name="file006"></a>6&nbsp;Configuring a Windows Machine as a Client for the VGL Image Transport</h1>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Install Hummingbird Exceed if it isn&rsquo;t already installed.
    </li>
    <li class="Ordered-1 Ordered">
        Add the Exceed path (example: 
        <code>C:\Program&nbsp;Files\Hummingbird\Connectivity\9.00\Exceed</code>) 
        to the system <code>PATH</code> environment if it isn&rsquo;t already 
        there.
    </li>
</ol>


<h2 id="hd006001">6.1&nbsp;Optimizing Exceed</h2>


<h3 id="hd006001001">Disabling Pixel Format Conversion (Exceed 2006 and earlier)</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select 
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        In the &ldquo;X Server Protocol&rdquo; applet, select the 
        &ldquo;Protocol&rdquo; tab and make sure that &ldquo;Use 32 bits per 
        pixel for true color&rdquo; is not checked. <br /><br /> 
        <img src="exceed1.png" alt="exceed1" class="inline" id="imgid_1" name="imgid_1"/>
    </li>
    <li class="Ordered-1 Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether 
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h3 id="hd006001002">Disabling Backing Store</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select 
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        Open the &ldquo;Other Server Settings&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Performance&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        Select the &ldquo;Performance&rdquo; tab and make sure that 
        &ldquo;Default Backing Store&rdquo; is set to &ldquo;None.&rdquo; 
        <br /><br /> 
        <img src="exceed3.png" alt="exceed3" class="inline" id="imgid_2" name="imgid_2"/>
    </li>
    <li class="Ordered-1 Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether 
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h3 id="hd006001003">Enabling MIT-SHM</h3>

<p>VirtualGL has the ability to take advantage of the MIT-SHM extension in 
Hummingbird Exceed to accelerate image drawing on Windows.  This can 
improve the overall performance of the VirtualGL pipeline by as much as 
20% in some cases.</p>

<p>The bad news is that this extension is not consistently implemented 
across all versions of Exceed.  In particular, Exceed 8, Exceed 9, and 
Exceed 2008 require patches to make it work properly.  If you are using 
one of these versions of Exceed, you will need to obtain the following 
patches from the Hummingbird support site:</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Product</th>
    <th class="head standard">Patches Required</th>
    <th class="head standard">How to Obtain</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 8.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v8.0.0.28 (or higher)</td>
    <td class="standard">Download all patches from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0060"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 9.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v9.0.0.9 (or higher)</td>
    <td class="standard"><code>exceed.exe</code> can be patched by running Hummingbird Update.<br /> <br /> All other patches must be downloaded from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0061"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 2008</td>
    <td class="standard"><code>xlib.dll</code> v13.0.1.235 (or higher)<br /> (or install the latest <span class="remote"><a href="http://support.hummingbird.com/customer/cspatches/patches.asp" class="remote">Connectivity 2008 Service Pack</a></span><a name="idx0062"></a>.)</td>
    <td class="standard">Download all patches from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0063"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
</table>
</div>


<p>No patches should be necessary for Exceed 10, 2006, or 2007.</p>

<p>Next, you need to enable the MIT-SHM extension in Exceed:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select 
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        Select the &ldquo;Extensions&rdquo; tab and make sure that 
        &ldquo;MIT-SHM&rdquo; is checked. <br /><br /> 
        <img src="exceed2.png" alt="exceed2" class="inline" id="imgid_3" name="imgid_3"/>
    </li>
    <li class="Ordered-1 Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether 
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>

<p><br /></p>

<hr class="break" />


<h1 id="hd007"><a name="file007"></a>7&nbsp;Using VirtualGL with the VGL Image Transport</h1>

<p><a name="VGL_Image_Transport_Usage"></a></p>


<h3 id="hd007000001">Advantages of the VGL Image Transport</h3>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        Seamless windows; every application window appears as a separate window 
        on the user&rsquo;s desktop
    </li>
    <li class="Itemize-1 Itemize asterisk">
        Supports stereographic and overlay rendering
    </li>
    <li class="Itemize-1 Itemize asterisk">
        Built-in encryption
    </li>
    <li class="Itemize-1 Itemize asterisk">
        Consumes fewer server resources, since the 2D (X11) rendering occurs on 
        the client machine
    </li>
</ul>


<h3 id="hd007000002">Disadvantages of the VGL Image Transport</h3>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        The VGL Image Transport is designed to be used with remote X servers, 
        thus it relies on the chatty remote X11 protocol to send the 2D elements 
        of the application&rsquo;s GUI to the user&rsquo;s desktop.  As a 
        result, the VGL Image Transport is not recommended for use on 
        high-latency networks
    </li>
    <li class="Itemize-1 Itemize asterisk">
        No collaboration features
    </li>
    <li class="Itemize-1 Itemize asterisk">
        Requires purchasing Exceed for use with Windows clients
    </li>
    <li class="Itemize-1 Itemize asterisk">
        The client is not stateless.  As with any remote X11 app, if the network 
        connection drops, then the application will exit
    </li>
</ul>


<h2 id="hd007001">7.1&nbsp;VGL Image Transport with X11 Forwarding</h2>

<p><a name="X11_Forwarding"></a></p>

<p>This mode is recommended for use on secure local-area networks.  The X11 
traffic is encrypted, but the VirtualGL image stream is left unencrypted 
to maximize performance.</p>


<h3 id="hd007001001">Procedure for Linux/Solaris/Mac Clients</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the X server if it isn&rsquo;t started already (<em>Mac 
        clients:</em> start the Mac X11 application.)
    </li>
    <li class="Ordered-1 Ordered">
        Open a new terminal window (<em>Mac clients:</em> in the X11 
        application, start a new xterm [Command-N] if one isn&rsquo;t already 
        started.)
    </li>
    <li class="Ordered-1 Ordered">
        In the same terminal/xterm window, open a Secure Shell (SSh) session 
        into the VirtualGL server:
<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on the 
        VirtualGL server and <em><code>{server}</code></em> with the hostname or 
        IP address of that server.
    </li>
    <li class="Ordered-1 Ordered">
        In the SSh session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">17</a> for 
        more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h3 id="hd007001002">Procedure for Windows Clients</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start Exceed if it isn&rsquo;t already started.  Hover the mouse pointer 
        over the Exceed taskbar icon and make a note of the display number on 
        which Exceed is listening (<em>Example:</em> &ldquo;Exceed 0.0 
        Multiwindow Mode&rdquo;.)
    </li>
    <li class="Ordered-1 Ordered">
        Open a new Command Prompt.
    </li>
    <li class="Ordered-1 Ordered">
        In the same Command Prompt window, set the <code>DISPLAY</code> 
        environment variable to match the display on which Exceed is listening.  
        Example:
<pre class="verbatim">
set&nbsp;DISPLAY=:0.0
</pre>

        <div class="important"><p class="important">
        If you only ever plan to use one Exceed session at a time, then you can set the <code>DISPLAY</code> environment variable in your global user environment (<em>Control Panel&ndash;&gt;System&ndash;&gt;Advanced&ndash;&gt;Environment Variables</em>.)
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        Open a Secure Shell (SSh) session into the VirtualGL server:
<pre class="verbatim">
cd&nbsp;/d&nbsp;&quot;c:\program&nbsp;files\virtualgl-{version}-{build}&quot;
vglconnect&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on the 
        VirtualGL server and <em><code>{server}</code></em> with the hostname or 
        IP address of that server.
    </li>
    <li class="Ordered-1 Ordered">
        In the SSh session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">17</a> for 
        more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h2 id="hd007002">7.2&nbsp;VGL Image Transport with a Direct X11 Connection</h2>

<p><a name="Direct_X11_Connection"></a></p>

<p>As with the <a href="#X11_Forwarding">previous 
mode</a><a name="idx0064"></a>, this mode performs optimally on 
local-area networks.  However, it is less secure, since both the X11 
traffic and the VGL image stream are unencrypted.  This mode is 
primarily useful in grid environments where you may not know ahead of 
time which server will execute a VirtualGL job.  It is assumed that the 
&ldquo;submit host&rdquo; (the machine into which you connect with SSh) 
and the &ldquo;execute hosts&rdquo; (the machines that will run 
VirtualGL jobs) share the same home directories and reside in the same 
domain.</p>

<div class="important"><p class="important">
Some newer Linux and Solaris distributions ship with default settings that do not allow TCP connections into the X server.  Such systems cannot be used as clients with this procedure unless they are reconfigured to allow X11 TCP connections.
</p></div>


<h3 id="hd007002001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for 
<a href="#X11_Forwarding">X11 forwarding</a><a name="idx0065"></a>, 
except that you should pass a <code>-x</code> argument to 
<code>vglconnect</code> when connecting to the server:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;-x&nbsp;{user}@{server}
</pre>


<h2 id="hd007003">7.3&nbsp;VGL Image Transport with SSL Encryption</h2>

<p><a name="SSL_Encryption"></a></p>

<p>This mode encrypts the VGL image stream and, when used in conjunction 
with <a href="#X11_Forwarding">X11 forwarding</a><a name="idx0066"></a>, 
provides a completely secure solution. However, enabling SSL encryption 
can reduce VirtualGL&rsquo;s performance by as much as 20% on high-speed 
networks such as Ethernet.</p>


<h3 id="hd007003001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for 
<a href="#X11_Forwarding">X11 forwarding</a><a name="idx0067"></a>, 
except that you should pass an argument of <code>+s</code> to 
<code>vglrun</code> when starting a 3D application using VirtualGL.  You 
can also set the environment variable <code>VGL_SSL</code> to 
<code>1</code> on the VirtualGL server prior to invoking 
<code>vglrun</code>.  (see Chapter 
<a href="#Advanced_Configuration" class="ref">17</a> for more details.)</p>


<h2 id="hd007004">7.4&nbsp;VGL Image Transport with X11 Forwarding and SSh Tunneling</h2>

<p><a name="SSh_Tunneling"></a></p>

<p>This mode is useful when either the VirtualGL server or the client 
machine are behind restrictive firewalls and only SSh connections are 
allowed through. Both the VGL image stream and the X11 traffic are 
tunneled through the SSh connection, and thus this mode provides a 
completely secure solution.  However, using SSh tunneling can reduce 
VirtualGL&rsquo;s performance by anywhere from 20-40% on high-speed 
networks such as Ethernet.</p>


<h3 id="hd007004001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for 
<a href="#X11_Forwarding">X11 forwarding</a><a name="idx0068"></a>, 
except that you should pass a <code>-s</code> argument to 
<code>vglconnect</code> when connecting to the server:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;-s&nbsp;{user}@{server}
</pre>

<p><code>vglconnect</code> will make two SSh connections into the server, 
the first to find an open port on the server and the second to create 
the secure image tunnels and open the secure shell.  If you are not 
using an SSh agent to create password-less logins, then this mode will 
require you to enter your password twice.</p>

<p><code>vglconnect&nbsp;-s</code> can be used to create multi-layered SSh 
tunnels.  For instance, if the VirtualGL server is not directly 
accessible from the Internet, you can use 
<code>vglconnect&nbsp;-s</code> to connect to a gateway server, then use 
<code>vglconnect&nbsp;-s</code> again on the gateway server to connect 
to the VirtualGL server.  Both the X11 and the VGL image traffic will be 
forwarded from the VirtualGL server through the gateway and to the 
client.</p>

<div class="figure">
<img src="sshtunnel.png" alt="sshtunnel" class="figure" id="imgid_15" name="imgid_15"/>
</div>


<h2 id="hd007005">7.5&nbsp;VGL Image Transport over Gigabit Networks</h2>

<p>When using the VGL image transport over Gigabit Ethernet or faster 
networks, it may be desirable to disable image compression.  This can be 
accomplished by passing an argument of <code>-c&nbsp;rgb</code> to 
<code>vglrun</code> or setting the <code>VGL_COMPRESS</code> environment 
variable to <code>rgb</code> on the VirtualGL server.  Disabling image 
compression will reduce VirtualGL&rsquo;s server and client CPU usage by 
50% or more, but the tradeoff is that it will also increase 
VirtualGL&rsquo;s network usage by a factor of 10 or more.  Thus, 
disabling image compression is not recommended unless you are using 
switched Gigabit Ethernet (or faster) infrastructure and have plenty of 
bandwidth to spare.</p>


<h2 id="hd007006">7.6&nbsp;VGL Image Transport with XDMCP</h2>

<p>Using the VGL Image Transport with XDMCP should mostly &ldquo;just 
work&rdquo;.  Once you have established the connection to the remote X 
server using XDMCP, you can then follow any of the above procedures to 
create an SSh connection to the application server and start a 3D 
application using VirtualGL.  The application server and the machine 
running the remote X server need not necessarily be the same machine.</p>


<h2 id="hd007007">7.7&nbsp;The VirtualGL Client Application: Nuts and Bolts</h2>

<p>The VirtualGL Client application receives encoded and/or compressed 
images on a dedicated TCP socket, decodes and/or decompresses the 
images, and draws the images into the appropriate X window.  In previous 
versions of VirtualGL, it was necessary to manually start the VirtualGL 
Client prior to connecting to the application server, but the new 
<code>vglconnect</code> script wraps both <code>vglclient</code> and SSh 
to greatly simplify the process of creating VGL Image Transport 
connections.  One consequence of this ease of use is that the actual 
workings of <code>vglclient</code> are hidden from view, which makes it 
a bit more difficult to see the cause of connection failures and other 
issues as they happen.</p>

<p><code>vglconnect</code> invokes <code>vglclient</code> with an argument 
of <code>-detach</code>, which causes <code>vglclient</code> to 
completely detach from the console and run as a background daemon.  It 
will remain running silently in the background, accepting VGL Image 
Transport connections for the X server on which it was started, until 
that X server is reset or until the <code>vglclient</code> process is 
explicitly killed.  Logging out of the X server will reset the X server 
and thus kill all <code>vglclient</code> instances that are attached to 
it.  You can also explicitly kill all instances of 
<code>vglclient</code> running under your user account by invoking</p>

<pre class="verbatim">
vglclient&nbsp;-kill
</pre>

<p>(<code>vglclient</code> is in <code>/opt/VirtualGL/bin</code> on 
Linux/Mac/Solaris systems and in 
<code>c:\program&nbsp;files\virtualgl-{version}-{build}</code> on 
Windows systems.)</p>

<p><code>vglconnect</code> instructs <code>vglclient</code> to redirect all 
of its console output to a log file named 
<em><code>{home}</code></em><code>/.vgl/vglconnect-</code><em><code>{hostname}</code></em><code>-</code><em><code>{display}</code></em><code>.log</code>, 
where <em><code>{home}</code></em> is the path of the current 
user&rsquo;s home directory (<code>%USERPROFILE%</code> on Windows 
systems), <em><code>{hostname}</code></em> is the name of the computer 
running <code>vglconnect</code>, and <em><code>{display}</code></em> is 
the name of the current X display (read from the <code>DISPLAY</code> 
environment or passed to <code>vglconnect</code> using the 
<code>-display</code> argument.)  In the event that something goes 
wrong, this log file is the first place to check.</p>

<p>When <code>vglclient</code> successfully starts on a given X display, it 
stores its listener port numbers in a pair of root window properties on 
the X display.  If other <code>vglclient</code> instances attempt to 
start on the same X display, they read the X window properties, 
determine that another <code>vglclient</code> instance is already 
running, and exit to allow the first instance to retain control. 
<code>vglclient</code> will clean up these X properties under most 
circumstances, even if it is explicitly killed.  However, under rare 
circumstances (if sent a SIGKILL signal on Unix, for instance), a 
<code>vglclient</code> instance may exit uncleanly and leave the X 
properties set.  In these cases, it may be necessary to add an argument 
of <code>-force</code> to <code>vglconnect</code> the next time you use 
it. This tells <code>vglconnect</code> to start a new 
<code>vglclient</code> instance, regardless of whether 
<code>vglclient</code> thinks that there is already an instance running 
on this X display.  Alternately, you can simply reset your X server to 
clear the orphaned X window properties.</p>


<h3 id="hd007007001">7.7.1&nbsp;The VirtualGL Client and Firewalls</h3>

<p>To retain compatibility with previous versions of VirtualGL, the first 
<code>vglclient</code> instance on a given machine will attempt to 
listen on port 4242 for unencrypted connections and 4243 for SSL 
connections.  If it fails to obtain one of those ports, because another 
application or another <code>vglclient</code> instance is already using 
them, then <code>vglclient</code> will try to obtain a free port in the 
range of 4200-4299.  Failing that, it will request a free port from the 
operating system.</p>

<p>In a nutshell: if you only ever plan to run one X server at a time on 
your client machine, which means that you&rsquo;ll only ever need one 
instance of <code>vglclient</code> at a time, then it is sufficient to 
open inbound ports 4242 and 4243 in your client machine&rsquo;s 
firewall.  If you plan to run multiple X servers on your client machine, 
which means that you will need to run multiple <code>vglclient</code> 
instances, then you may wish to open ports 4200-4299.  Similarly, if you 
are running <code>vglclient</code> on a multi-user X proxy server or Sun 
Ray server that has a firewall, then you may wish to open ports 
4200-4299 in the server&rsquo;s firewall.  Opening ports 4200-4299 will 
accommodate up to 50 separate <code>vglclient</code> instances.  More 
instances than that cannot be accommodated on a firewalled machine, 
unless the firewall is able to create rules based on application 
executables instead of listening ports.</p>

<p>Note that it is not necessary to open any inbound ports in the firewall 
to use the VGL Image Transport with <a href="#SSh_Tunneling">SSh 
Tunneling</a><a name="idx0069"></a>.</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd008"><a name="file008"></a>8&nbsp;Using VirtualGL with X Proxies Such as VNC</h1>

<p><a name="X11_Proxy_Usage"></a></p>

<p>The VGL Image Transport is a good solution for using VirtualGL over a 
fast network.  However, the VGL Image Transport is not generally 
suitable for high-latency networks, due to its reliance on the X11 
protocol to send the non-3D elements of the 3D application&rsquo;s GUI.  
The VGL Image Transport also requires an X server to be running on the 
client machine, which makes it more difficult and costly to deploy for 
Windows clients.  VirtualGL can be used with an &ldquo;X proxy&rdquo; to 
overcome these limitations.  An X proxy acts as a virtual X server, 
receiving X11 commands from the application (and from VirtualGL), 
rendering the X11 commands into images, compressing the resulting 
images, and sending the compressed images over the network to a client 
or clients.  X proxies perform well on all types of networks, including 
high-latency networks. They often provide rudimentary collaboration 
capabilities, allowing multiple clients to simultaneously view the same 
X session and pass around control of the keyboard and mouse.  X proxies 
are also stateless, meaning that the client can disconnect and reconnect 
at will from any machine on the network, and the 3D application will 
remain running on the server.</p>

<p>Since VirtualGL is sending rendered 3D images to the X proxy at a very 
fast rate, the proxy must be able to compress the images very quickly in 
order to keep up.  Unfortunately, however, most X proxies can&rsquo;t.  
They simply aren&rsquo;t designed to compress, with any degree of 
performance, the large and complex images generated by 3D applications.  
Therefore, the VirtualGL Project provides an optimized X proxy called 
&ldquo;TurboVNC&rdquo;, a variant of 
<span class="remote"><a href="http://www.tightvnc.com" class="remote">TightVNC</a></span><a name="idx0070"></a> 
that is designed specifically to achieve high levels of performance with 
VirtualGL.  More information about TurboVNC, including instructions for 
using it with VirtualGL, can be found in the TurboVNC User&rsquo;s Guide.</p>

<p><span class="remote"><a href="http://www.tigervnc.com" class="remote">TigerVNC</a></span><a name="idx0071"></a> 
is a next-generation VNC project based on the RealVNC and Xorg code 
bases.  TigerVNC spun off from the TightVNC project in early 2009, and 
the VirtualGL Project now actively participates in its development.  
TigerVNC uses a SIMD-accelerated version of libjpeg, which makes it much 
faster than RealVNC or TightVNC.  As of this writing, TigerVNC&rsquo;s 
performance is not yet on par with TurboVNC, but the ultimate goal is to 
replace TurboVNC with this solution.  TigerVNC is available in Fedora 11 
or later.</p>

<p>Other solutions, such as RealVNC and NX, also work well with VirtualGL. 
Generally, none of these other solutions will provide anywhere near the 
performance of TurboVNC, but some of them have capabilities that 
TurboVNC lacks (NX, for instance, can do seamless windows.)</p>


<h2 id="hd008001">8.1&nbsp;Using VirtualGL with an X Proxy on the Same Server</h2>

<p><a name="X11_Proxy_Usage_Local"></a></p>

<p>The most common (and optimal) way to use VirtualGL with an X proxy is to 
set up both on the same server.  This allows VirtualGL to send its 
rendered 3D images to the X proxy through shared memory rather than 
sending them over a network.</p>

<div class="figure">
<img src="x11transport.png" alt="x11transport" class="figure" id="imgid_16" name="imgid_16"/>
</div>

<p>With this configuration, you can usually invoke</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;{application_executable_or_script}
</pre>

<p>from within an X proxy session, and it will &ldquo;just work.&rdquo;  
VirtualGL reads the value of the <code>DISPLAY</code> environment 
variable to determine whether to enable the X11 Image Transport by 
default.  If <code>DISPLAY</code> begins with a colon 
(&ldquo;<code>:</code>&rdquo;) or with &ldquo;<code>unix:</code>&rdquo;, 
then VirtualGL will assume that the X server connection is local and 
will enable the X11 Image Transport as the default.  In some cases, 
however, the <code>DISPLAY</code> environment variable within the X 
proxy may not begin with a colon or &ldquo;<code>unix:</code>&rdquo;.  
In these cases, it is necessary to manually enable the X11 Image 
Transport by setting the <code>VGL_COMPRESS</code> environment variable 
to <code>proxy</code> or by passing an argument of 
<code>-c&nbsp;proxy</code> to <code>vglrun</code>.</p>


<h2 id="hd008002">8.2&nbsp;Using VirtualGL with an X Proxy on a Different Machine</h2>

<p><a name="X11_Proxy_Usage_Remote"></a></p>

<div class="figure">
<img src="vgltransportservernetwork.png" alt="vgltransportservernetwork" class="figure" id="imgid_17" name="imgid_17"/>
</div>

<p>If the X proxy and VirtualGL are running on different servers, then it 
is desirable to use the VGL Image Transport to send images from the 
VirtualGL server to the X proxy.  It is also desirable to disable image 
compression in the VGL Image Transport.  Otherwise, the images would 
have to be compressed by the VirtualGL server, decompressed by the 
VirtualGL Client, then recompressed by the X proxy, which is a waste of 
CPU resources.  However, sending images uncompressed over a network 
requires a fast network (generally, Gigabit Ethernet or faster), so 
there needs to be a fast link between the VirtualGL server and the X 
proxy for this procedure to perform well.</p>

<p>The procedure for using the VGL Image Transport to remotely display 3D 
applications from a VirtualGL server to an X proxy is the same as the 
<a href="#X11_Forwarding">procedure</a><a name="idx0072"></a> for using 
the VGL Transport to remotely display 3D applications from a VirtualGL 
server to a remote 2D X server, with the following notable differences:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        The &ldquo;client&rdquo; in this case is really the machine on which the 
        X proxy is running.
    </li>
    <li class="Ordered-1 Ordered">
        The &ldquo;X server&rdquo; is really the X proxy.
    </li>
    <li class="Ordered-1 Ordered">
        Once connected to the VirtualGL server with SSh, it is recommended that 
        you disable image compression in the VGL Image Transport by either 
        setting the <code>VGL_COMPRESS</code> environment variable to 
        <code>rgb</code> or passing an argument of <code>-c&nbsp;rgb</code> to 
        <code>vglrun</code> when launching VirtualGL.  Otherwise, VirtualGL will 
        detect that the connection to the X server is remote, and it will 
        automatically try to enable JPEG compression.
    </li>
</ol>

<p><br /></p>

<hr class="break" />


<h1 id="hd009"><a name="file009"></a>9&nbsp;Using VirtualGL in a Sun Ray Environment</h1>

<p><a name="Sun_Ray_Usage"></a></p>

<p>As described in Chapter <a href="#Overview" class="ref">2</a>, the Sun 
Ray environment consists of both an X proxy and an ultra-thin hardware 
client.  If the proprietary VirtualGL Sun Ray plugin is not used, then 
the Sun Ray server can be treated just like any other X proxy and used 
with either the X11 Image Transport or the VGL Image Transport, as 
described in Chapter <a href="#X11_Proxy_Usage" class="ref">8</a>.</p>

<p>If, however, the Sun Ray plugin is installed on the VirtualGL server, 
then a slightly different procedure is required to connect to that 
server and use the Sun Ray Image Transport.  This procedure assumes that 
VirtualGL is running on a different machine than the Sun Ray server.</p>


<h3 id="hd009000001">Procedure</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        In the Sun Ray session, open a new terminal window.
    </li>
    <li class="Ordered-1 Ordered">
        In the same terminal window, open a Secure Shell (SSh) session into the 
        VirtualGL server:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on the 
        VirtualGL server and <em><code>{server}</code></em> with the hostname or 
        IP address of that server.
    </li>
    <li class="Ordered-1 Ordered">
        In the SSh session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">17</a> for 
        more information on <code>vglrun</code> command line options.
    </li>
</ol>

<p>Note that this procedure is substantially similar to the 
<a href="#X11_Forwarding">X11 Forwarding</a><a name="idx0073"></a> 
procedure used with the VGL Image Transport, except that it invokes 
<code>ssh</code> directly rather than using the <code>vglconnect</code> 
wrapper script.  <code>vglconnect</code> launches 
<code>vglclient</code>, and <code>vglclient</code> is not needed when 
using the Sun Ray Image Transport.</p>

<p>If the VirtualGL Sun Ray plugin is installed on a VirtualGL server, then 
VirtualGL will try to use the Sun Ray Image Transport when displaying 3D 
applications from that server to a Sun Ray client.  However, the Sun Ray 
Image Transport requires that the Sun Ray client be on a network that is 
accessible from the VirtualGL server.  Some Sun Ray deployments place 
the clients on a private network that is visible only to the Sun Ray 
server, and the Sun Ray Image Transport cannot be used in such cases 
(unless VirtualGL is running on the Sun Ray server itself, but that 
defeats the purpose of the Sun Ray Image Transport.)  If VirtualGL 
detects that it is running in a Sun Ray environment but is unable to use 
the Sun Ray Image Transport, then it will fall back to using the X11 
Image Transport.</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd0010"><a name="file010"></a>10&nbsp;Using VirtualGL with setuid/setgid Executables</h1>

<p><code>vglrun</code> can be used to launch either binary executables or 
shell scripts, but there are a few things to keep in mind when using 
<code>vglrun</code> to launch a shell script.  When you 
<code>vglrun</code> a shell script, the VirtualGL faker library will be 
preloaded into every executable that the script launches.  Normally this 
is innocuous, but if the script calls any executables that have the 
setuid and/or setgid permission bits set, then the dynamic linker will 
refuse to preload the VirtualGL faker library into those executables.  
One of the following warnings will be printed out for each setuid/setgid 
executable that the script tries to launch:</p>

<dl class="Description">
    <dt class="Description-1 Description">Linux</dt>
    <dd class="Description-1 Description">
    </dd>
</dl>

<pre class="verbatim">
ERROR:&nbsp;ld.so:&nbsp;object&nbsp;'librrfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.
</pre>

<pre class="verbatim">
ERROR:&nbsp;ld.so:&nbsp;object&nbsp;'libdlfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.
</pre>

<dl class="Description">
    <dt class="Description-1 Description">Solaris</dt>
    <dd class="Description-1 Description">
    </dd>
</dl>

<pre class="verbatim">
ld.so.1:&nbsp;warning:&nbsp;librrfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories
</pre>

<pre class="verbatim">
ld.so.1:&nbsp;warning:&nbsp;libdlfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories
</pre>

<p>On Solaris and on newer versions of Linux (GLIBC 2.3 and later), the 
executable will continue to run, but without VirtualGL preloaded into 
it.  That may be a problem, if the setuid/setgid executable was a 3D 
application that was intended to be used with VirtualGL.  To further 
complicate matters, some older versions of Linux will refuse to launch 
setuid/setgid executables at all if one attempts to preload VirtualGL 
into them.</p>

<p>There are a couple of ways to work around this issue.  If the 3D 
application that you are intending to run in VirtualGL is not itself a 
setuid/setgid executable, then probably the safest way to work around 
the issue is simply to edit the application script and make it store the 
value of the <code>LD_PRELOAD</code> environment variables until right 
before the application executable is launched.  For instance, consider 
the following application script:</p>

<p>Initial contents of <code>application.sh</code>:</p>

<pre class="verbatim">
#!/bin/sh
some_setuid_executable
some_application_executable
</pre>

<p>You could modify the script as follows:</p>

<dl class="Description">
    <dt class="Description-1 Description">Solaris</dt>
    <dd class="Description-1 Description">
        Modified <code>application.sh</code>:
    </dd>
</dl>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_32_SAVE=$LD_PRELOAD_32
LD_PRELOAD_64_SAVE=$LD_PRELOAD_64
LD_PRELOAD_32=
LD_PRELOAD_64=
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_setuid_executable

LD_PRELOAD_32=$LD_PRELOAD_32_SAVE
LD_PRELOAD_64=$LD_PRELOAD_64_SAVE
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_application_executable
</pre>

<dl class="Description">
    <dt class="Description-1 Description">Linux</dt>
    <dd class="Description-1 Description">
        Modified <code>application.sh</code>:
    </dd>
</dl>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_SAVE=$LD_PRELOAD
LD_PRELOAD=
export&nbsp;LD_PRELOAD

some_setuid_executable

LD_PRELOAD=$LD_PRELOAD_SAVE
export&nbsp;LD_PRELOAD

some_application_executable
</pre>

<p>You can also force VirtualGL to be preloaded into setuid/setgid 
executables, but please be aware of the security ramifications of this 
before you do it.  By applying one of the following workarounds, you are 
essentially telling the operating system that you trust the security and 
stability of the VirtualGL code as much as you trust the security and 
stability of the operating system. And while we&rsquo;re flattered, 
we&rsquo;re not sure that we&rsquo;re necessarily deserving of that 
accolade, so if you are in a security critical environment, apply the 
appropriate level of paranoia here.</p>

<p><a name="setuid_linux"></a> To force VirtualGL to be preloaded into 
setuid/setgid executables on Linux, make <code>librrfaker.so</code> and 
<code>libdlfaker.so</code> setuid executables.  To do this, run the 
following commands as root:</p>

<pre class="verbatim">
chmod&nbsp;u+s&nbsp;/usr/lib/librrfaker.so
chmod&nbsp;u+s&nbsp;/usr/lib/libdlfaker.so
</pre>

<p>On 64-bit Linux systems, also run:</p>

<pre class="verbatim">
chmod&nbsp;u+s&nbsp;/usr/lib64/librrfaker.so
chmod&nbsp;u+s&nbsp;/usr/lib64/libdlfaker.so
</pre>

<p>On Solaris, you can force VirtualGL to be preloaded into setuid/setgid 
executables by adding the VirtualGL library directories to the Solaris 
&ldquo;secure path.&rdquo;  Solaris keeps a tight lid on what goes into 
<code>/usr/lib</code> and <code>/lib</code>, and by default, it will 
only allow libraries in those paths to be preloaded into an executable 
that is setuid and/or setgid.  Generally, 3rd party packages are 
forbidden from installing anything into <code>/usr/lib</code> or 
<code>/lib</code>.  But you can use the <code>crle</code> utility to add 
other directories to the operating system&rsquo;s list of secure paths.  
In the case of VirtualGL, you would execute the following commands (as 
root):</p>

<pre class="verbatim">
crle&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib
crle&nbsp;-64&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib/64
</pre>

<p><code>vglrun</code> on Solaris has two additional options that are 
relevant to launching scripts:</p>

<pre class="verbatim">
vglrun&nbsp;-32&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 32-bit executables called by a script, 
whereas</p>

<pre class="verbatim">
vglrun&nbsp;-64&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 64-bit executables.  So if, for 
instance, the setuid executable that the script is invoking is 32-bit 
and the application executable is 64-bit, then you could use 
<code>vglrun&nbsp;-64</code> to launch the application script.</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd0011"><a name="file011"></a>11&nbsp;Using VirtualGL with Chromium and ModViz VGP</h1>

<p><a name="Chromium"></a></p>

<p>Chromium is a powerful framework for performing various types of 
parallel OpenGL rendering.  It is usually used on clusters of commodity 
Linux PC&rsquo;s to divide up the task of rendering scenes with large 
geometries or large pixel counts (such as when driving a display wall.)  
Chromium is most often used in one of three configurations:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered" value="1">
        Sort-First Rendering (Image-Space Decomposition)
    </li>
    <li class="Ordered-1 Ordered" value="2">
        Sort-First Rendering (Image-Space Decomposition) with Readback
    </li>
    <li class="Ordered-1 Ordered" value="3">
        Sort-Last Rendering (Object-Space Decomposition)
    </li>
</ol>


<h2 id="hd0011001">11.1&nbsp;Configuration 1: Sort-First Rendering (Image-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-displaywall.png" alt="chromium-displaywall" class="figure" id="imgid_18" name="imgid_18"/>
</div>

<p>Sort-First Rendering (Image-Space Decomposition) is used to overcome the 
fill rate limitations of individual graphics cards.  When configured to 
use sort-first rendering, Chromium divides up the scene based on which 
polygons will be visible in a particular section of the final image.  It 
then instructs each node of the cluster to render only the polygons that 
are necessary to generate the image section (&ldquo;tile&rdquo;) for 
that node.  This is primarily used to drive high-resolution displays 
that would be impractical to drive from a single graphics card due to 
limitations in the card&rsquo;s framebuffer memory, processing power, or 
both.  Configuration 1 could be used, for instance, to drive a CAVE, 
video wall, or even an extremely high-resolution monitor.  In this 
configuration, each Chromium node generally uses all of its screen real 
estate to render a section of the multi-screen image.</p>

<p>VirtualGL is generally not very useful with Configuration 1.  You could 
theoretically install a separate copy of VirtualGL on each display node 
and use it to redirect the output of each <code>crserver</code> instance 
to a separate VirtualGL Client instance running on a multi-screen 2D X 
server elsewhere on the network. However, synchronizing the frames on 
the remote end would require extensive modifications to VirtualGL and 
perhaps to Chromium as well.  Such is left as an exercise for the reader.</p>


<h2 id="hd0011002">11.2&nbsp;Configuration 2: Sort-First Rendering (Image-Space Decomposition) with Readback</h2>

<div class="figure">
<img src="chromium-sortfirst.png" alt="chromium-sortfirst" class="figure" id="imgid_19" name="imgid_19"/>
</div>

<p>Configuration 2 uses the same sort-first principle as Configuration 1, 
except that each tile is only a fraction of a single screen, and the 
tiles are recombined into a single window on Node 0.  This configuration 
is perhaps the least often used of the three, but it is useful in cases 
where the scene contains a large amount of textures (such as in volume 
rendering) and thus rendering the whole scene on a single node would be 
prohibitively slow due to fill rate limitations.</p>

<p>In this configuration, the application is allowed to choose a visual, 
create an X window, and manage the window as it would normally do.  
However, all other OpenGL and GLX activity is intercepted by the 
Chromium App Faker (CrAppFaker) so that the 3D rendering can be split up 
among the rendering nodes.  Once each node has rendered its section of 
the final image, the image tiles are passed back to a Chromium Server 
(CrServer) process running on Node 0.  This CrServer process attaches to 
the previously-created application window and draws the pixels into the 
window using <code>glDrawPixels()</code>.</p>

<p>The general strategy for making this work with VirtualGL is to first 
make it work without VirtualGL and then insert VirtualGL only into the 
processes that run on Node 0.  VirtualGL must be inserted into the 
CrAppFaker process to prevent CrAppFaker from sending 
<code>glXChooseVisual()</code> calls to the 2D X server (which would 
fail if this X server was a VNC session or otherwise did not support 
GLX.)  VirtualGL must be inserted into the CrServer process on Node 0 to 
prevent it from sending <code>glDrawPixels()</code> calls to the 2D X 
server (which would similarly fail if the 2D X server didn&rsquo;t 
support GLX and which would create a performance issue if the 2D X 
server was remote.)  Instead, VirtualGL forces CrServer to draw into a 
Pbuffer, and VGL then takes charge of transmitting the pixels from the 
Pbuffer to the 2D X server in the most efficient way possible.</p>

<p>As with any normal OpenGL application, CrServer can be launched using 
<code>vglrun</code>.  However, because CrAppFaker also interposes OpenGL 
and GLX functions, it must be handled differently in order to avoid 
interference with VirtualGL.  Chromium provides an environment variable, 
<code>CR_SYSTEM_GL_PATH</code>, which allows one to specify an alternate 
path to be searched for <code>libGL.so</code>. The VirtualGL packages 
for Linux and Solaris include a symbolic link named 
<code>libGL.so</code> which points to the VirtualGL faker library 
(<code>librrfaker.so</code>). This symbolic link is located in its own 
isolated directory, so that directory can be passed to Chromium in the 
<code>CR_SYSTEM_GL_PATH</code> environment variable, and this will cause 
Chromium to load VirtualGL rather than the &ldquo;real&rdquo; OpenGL 
library.  Refer to the following table:</p>

<p><a name="CR_SYSTEM_GL_PATH_Table"></a></p>

<div class="table">
<table class="standard" align="center">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">32-bit Applications</th>
    <th class="head standard">64-bit Applications</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>/opt/VirtualGL/fakelib</code></td>
    <td class="standard"><code>/opt/VirtualGL/fakelib/64</code></td>
  </tr>
</table>
<div class="tableNote" style="text-align=center;"><code>CR_SYSTEM_GL_PATH</code> setting required to use VirtualGL with Chromium</div>
</div>


<p>To run CrAppFaker, it is necessary to set this environment variable to 
the appropriate value so that Chromium will load the interposed versions 
of OpenGL and GLX functions from VirtualGL.  It is also necessary to set 
<code>VGL_GLLIB</code> to the location of the &ldquo;real&rdquo; OpenGL 
library (example: <code>/usr/lib/libGL.so.1</code>). CrAppFaker creates 
its own fake version of <code>libGL.so</code> which is really just a 
copy of Chromium&rsquo;s <code>libcrfaker.so</code>.  Thus, if left to 
its own devices, VirtualGL will unwittingly try to load 
<code>libcrfaker.so</code> instead of the &ldquo;real&rdquo; OpenGL 
library.  Chromium&rsquo;s <code>libcrfaker.so</code> will, in turn, try 
to load VirtualGL, and an endless loop will occur.</p>

<p>Therefore, we must use the <code>CR_SYSTEM_GL_PATH</code> environment 
variable to tell Chromium to pass OpenGL commands into VirtualGL, then 
we must use the <code>VGL_GLLIB</code> environment variable to tell 
VirtualGL <em>not</em> to pass OpenGL commands into Chromium:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
export&nbsp;VGL_GLLIB=/usr/lib/libGL.so.1
crappfaker
</pre>

<p>CrAppFaker will copy the application into a temporary directory and then 
copy <code>libcrfaker.so</code> to that same directory, renaming it as 
<code>libGL.so</code>.  So when the application is started, it loads 
<code>libcrfaker.so</code> instead of <code>libGL.so</code>. 
<code>libcrfaker.so</code> will then load VirtualGL instead of the 
&ldquo;real&rdquo; OpenGL library, because we&rsquo;ve overridden 
<code>CR_SYSTEM_GL_PATH</code> to point to VirtualGL&rsquo;s fake 
<code>libGL.so</code>.  VirtualGL will then use the library specified in 
<code>VGL_GLLIB</code> to make any &ldquo;real&rdquo; OpenGL calls that 
it needs to make.</p>

<div class="important"><p class="important">
NOTE: <code>crappfaker</code> should not be invoked with <code>vglrun</code>.
</p></div>

<p>So, putting this all together, here is an example of how you might start 
a sort-first rendering job using Chromium and VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the mothership on Node 0 with an appropriate configuration for 
        performing sort-first rendering with readback
    </li>
    <li class="Ordered-1 Ordered">
        Start <code>crserver</code> on each of the rendering nodes
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, set the <code>CR_SYSTEM_GL_PATH</code> environment variable 
        to the appropriate value based on whether <code>crappfaker</code> was 
        compiled as a 32-bit or a 64-bit app (see table above)
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, set <code>VGL_GLLIB</code> to the location of the 
        &ldquo;real&rdquo; OpenGL library (example: 
        <code>/usr/lib/libGL.so.1</code> or <code>/usr/lib64/libGL.so.1</code>).
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, launch <code>crappfaker</code> (do not use 
        <code>vglrun</code> here)
    </li>
</ol>

<p>Again, it&rsquo;s always a good idea to make sure this works without 
VirtualGL before adding VirtualGL into the mix.</p>

<p><a name="Force_Pbuffer"></a></p>


<h3 id="hd0011002001">Using VirtualGL to Force Pbuffer Rendering</h3>

<p>In the procedure above, VirtualGL can also be used on the rendering 
nodes to redirect the rendering commands from <code>crserver</code> into 
a Pbuffer instead of a window.  If you wish to do this, then perform the 
following procedure in place of step 2 above:</p>

<p>On each of the rendering nodes,</p>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        set the <code>VGL_READBACK</code> environment variable to <code>0</code>
    </li>
    <li class="Itemize-1 Itemize asterisk">
        <code>vglrun&nbsp;crserver</code>
    </li>
</ul>


<h2 id="hd0011003">11.3&nbsp;Configuration 3: Sort-Last Rendering (Object-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-sortlast.png" alt="chromium-sortlast" class="figure" id="imgid_20" name="imgid_20"/>
</div>

<p>Sort-Last Rendering is used when the scene contains a huge number of 
polygons and the rendering bottleneck is processing all of that geometry 
on a single graphics card.  In this case, each node runs a separate copy 
of the application, and for best results, the application needs to be 
aware that it is running in a parallel environment so that it can give 
Chromium hints as to how to distribute the various objects to be 
rendered.  Each node generates an image of a particular portion of the 
object space, and these images must be composited in such a way that the 
front-to-back ordering of pixels is maintained.  This is generally done 
by collecting Z buffer data from each node to determine whether a 
particular pixel on a particular node is visible in the final image.  
The rendered images from each node are often composited using a 
&ldquo;binary swap&rdquo;, whereby the nodes combine their images in a 
cascading tree so that the overall compositing time is proportional to 
log<sub>2</sub>(N) rather than N.</p>

<p>To make this configuration work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the mothership on Node 0 with an appropriate configuration for 
        performing sort-last rendering
    </li>
    <li class="Ordered-1 Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h3 id="hd0011003001">CRUT</h3>

<p>The Chromium Utility Toolkit provides a convenient way for graphics 
applications to specifically take advantage of Chromium&rsquo;s 
sort-last rendering capabilities.  Such applications can use CRUT to 
explicitly specify how their object space should be decomposed.  CRUT 
applications require an additional piece of software, 
<code>crutserver</code>, to be running on Node 0.  Therefore, the 
following procedure should be used to make these applications work with 
VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the mothership on Node 0 with an appropriate configuration for 
        performing sort-last rendering
    </li>
    <li class="Ordered-1 Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crutserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h2 id="hd0011004">11.4&nbsp;A Note About Performance</h2>

<p>Chromium&rsquo;s use of X11 is generally not very optimal.  It assumes a 
very fast connection between the 2D X server and the Chromium Server.  
In certain modes, Chromium polls the 2D X server on every frame to 
determine whether windows have been resized, etc.  Thus, we have 
observed that, even on a fast network, Chromium tends to perform much 
better with VirtualGL running in a TurboVNC session as opposed to using 
the VGL Image Transport.</p>


<h2 id="hd0011005">11.5&nbsp;ModViz VGP v1.x and VirtualGL</h2>

<p>ModViz Virtual Graphics Platform<sup>TM</sup> is a polished commercial 
clustered rendering framework for Linux which supports all three of the 
rendering modes described above and provides a much more straightforward 
interface to configure and run these types of parallel rendering jobs.</p>

<p>All VGP jobs, regardless of configuration, are spawned through 
<code>vglauncher</code>, a front-end program which automatically takes 
care of starting the appropriate processes on the rendering nodes, 
intercepting OpenGL calls from the application instance(s), sending 
rendered images back to Node 0, and compositing the images as 
appropriate.  In a similar manner to VirtualGL&rsquo;s 
<code>vglrun</code>, VGP&rsquo;s <code>vglauncher</code> preloads a 
library (<code>libVGP.so</code>) in place of <code>libGL.so</code>, and 
this library intercepts the OpenGL calls from the application.</p>

<p>So our strategy here is similar to our strategy for loading the Chromium 
App Faker.  We want to insert VirtualGL between VGP and the real system 
OpenGL library, so that VGP will call VirtualGL and VirtualGL will call 
<code>libGL.so</code>. Achieving this with VGP is relatively simple:</p>

<pre class="verbatim">
export&nbsp;VGP_BACKING_GL_LIB=librrfaker.so
vglrun&nbsp;-nodl&nbsp;vglauncher&nbsp;--preload=librrfaker.so:/usr/lib/libGL.so&nbsp;{application}
</pre>

<p>Replace <code>/usr/lib/libGL.so</code> with the full path of your 
system&rsquo;s OpenGL library (<code>/usr/lib64/libGL.so</code> if you 
are launching a 64-bit application.)</p>

<div class="important"><p class="important">
NOTE: This is known not to work with VGP 2.0.
</p></div>

<p><br /></p>

<hr class="break" />


<h1 id="hd0012"><a name="file012"></a>12&nbsp;Using VirtualGL with VirtualBox</h1>

<p>VirtualBox is an enterprise-class, open source virtualization solution 
provided by Sun Microsystems.  With the release of VirtualBox 2.1.0, 
experimental support was added for hardware-accelerated OpenGL in 
Windows and Linux guests running on Windows, MacIntel, Linux, and 
Solaris/x86 hosts. 3D acceleration in VirtualBox is accomplished by 
installing a special driver in the guest which uses a subset of Chromium 
to transmit OpenGL calls through a local connection to the VirtualBox 
process running on the host.  When used in conjunction with VirtualGL on 
a Linux or Solaris/x86 host, this solution provides a means of 
displaying Windows 3D applications remotely.</p>

<p>To use VirtualGL with VirtualBox, perform the following procedure:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Launch VirtualBox and use the VirtualBox GUI to create and test your 
        virtual machine.
    </li>
    <li class="Ordered-1 Ordered">
        Follow the procedures outlined in the VirtualBox User&rsquo;s Manual to 
        enable 3D acceleration on the virtual machine.  Verify that 3D 
        acceleration works <em>without</em> VirtualGL before adding VirtualGL to 
        the mix.
    </li>
    <li class="Ordered-1 Ordered">
        Follow the procedure described in Section 
        <a href="#setuid_linux" class="ref">10</a> to make 
        <code>librrfaker.so</code> a setuid executable (Linux) or to add the 
        VirtualGL library directory to the list of secure paths (Solaris).
    </li>
    <li class="Ordered-1 Ordered">
        If running 32-bit VirtualBox,
<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
</pre>

        If running 64-bit VirtualBox,
<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib/64
</pre>

    </li>
    <li class="Ordered-1 Ordered">
        <code>vglrun&nbsp;-nodl&nbsp;VirtualBox&nbsp;-startvm&nbsp;</code><em><code>{VM&nbsp;name&nbsp;or&nbsp;UUID}</code></em>
    </li>
</ol>


<h3 id="hd0012000001">NOTES</h3>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        VirtualBox should work with prior versions of VirtualGL (2.0 through 
        2.1.1), but it is necessary to remove the <code>-nodl</code> argument 
        from the <code>vglrun</code> command line when using VirtualBox with 
        these versions of VirtualGL.  Some versions of VirtualBox may not work 
        with VirtualGL 2.1.2.
    </li>
    <li class="Itemize-1 Itemize asterisk">
        You might want to temporarily enable profiling (add an argument of 
        <code>+pr</code> to <code>vglrun</code> above) in order to verify that 
        VirtualGL is loaded and working.
    </li>
    <li class="Itemize-1 Itemize asterisk">
        It is necessary to start the virtual machine directly as described 
        above. Simply executing <code>vglrun&nbsp;VirtualBox</code> and using 
        the GUI to launch the VM does not work.  VirtualBox forks a separate 
        process for each VM, and the value of the <code>LD_PRELOAD</code> 
        environment variable from <code>vglrun</code> does not get propagated to 
        the VM process unless you start it directly.
    </li>
    <li class="Itemize-1 Itemize asterisk">
        VirtualBox sends mainly uncompressed image updates to the X display, so 
        the 2D elements of the virtual machine display will not perform well 
        over a remote X11 connection unless a 
        <a href="#Direct_X11_Connection">direct X11 
        connection</a><a name="idx0074"></a> (<code>vglconnect&nbsp;-x</code>) 
        is used with gigabit Ethernet (or faster.)  For 100 Megabit and slower 
        networks, using TurboVNC is recommended when remotely displaying 
        VirtualBox using VirtualGL.
    </li>
</ul>

<p><br /></p>

<hr class="break" />


<h1 id="hd0013"><a name="file013"></a>13&nbsp;Other Application Recipes</h1>

<p><a name="Application_Recipes"></a></p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Application</th>
    <th class="head standard">Platform</th>
    <th class="head standard">Recipe</th>
    <th class="head standard">Notes</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">ANSA v12.1.0</td>
    <td class="standard">Linux/x86</td>
    <td class="standard">Add <br /><br /> <code>LD_PRELOAD_SAVE=$LD_PRELOAD</code><br /> <code>export&nbsp;LD_PRELOAD=</code> <br /><br /> to the top of the <code>ansa.sh</code> script, then add <br /><br /> <code>export&nbsp;LD_PRELOAD=$LD_PRELOAD_SAVE</code> <br /><br /> just prior to the <code>${ANSA_EXEC_DIR}bin/ansa_linux${ext2}</code> line.</td>
    <td class="standard">The ANSA startup script directly invokes <code>/lib/libc.so.6</code> to query the glibc version.  Since the VirtualGL faker depends on libc, preloading VirtualGL when directly invoking <code>libc.so.6</code> creates an infinite loop. So it is necessary to disable the preloading of VirtualGL in the application script and then re-enable it prior to launching the actual application.</td>
  </tr>
  <tr class="standard">
    <td class="standard">AutoForm v4.0x</td>
    <td class="standard">All</td>
    <td class="standard"><code>vglrun&nbsp;+sync&nbsp;xaf_</code><em><code>{version}</code></em></td>
    <td class="standard">AutoForm relies on mixed X11/OpenGL rendering, and thus certain features (particularly the &ldquo;Dynamic Section&rdquo; dialog and &ldquo;Export Image&rdquo; feature) do not work properly unless <code>VGL_SYNC</code> is enabled.  Since <code>VGL_SYNC</code> automatically enables the X11 image transport and disables frame spoiling, it is highly recommended that you use TurboVNC when <code>VGL_SYNC</code> is enabled.  See Section <a href="#VGL_SYNC" class="ref">17.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Cedega v6.0.x</td>
    <td class="standard">Linux</td>
    <td class="standard">Add <br /><br /> <code>export&nbsp;LD_PRELOAD=librrfaker.so</code> <br /><br /> to the top of <code>~/.cedega/.winex_ver/winex-{version}/bin/winex3</code>, then run Cedega as you would normally (without <code>vglrun</code>.)  Since <code>vglrun</code> is not being used, it is necessary to use environment variables or the VirtualGL Configuration dialog to modify VirtualGL&rsquo;s configuration.</td>
    <td class="standard">The actual binary (WineX) which uses OpenGL is buried beneath several layers of Python and shell scripts.  The <code>LD_PRELOAD</code> variable does not get propagated down from the initial shell that invoked <code>vglrun</code>.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heretic II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;heretic2&nbsp;+set&nbsp;vid_ref&nbsp;glx</code></td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="standard">Java2D applications that use OpenGL</td>
    <td class="standard">Solaris/SPARC</td>
    <td class="standard">When VirtualGL is used in conjunction with Java v5.0 (also known as Java 1.5.0) to remotely display Java2D applications using the OpenGL pipeline (see above), certain Java2D applications will cause the OpenGL subsystem to crash with the following error: <br /><br /> <code>thread&nbsp;tries&nbsp;to&nbsp;access&nbsp;GL&nbsp;context&nbsp;current&nbsp;to&nbsp;another&nbsp;thread</code> <br /><br /> If you encounter this error, try setting the <code>SUN_OGL_IS_MT</code> environment variable to <code>1</code> and re-running the application.</td>
    <td class="standard">Java 5.0 should call <code>glXInitThreadsSUN()</code> since it is using multiple OpenGL threads, but it doesn&rsquo;t.  Purely by chance, this doesn&rsquo;t cause any problems when the application is displayed locally.  However, VirtualGL changes things up enough that the luck runs out.  This issue does not exist in Java 6.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Pro/ENGINEER Wildfire v2.0</td>
    <td class="standard">Solaris/SPARC</td>
    <td class="standard">Add <br /><br /> <code>graphics&nbsp;opengl</code> <br /><br /> to <code>~/config.pro</code>.  You may also need to set the <code>VGL_XVENDOR</code> environment variable to <code>&quot;Sun&nbsp;Microsystems,&nbsp;Inc.&quot;</code> if you are running Pro/ENGINEER 2.0 over a remote X connection to a Linux or Windows VirtualGL client.</td>
    <td class="standard">Pro/E 2.0 for Solaris will disable OpenGL if it detects a remote connection to a non-Sun X server.</td>
  </tr>
</table>
</div>


<p><br /></p>

<hr class="break" />


<h1 id="hd0014"><a name="file014"></a>14&nbsp;Advanced OpenGL Features</h1>

<p><a name="Advanced_OpenGL"></a></p>


<h2 id="hd0014001">14.1&nbsp;Stereographic Rendering</h2>

<p>Stereographic rendering is a feature of OpenGL that creates separate 
rendering buffers for the left and right eyes and allows the application 
to render a different image into each buffer.  How the stereo images are 
subsequently displayed depends on the particulars of the 3D hardware and 
the user&rsquo;s environment.  VirtualGL can support stereographic 
applications in one of two ways: (1) by sending the stereo image pairs 
to the client to be displayed in stereo by the client&rsquo;s 3D 
graphics card, or (2) by combining each stereo image pair into a single 
anaglyph that can be viewed with traditional red/cyan 3D glasses.</p>


<h3 id="hd0014001001">14.1.1&nbsp;Quad-Buffered Stereo</h3>

<p>The name &ldquo;quad-buffered&rdquo; stereo derives from the fact that 
OpenGL uses four buffers (left front, right front, left back, and right 
back) to support stereographic rendering with double buffering.  3D 
graphics cards with quad-buffered stereo capabilities generally provide 
some sort of synchronization signal that can be used to control various 
types of active stereo 3D glasses.  Some also support &ldquo;passive 
stereo&rdquo;, which requires displaying the left and right eye buffers 
to different monitor outputs. VirtualGL supports true quad-buffered 
stereo by rendering the stereo images on the server and sending the 
image pairs across the network to be displayed by a 3D graphics card on 
the client.</p>

<p>In most cases, VirtualGL does not require a 3D graphics card to be 
present in the client machine.  However, a 3D graphics card is required 
to display stereo image pairs, so such a card must be present in any 
client machine that will use VirtualGL&rsquo;s quad-buffered stereo 
feature.  Since the 3D graphics card is only being used to draw images, 
it need not necessarily be a high-end card. Generally, the least 
expensive 3D graphics card that has stereo capabilities will work fine 
in a VirtualGL client machine.</p>

<p>The VirtualGL server must also have a 3D graphics card that supports 
stereo, since this is the only way that VirtualGL can obtain a stereo 
Pbuffer.  When an application tries to render something in stereo, 
VirtualGL will (by default) use quad-buffered stereo rendering if:</p>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        The client supports OpenGL (Exceed 3D is required for Windows clients)
    </li>
    <li class="Itemize-1 Itemize asterisk">
        The client has stereo rendering capabilities
    </li>
    <li class="Itemize-1 Itemize asterisk">
        The server has stereo rendering capabilities
    </li>
</ul>

<p>If one or more of these is not true, then VirtualGL will fall back to 
using anaglyphic stereo (see below.)  It is usually necessary to 
explicitly enable stereo in the graphics driver configuration for both 
the client and server machines.  The 
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0075"></a> 
section below lists a way to verify that both client and server have 
stereo visuals available.</p>

<p>In quad-buffered mode, VirtualGL reads back both eye buffers on the 
server and sends the contents as a pair of compressed images (one for 
each eye) to the VirtualGL Client.  The VirtualGL Client then 
decompresses both images and draws them as a single stereo frame to the 
client machine&rsquo;s X display using <code>glDrawPixels()</code>.  It 
should thus be no surprise that enabling quad-buffered stereo in 
VirtualGL decreases performance by 50% or more and uses twice the 
network bandwidth to maintain the same frame rate as mono.</p>

<p>Quad-buffered stereo requires the VGL Image Transport.  If any other 
image transport is used, then VGL will fall back to anaglyphic stereo 
mode.</p>


<h3 id="hd0014001002">14.1.2&nbsp;Anaglyphic Stereo</h3>

<p>Anaglyphic stereo is the type of stereographic display used by old 3D 
movies. It generally relies on a set of 3D glasses consisting of red 
transparency film over the left eye and cyan transparency film over the 
right eye.  To generate a 3D anaglyph, the red color data from the left 
eye buffer is combined with the green and blue color data from the right 
eye buffer, thus allowing a single monographic image to contain stereo 
data.  From the point of view of VirtualGL, an anaglyphic image is the 
same as a monographic image, so anaglyphic stereo images can be sent 
using any image transport to any type of client, regardless of the 
client&rsquo;s capabilities.</p>

<p>VirtualGL uses anaglyphic stereo if it detects that an application has 
rendered something in stereo but quad-buffered stereo is not available, 
either because the client doesn&rsquo;t support it or because a 
transport other than the VGL Image Transport is being used.  Anaglyphic 
stereo provides a cheap and easy way to view stereographic applications 
in X proxies and on clients that do not support quad-buffered stereo.  
Additionally, anaglyphic stereo performs much faster than quad-buffered 
stereo, since it does not require sending twice the data to the client.</p>

<p>As with quad-buffered stereo, anaglyphic stereo requires that the 
VirtualGL server have stereo rendering capabilities.  However, 
anaglyphic stereo does not require any 3D rendering capabilities (stereo 
or otherwise) on the client machine.</p>


<h3 id="hd0014001003">14.1.3&nbsp;Selecting a Stereo Mode</h3>

<p>A particular stereo mode can be selected by setting the 
<code>VGL_STEREO</code> environment variable or by using the 
<code>-st</code> argument to <code>vglrun</code>.  See Section 
<a href="#VGL_STEREO" class="ref">17.1</a> for more details.</p>


<h2 id="hd0014002">14.2&nbsp;Transparent Overlays</h2>

<p>Transparent overlays have similar requirements and restrictions as 
quad-buffered stereo.  In this case, VirtualGL completely bypasses its 
own GLX faker and uses indirect OpenGL rendering to render the 
transparent overlay on the client machine&rsquo;s 3D graphics card.  The 
underlay is still rendered on the server, as always.  Using indirect 
rendering to render the overlay is unfortunately necessary, because 
there is no reliable way to draw to an overlay using 2D (X11) functions, 
there are severe performance issues (on some cards) with using 
<code>glDrawPixels()</code> to draw to the overlay, and there is no 
reasonable way to composite the overlay and underlay on the VirtualGL 
server.</p>

<p>The use of overlays is becoming more and more infrequent, and when they 
are used, it is generally only for drawing small, simple, static shapes 
and text. We have found that it is often faster to ship the overlay 
geometry over to the client rather than to render it as an image and 
send the image.  So even if it were possible to implement overlays 
without using indirect rendering, it is likely that indirect rendering 
of overlays would still be the fastest approach for most applications.</p>

<p>As with quad-buffered stereo, overlays must be explicitly enabled in the 
graphics driver configuration.  In the case of overlays, however, they 
need only be supported and enabled on the client machine.  Some graphics 
drivers are known to disallow using both quad-buffered stereo and 
overlays at the same time.</p>

<p>Indexed color (8-bit) overlays have been tested and are known to work 
with VirtualGL.  True color (24-bit) overlays work, in theory, but have 
not been tested.  Use <code>glxinfo</code> (see 
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0076"></a> 
below) to verify whether your client&rsquo;s X display supports overlays 
and whether they are enabled.  In Exceed 3D, make sure that the 
&ldquo;Overlay Support&rdquo; option is checked in the &ldquo;Exceed 3D 
and GLX&rdquo; applet:</p>

<p><img src="exceed6.png" alt="exceed6" class="inline" id="imgid_4" name="imgid_4"/></p>

<div class="important"><p class="important">
Overlays do not work with X proxies (including TurboVNC.)  VirtualGL must be displaying to a &ldquo;real&rdquo; X server.
</p></div>


<h2 id="hd0014003">14.3&nbsp;Indexed (PseudoColor) Rendering</h2>

<p>In a PseudoColor visual, each pixel is represented by an index which 
refers to a location in a color table.  The color table stores the 
actual color values (256 of them in the case of 8-bit PseudoColor) which 
correspond to each index. An application merely tells the X server which 
color index to use when drawing, and the X server takes care of mapping 
that index to an actual color from the color table.  OpenGL allows for 
rendering to Pseudocolor visuals, and it does so by being intentionally 
ignorant of the relationship between indices and actual colors.  As far 
as OpenGL is concerned, each color index value is just a meaningless 
number, and it is only when the final image is drawn by the X server 
that these numbers take on meaning.  As a result, many pieces of 
OpenGL&rsquo;s core functionality either have undefined behavior or do 
not work at all with PseudoColor rendering.  PseudoColor rendering used 
to be a common technique for visualizing scientific data, because such 
data often only contained 8 bits per sample to begin with.  Applications 
could manipulate the color table to allow the user to dynamically 
control the relationship between sample values and colors.  As more and 
more graphics cards drop support for PseudoColor rendering, however, the 
applications which use it are becoming a vanishing breed.</p>

<p>VirtualGL supports PseudoColor rendering if a PseudoColor visual is 
available on the 2D X server or X proxy.  A PseudoColor visual need not 
be present on the application server.  On the application server, 
VirtualGL uses the red channel of a standard RGB Pbuffer to store the 
color index.  Upon receiving an end of frame trigger, VirtualGL reads 
back the red channel of the Pbuffer and uses <code>XPutImage()</code> to 
draw the color indices into the appropriate X window.  To put this 
another way, PseudoColor rendering in VirtualGL always uses the X11 
Image Transport.  However, since there is only 1 byte per pixel in a 
PseudoColor &ldquo;image&rdquo;, the images can still be sent to the 
client reasonably quickly even though they are uncompressed.</p>

<p>VirtualGL&rsquo;s PseudoColor rendering mode works with X proxies 
(including TurboVNC), provided that the X proxy is configured to use an 
8-bit color depth. Note, however, that VNC cannot provide both 
PseudoColor and TrueColor visuals at the same time.</p>


<h2 id="hd0014004">14.4&nbsp;Troubleshooting</h2>

<p><a name="Troubleshooting"></a></p>

<p>VirtualGL includes a modified version of <code>glxinfo</code> that can 
be used to determine whether or not the client and server have stereo, 
overlay, or Pseudocolor visuals enabled.</p>

<p>Run one of the following command sequences on the VirtualGL server to 
determine whether the server has a suitable visual for stereographic 
rendering:</p>

<dl class="Description">
    <dt class="Description-1 Description">Solaris VirtualGL servers (using GLP)</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-d&nbsp;{glp_device}&nbsp;-v
</pre>

    </dd>
    <dt class="Description-1 Description">Linux and Solaris VirtualGL servers (not using GLP)</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c&nbsp;-v
</pre>

    </dd>
</dl>

<p>One or more of the visuals should say &ldquo;stereo=1&rdquo; and should 
list &ldquo;Pbuffer&rdquo; as one of the &ldquo;Drawable Types.&rdquo;</p>

<p>Run the following command sequence on the VirtualGL server to determine 
whether the X display on the client has a suitable visual for 
stereographic rendering, transparent overlays, or Pseudocolor.</p>

<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-v
</pre>

<p>In order to use stereo, one or more of the visuals should say 
&ldquo;stereo=1&rdquo;. In order to use transparent overlays, one or 
more of the visuals should say &ldquo;level=1&rdquo;, should list a 
&ldquo;Transparent Index&rdquo; (non-transparent visuals will say 
&ldquo;Opaque&rdquo; instead), and should have a class of 
&ldquo;PseudoColor.&rdquo;  In order to use PseudoColor (indexed) 
rendering, one of the visuals should have a class of 
&ldquo;PseudoColor.&rdquo;</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd0015"><a name="file015"></a>15&nbsp;Performance Measurement</h1>

<p><a name="Perf_Measurement"></a></p>


<h2 id="hd0015001">15.1&nbsp;VirtualGL&rsquo;s Built-In Profiling System</h2>

<p>The easiest way to uncover bottlenecks in VirtualGL&rsquo;s image 
pipelines is to set the <code>VGL_PROFILE</code> environment variable to 
<code>1</code> on both server and client (passing an argument of 
<code>+pr</code> to <code>vglrun</code> on the server has the same 
effect.)  This will cause VirtualGL to measure and report the throughput 
of the various stages in the pipeline.  For example, here are some 
measurements from a dual Pentium 4 server communicating with a Pentium 
III client on a 100 Megabit LAN:</p>

<dl class="Description">
    <dt class="Description-1 Description">Server</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
Readback&nbsp;&nbsp;&nbsp;-&nbsp;43.27&nbsp;Mpixels/sec&nbsp;-&nbsp;34.60&nbsp;fps
Compress&nbsp;0&nbsp;-&nbsp;33.56&nbsp;Mpixels/sec&nbsp;-&nbsp;26.84&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.02&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.41&nbsp;fps&nbsp;-&nbsp;10.19&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
    <dt class="Description-1 Description">Client</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
Decompress&nbsp;-&nbsp;10.35&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;8.28&nbsp;fps
Blit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;35.75&nbsp;Mpixels/sec&nbsp;-&nbsp;28.59&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.00&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.40&nbsp;fps&nbsp;-&nbsp;10.18&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
</dl>

<p>The total throughput of the pipeline is 8.0 Megapixels/sec, or 6.4 
frames/sec, indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels in 
size (a little less than 1280 x 1024 pixels.)  The readback and compress 
stages, which occur in parallel on the server, are obviously not slowing 
things down, and we&rsquo;re only using 1/10 of our available network 
bandwidth.  Looking at the client, however, we discover that its slow 
decompression speed (10.35 Megapixels/second) is the primary bottleneck.  
Decompression and blitting on the client cannot be done in parallel, so 
the aggregate performance is the harmonic mean of the decompression and 
blitting rates:  <em>[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec</em>. In 
this case, we could improve the performance of the whole system by 
simply using a client with a faster CPU.</p>


<h2 id="hd0015002">15.2&nbsp;Frame Spoiling</h2>

<p><a name="Frame_Spoiling"></a></p>

<p>By default, VirtualGL will only send a frame to the client if the client 
is ready to receive it.  If a rendered frame arrives at the 
server&rsquo;s queue and there are frames waiting in the queue to be 
processed, then those unprocessed frames are dropped 
(&ldquo;spoiled&rdquo;) and the new frame is promoted to the head of the 
queue.  This prevents a backlog of frames on the server, which would 
cause a perceptible delay in the responsiveness of interactive 
applications.  However, when running non-interactive applications, 
particularly benchmarks, frame spoiling should always be disabled.   
With frame spoiling disabled, the server will render frames only as 
quickly as VirtualGL can send those frames to the client, which will 
conserve server resources as well as allow OpenGL benchmarks to 
accurately measure the frame rate of the VirtualGL system.  With frame 
spoiling enabled, OpenGL benchmarks will report meaningless data, since 
the rate at which the server can render frames is decoupled from the 
rate at which VirtualGL can send those frames to the client.</p>

<p>In a VNC environment, there is another layer of frame spoiling, since 
the server only sends updates to the client when the client requests 
them.  Thus, even if frame spoiling is disabled in VirtualGL, OpenGL 
benchmarks will still report inaccurate data if they are run in a VNC 
session.  TCBench, described below, provides a limited solution to this 
problem.</p>

<p>To disable frame spoiling, set the <code>VGL_SPOIL</code> environment 
variable to <code>0</code> on the VirtualGL server or pass an argument 
of <code>-sp</code> to <code>vglrun</code>.  See Section 
<a href="#VGL_SPOIL" class="ref">17.1</a> for more details.</p>


<h2 id="hd0015003">15.3&nbsp;VirtualGL Diagnostic Tools</h2>

<p>VirtualGL includes several tools which can be useful in diagnosing 
performance problems with the system.</p>


<h3 id="hd0015003001">NetTest</h3>

<p>NetTest is a network benchmark that uses the same network I/O classes as 
VirtualGL.  It can be used to test the latency and throughput of any 
TCP/IP connection, with or without SSL encryption.  <code>nettest</code> 
can be found in <code>/opt/VirtualGL/bin</code> on Linux/Mac/Solaris 
VirtualGL installations or in 
<code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code> on 
Windows installations.</p>

<p>To use NetTest, first start up the NetTest server on one end of the 
connection:</p>

<pre class="verbatim">
nettest&nbsp;-server&nbsp;[-ssl]
</pre>

<p>(Use <code>-ssl</code> if you want to test the performance of SSL 
encryption over this particular connection.)</p>

<p>Next, start the client on the other end of the connection:</p>

<pre class="verbatim">
nettest&nbsp;-client&nbsp;{server}&nbsp;[-ssl]
</pre>

<p>(Replace <em><code>{server}</code></em> with the hostname or IP address 
of the machine where the NetTest server is running.  Use 
<code>-ssl</code> if the NetTest server is running in SSL mode.)</p>

<p>The NetTest client will produce output similar to the following:</p>

<pre class="verbatim">
TCP&nbsp;transfer&nbsp;performance&nbsp;between&nbsp;localhost&nbsp;and&nbsp;{server}:

Transfer&nbsp;size&nbsp;&nbsp;1/2&nbsp;Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput
(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(msec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MB/sec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Mbits/sec)
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093402&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.010210&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.085651
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087308&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.021846&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183259
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087504&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.043594&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.365697
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.088105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.086595&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.726409
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.090090&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.169373&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.420804
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093893&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325026&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.726514
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.102289&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.596693&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.005424
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.118493&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.030190&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.641863
256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.146603&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.665318&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.969704
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.205092&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.380790&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.971514
1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.996542&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25.136815
2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.476611&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.097946&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;34.376065
4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.639502&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.108265&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;51.239840
8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.033596&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.558565&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63.405839
16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.706110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.158259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76.825049
32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.089896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.113608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84.839091
65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.909509&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.576174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88.719379
131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.453894&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.913319&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;91.547558
262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22.616389&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.053931&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;92.727094
524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44.882406&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.140223&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.450962
1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89.440702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.180592&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.789603
2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;178.536997&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.202160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.970529
4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;356.754396&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.212195&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;94.054712
</pre>

<p>We can see that the throughput peaks at about 94 megabits/sec, which is 
pretty good for a 100 Megabit connection.  We can also see that, for 
small transfer sizes, the round-trip time is dominated by latency.  The 
&ldquo;latency&rdquo; is the same thing as the one-way (1/2 round-trip) 
transit time for a zero-byte packet, which is about 93 microseconds in 
this case.</p>


<h3 id="hd0015003002">CPUstat</h3>

<p>CPUstat is available only in the VirtualGL Linux packages and is located 
in the same place as NetTest (<code>/opt/VirtualGL/bin</code>.)  It 
measures the average, minimum, and peak CPU usage for all processors 
combined and for each processor individually.  On Windows, this same 
functionality is provided in the Windows Performance Monitor, which is 
part of the operating system.  On Solaris, the same data can be obtained 
through <code>vmstat</code>.</p>

<p>CPUstat measures the CPU usage over a given sample period (a few 
seconds) and continuously reports how much the CPU was utilized since 
the last sample period.  Output for a particular sample looks something 
like this:</p>

<pre class="verbatim">
ALL&nbsp;:&nbsp;&nbsp;51.0&nbsp;(Usr=&nbsp;47.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;3.5)&nbsp;/&nbsp;Min=&nbsp;47.4&nbsp;Max=&nbsp;52.8&nbsp;Avg=&nbsp;50.8
cpu0:&nbsp;&nbsp;20.5&nbsp;(Usr=&nbsp;19.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;1.0)&nbsp;/&nbsp;Min=&nbsp;19.4&nbsp;Max=&nbsp;88.6&nbsp;Avg=&nbsp;45.7
cpu1:&nbsp;&nbsp;81.5&nbsp;(Usr=&nbsp;75.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;6.0)&nbsp;/&nbsp;Min=&nbsp;16.6&nbsp;Max=&nbsp;83.5&nbsp;Avg=&nbsp;56.3
</pre>

<p>The first column indicates what percentage of time the CPU was active 
since the last sample period (this is then broken down into what 
percentage of time the CPU spent running user, nice, and system/kernel 
code.)  &ldquo;ALL&rdquo; indicates the average utilization across all 
CPUs since the last sample period.  &ldquo;Min&rdquo;, 
&ldquo;Max&rdquo;, and &ldquo;Avg&rdquo; indicate a running minimum, 
maximum, and average of all samples since CPUstat was started.</p>

<p>Generally, if an application&rsquo;s CPU usage is fairly steady, you can 
run CPUstat for a bit and wait for the Max. and Avg. for the 
&ldquo;ALL&rdquo; category to stabilize, then that will tell you what 
the application&rsquo;s peak and average % CPU utilization is.</p>


<h3 id="hd0015003003">TCBench</h3>

<p>TCBench was born out of the need to compare VirtualGL&rsquo;s 
performance to that of other thin client packages, some of which had 
frame spoiling features that couldn&rsquo;t be disabled.  TCBench 
measures the frame rate of a thin client system as seen from the 
client&rsquo;s point of view.  It does this by attaching to one of the 
client windows and continuously reading back a small area at the center 
of the window.  While this may seem to be a somewhat non-rigorous test, 
experiments have shown that if care is taken to ensure that the 
application is updating the center of the window on every frame (such as 
in a spin animation), TCBench can produce quite accurate results.  It 
has been sanity checked with VirtualGL&rsquo;s internal profiling 
mechanism and with a variety of system-specific techniques, such as 
monitoring redraw events on the client&rsquo;s windowing system.</p>

<p>TCBench can be found in <code>/opt/VirtualGL/bin</code> on 
Linux/Mac/Solaris or in 
<code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code> on 
Windows.  Run <code>tcbench</code> from the command line, and it will 
prompt you to click in the window you want to benchmark.   That window 
should already have an automated animation of some sort running before 
you launch TCBench.  Note that GLXSpheres (see below) is an ideal 
benchmark to use with TCBench, since GLXSpheres draws a new sphere to 
the center of its window on every frame.</p>

<p>TCBench can also be used to measure the frame rate of applications that 
are running on the local display, although for extremely fast 
applications (those that exceed 40 fps on the local display), you may 
need to increase the sampling rate of TCBench to get accurate results.  
The default sampling rate of 50 samples/sec should be fine for measuring 
the throughput of VirtualGL and other thin client systems.</p>

<pre class="verbatim">
tcbench&nbsp;-?
</pre>

<p>lists the relevant command line switches, which can be used to adjust 
the benchmark time, the sampling rate, and the x and y offset of the 
sampling area within the window.</p>


<h3 id="hd0015003004">GLXSpheres</h3>

<p>GLXSpheres is a benchmark which produces very similar images to 
NVidia&rsquo;s (long discontinued) SphereMark benchmark.  Back in the 
early days of VirtualGL&rsquo;s existence, it was discovered (quite by 
accident) that SphereMark was a pretty good test of VirtualGL&rsquo;s 
end-to-end performance, because that benchmark generated images with 
about the same proportion of solid color and similar frequency 
components to the images generated by volume visualization applications.</p>

<p>Thus, the goal of GLXSpheres was to create an open source Unix version 
of SphereMark (the original SphereMark was for Windows only) completely 
from scratch.  GLXSpheres does not use any code from the original 
benchmark, but it does attempt to mimic the image output of the original 
as closely as possible.  GLXSpheres lacks some of the advanced rendering 
features of the original, such as the ability to use vertex arrays, but 
since it was primarily designed as a benchmark for VirtualGL, display 
lists are more than fast enough for that purpose.</p>

<p>GLXSpheres has some additional modes which its predecessor lacked, modes 
which are designed specifically to test the performance of various 
VirtualGL features:</p>

<dl class="Description">
    <dt class="Description-1 Description">Stereographic rendering (<code>glxspheres&nbsp;-s</code>)</dt>
    <dd class="Description-1 Description">
    </dd>
    <dt class="Description-1 Description">Color index rendering (<code>glxspheres&nbsp;-c</code>)</dt>
    <dd class="Description-1 Description">
        In color index mode, GLXSpheres will draw the spheres using an 8-bit 
        color map and will change the color map periodically.
    </dd>
    <dt class="Description-1 Description">Overlay rendering (<code>glxspheres&nbsp;-o</code>)</dt>
    <dd class="Description-1 Description">
        This renders text, a moving crosshair cursor, and a block of pixels to 
        an 8-bit transparent overlay while animating the spheres on the 
        underlay.  The color map of the overlay is changed periodically.
    </dd>
    <dt class="Description-1 Description">Immediate mode rendering (<code>glxspheres&nbsp;-m</code>)</dt>
    <dd class="Description-1 Description">
        Want to really see the benefit of VirtualGL?  Run 
        <code>glxspheres&nbsp;-m</code> over a remote X connection, then run 
        <code>vglrun&nbsp;-sp&nbsp;glxspheres&nbsp;-m</code> over the same 
        connection and compare. Immediate mode does not use display lists, so 
        when immediate mode OpenGL is rendered indirectly (over a remote X 
        connection), this causes every OpenGL command to be sent as a separate 
        network request to the X server &hellip; on every frame.  Many 
        applications cannot use display lists, because the geometry they are 
        rendering is dynamic, so this models how such applications might perform 
        when displayed remotely without VirtualGL.
    </dd>
    <dt class="Description-1 Description">Interactive mode (<code>glxspheres&nbsp;-i</code>)</dt>
    <dd class="Description-1 Description">
        In interactive mode, GLXSpheres will wait to draw a frame until it 
        receives a mouse event.  Continuously dragging the mouse in the window 
        should produce a steady frame rate, and this frame rate is a reasonable 
        model of the frame rate that you can achieve when running interactive 
        applications in VirtualGL.  Comparing this interactive frame rate 
        (<code>vglrun&nbsp;glxspheres&nbsp;-i</code>) with the non-interactive 
        frame rate (<code>vglrun&nbsp;-sp&nbsp;glxspheres</code>) allows you to 
        quantify the effect of X latency on the performance of interactive 
        applications in a VirtualGL environment.
    </dd>
</dl>

<p>GLXSpheres is installed in <code>/opt/VirtualGL/bin</code> on Linux and 
Solaris VirtualGL servers.  64-bit VirtualGL packages contain both a 
32-bit version (<code>glxpheres</code>) and a 64-bit version 
(<code>glxspheres64</code>.)</p>

<p><br /></p>

<hr class="break" />


<h1 id="hd0016"><a name="file016"></a>16&nbsp;The VirtualGL Configuration Dialog</h1>

<p><a name="Config_Dialog"></a></p>

<p>Several of VirtualGL&rsquo;s configuration parameters can be changed on 
the fly once a 3D application has been started.  This is accomplished by 
using the VirtualGL Configuration dialog, which can be popped up by 
holding down the <code>CTRL</code> and <code>SHIFT</code> keys and 
pressing the <code>F9</code> key while any one of the 3D 
application&rsquo;s windows is active.  This displays the following 
dialog box:</p>

<p><img src="configdialog.gif" alt="configdialog" class="inline" id="imgid_5" name="imgid_5"/></p>

<p>You can use this dialog to adjust various image compression and display 
parameters in VirtualGL.  Changes are reflected immediately in the 
application.</p>

<dl class="Description">
    <dt class="Description-1 Description">Image Compression (Transport)</dt>
    <dd class="Description-1 Description">
        This is a drop-down gadget with the following options: <br /><br /> 
        <em>None (X11 Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=proxy</code>. This option can be activated at any 
        time, regardless of which transport was active when VirtualGL started. 
        <br /><br /> <em>JPEG (VGL Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=jpeg</code>.  This option is only available if the 
        VGL Image Transport was active when VirtualGL started. <br /><br /> 
        <em>RGB (VGL Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=rgb</code>.  This option is only available if the VGL 
        Image Transport was active when VirtualGL started. <br /><br /> <em>DPCM 
        (Sun Ray Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=sr</code>. This option is only available if the Sun 
        Ray Image Transport was active when VirtualGL started. <br /><br /> 
        <em>RGB (Sun Ray Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=srrgb</code>. This option is only available if the 
        Sun Ray Image Transport was active when VirtualGL started. <br /><br /> 
        <em>YUV (Sun Ray Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=sryuv</code>. This option is only available if the 
        Sun Ray Image Transport was active when VirtualGL started. <br /><br /> 
        See Section <a href="#VGL_COMPRESS" class="ref">17.1</a> for more 
        information about the <code>VGL_COMPRESS</code> configuration option and 
        its various parameters.
    </dd>
    <dt class="Description-1 Description">Chrominance Subsampling</dt>
    <dd class="Description-1 Description">
        This drop-down gadget is active only when using JPEG, Sun Ray DPCM, or 
        Sun Ray YUV compression.  It has the following options: <br /><br /> 
        <em>Grayscale</em> : equivalent to setting 
        <code>VGL_SUBSAMP=gray</code>.  Available only with JPEG compression. 
        <br /><br /> <em>1X</em> : equivalent to setting 
        <code>VGL_SUBSAMP=1x</code> <br /><br /> <em>2X</em> : equivalent to 
        setting <code>VGL_SUBSAMP=2x</code> <br /><br /> <em>4X</em> : 
        equivalent to setting <code>VGL_SUBSAMP=4x</code> <br /><br /> 
        <em>8X</em> : equivalent to setting <code>VGL_SUBSAMP=8x</code>.  
        Available only with Sun Ray DPCM or YUV compression. <br /><br /> 
        <em>16X</em> : equivalent to setting <code>VGL_SUBSAMP=16x</code>.  
        Available only with Sun Ray DPCM or YUV compression. <br /><br /> See 
        Section <a href="#VGL_SUBSAMP" class="ref">17.1</a> for more information 
        about the <code>VGL_SUBSAMP</code> configuration option and its various 
        parameters.
    </dd>
    <dt class="Description-1 Description">JPEG Image Quality</dt>
    <dd class="Description-1 Description">
        This slider gadget is active only when using JPEG compression.  It is 
        the equivalent of setting <code>VGL_QUAL</code>.  	See Section 
        <a href="#VGL_QUAL" class="ref">17.1</a> for more information about the 
        <code>VGL_QUAL</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Connection Profile</dt>
    <dd class="Description-1 Description">
        This drop-down gadget is active only if the VGL Image Transport was 
        active when VirtualGL started.  It has the following options: 
        <br /><br /> <em>Low Qual (Low-Bandwidth Network)</em> : Sets the image 
        compression type to JPEG (VGL Transport), sets the Chrominance 
        Subsampling to 4X, and sets the JPEG Image Quality to 30. <br /><br /> 
        <em>Medium Qual</em> : Sets the image compression type to JPEG	(VGL 
        Transport), sets the Chrominance Subsampling to 2X, and sets the JPEG 
        Image Quality to 80. <br /><br /> <em>High Qual (High-Bandwidth 
        Network)</em> : Sets the image compression type to JPEG (VGL Transport), 
        sets the Chrominance Subsampling to 1X, and sets the JPEG Image Quality 
        to 95.
    </dd>
    <dt class="Description-1 Description">Gamma Correction Factor</dt>
    <dd class="Description-1 Description">
        This floating point input gadget is the equivalent of setting 
        <code>VGL_GAMMA</code>.  If using a gamma-corrected visual (SPARC 
        clients only), then this gadget has no effect.  Otherwise, it enables 
        VirtualGL&rsquo;s internal gamma correction system with the specified 
        gamma correction factor. See Section 
        <a href="#VGL_GAMMA" class="ref">17.1</a> for more information about the 
        <code>VGL_GAMMA</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Frame Spoiling</dt>
    <dd class="Description-1 Description">
        This toggle button is the equivalent of setting <code>VGL_SPOIL</code>.  
        See Section <a href="#Frame_Spoiling" class="ref">15.2</a> and Section 
        <a href="#VGL_SPOIL" class="ref">17.1</a> for more information about the 
        <code>VGL_SPOIL</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Interframe Comparison</dt>
    <dd class="Description-1 Description">
        This toggle button is the equivalent of setting 
        <code>VGL_INTERFRAME</code>.  See Section 
        <a href="#VGL_INTERFRAME" class="ref">17.1</a> for more information 
        about the <code>VGL_INTERFRAME</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Stereographic Rendering Method</dt>
    <dd class="Description-1 Description">
        This drop-down gadget has the following options: <br /><br /> <em>Send 
        Left Eye Only</em> : equivalent to setting <code>VGL_STEREO=left</code>. 
        <br /><br /> <em>Send Right Eye Only</em> : equivalent to setting 
        <code>VGL_STEREO=right</code> <br /><br /> <em>Quad-Buffered (if 
        available)</em> : equivalent to setting <code>VGL_STEREO=quad</code> 
        <br /><br /> <em>Anaglyphic (Red/Cyan)</em> : equivalent to setting 
        <code>VGL_STEREO=rc</code> <br /><br /> See Section 
        <a href="#VGL_STEREO" class="ref">17.1</a> for more information about 
        the <code>VGL_STEREO</code> configuration option and its various 
        parameters.
    </dd>
    <dt class="Description-1 Description">Limit Frames/second</dt>
    <dd class="Description-1 Description">
        This floating point input gadget is the equivalent of setting 
        <code>VGL_FPS</code>.  See Section 
        <a href="#VGL_FPS" class="ref">17.1</a> for more information about the 
        <code>VGL_FPS</code> configuration option.
    </dd>
</dl>

<p>You can set the <code>VGL_GUI</code> environment variable to change the 
key sequence used to pop up the VirtualGL Configuration dialog.  If the 
default of <code>CTRL-SHIFT-F9</code> is not suitable, then set 
<code>VGL_GUI</code> to any combination of <code>ctrl</code>, 
<code>shift</code>, <code>alt</code>, and one of 
<code>f1,&nbsp;f2,...,&nbsp;f12</code> (these are not case sensitive.)  
For example:</p>

<pre class="verbatim">
export&nbsp;VGL_GUI=CTRL-F9
</pre>

<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code> is 
pressed.</p>

<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code> to 
<code>none</code>.</p>

<div class="important"><p class="important">
VirtualGL monitors the application&rsquo;s X event loop to determine whenever a particular key sequence has been pressed.  If an application is not monitoring key press events in its X event loop, then the VirtualGL Configuration dialog might not pop up at all.  There is unfortunately no workaround for this, but it should be a rare occurrence.
</p></div>

<p><br /></p>

<hr class="break" />


<h1 id="hd0017"><a name="file017"></a>17&nbsp;Advanced Configuration</h1>

<p><a name="Advanced_Configuration"></a></p>


<h2 id="hd0017001">17.1&nbsp;Server Settings</h2>

<p>You can control the operation of the VirtualGL faker in four different 
ways. Each method of configuration takes precedence over the previous 
method:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Setting a configuration environment variable globally (for instance, in 
        <code>/etc/profile</code>)
    </li>
    <li class="Ordered-1 Ordered">
        Setting a configuration environment variable on a per-user basis (for 
        instance, in <code>~/.bashrc</code>)
    </li>
    <li class="Ordered-1 Ordered">
        Setting a configuration environment variable only for the current shell 
        session (for instance, <code>export&nbsp;VGL_XXX={whatever}</code>)
    </li>
    <li class="Ordered-1 Ordered">
        Passing a configuration option as an argument to <code>vglrun</code>.  
        This effectively overrides any previous environment variable setting 
        corresponding to that configuration option.
    </li>
</ol>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_CLIENT&nbsp;=&nbsp;</code><em><code>{c}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-cl&nbsp;</code><em><code>{c}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{c}</code></em> = the hostname or IP address of the VirtualGL client machine or Sun Ray server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray, VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically set by <code>vglconnect</code> or <code>vglrun</code></td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When using the VGL Image Transport, <code>VGL_CLIENT</code> should be 
        set to the hostname or IP address of the machine on which 
        <code>vglclient</code> is running.  When using the Sun Ray Image 
        Transport, <code>VGL_CLIENT</code> should be set to the hostname or IP 
        address of the Sun Ray server.  Normally, <code>VGL_CLIENT</code> is set 
        automatically by the <code>vglconnect</code> or <code>vglrun</code> 
        script, so don&rsquo;t override it unless you know what you&rsquo;re 
        doing.
    </dd>
</dl>

<p><a name="VGL_COMPRESS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_COMPRESS&nbsp;=&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;sr&nbsp;|&nbsp;srrgb&nbsp;|&nbsp;sryuv</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-c&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;sr&nbsp;|&nbsp;srrgb&nbsp;|&nbsp;sryuv</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Set image transport and image compression type</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">(See description)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
         <em>proxy</em> = Send images uncompressed using the X11 Image 
         Transport.  This is useful when displaying to a local 2D X server or X 
         proxy (see Section 
         <a href="#X11_Proxy_Usage_Local" class="ref">8.1</a>.) <br /><br /> 
         <em>jpeg</em> = Compress images using JPEG and send using the VGL Image 
         Transport. This is useful when displaying to a remote 2D X server (see 
         Chapter <a href="#VGL_Image_Transport_Usage" class="ref">7</a>.) 
         <br /><br /> <em>rgb</em> = Encode images as uncompressed RGB and send 
         using the VGL Image Transport.  This is useful when displaying to a 
         remote 2D X server or X proxy across a very fast network (see Section 
         <a href="#X11_Proxy_Usage_Remote" class="ref">8.2</a>.) <br /><br /> 
         <em>sr</em> = Compress images using the Sun Ray default compression 
         method (DPCM) and send using the Sun Ray Image Transport.  This 
         requires that the proprietary Sun Ray plugin be installed on the 
         VirtualGL server. (see Chapter 
         <a href="#Sun_Ray_Usage" class="ref">9</a>.) <br /><br /> 
         <em>srrgb</em> = Encode images as uncompressed RGB and send using the 
         Sun Ray Image Transport.  This requires that the proprietary Sun Ray 
         plugin be installed on the VirtualGL server (see Chapter 
         <a href="#Sun_Ray_Usage" class="ref">9</a>.) <br /><br /> 
         <em>sryuv</em> = Encode images as uncompressed YUV	and send using the 
         Sun Ray Image Transport.  This requires that the proprietary Sun Ray 
         plugin be installed on the VirtualGL server (see Chapter 
         <a href="#Sun_Ray_Usage" class="ref">9</a>.) <br /><br /> If this 
         option is not specified, then the default is set as follows: 
         <br /><br /> If the 2D X server is a Sun Ray server and the Sun Ray 
         plugin is installed on the VirtualGL server, then VGL will default to 
         using <em>sr</em> compression.  VGL will fall back to using 
         <em>proxy</em> compression if, for any given frame, it is unable to 
         send the frame using the Sun Ray Image Transport.  This could occur if, 
         for example, the Sun Ray client is on a network that is not visible to 
         the VirtualGL server. <br /><br /> If the 2D X server is not a Sun Ray 
         server but the <code>DISPLAY</code> environment variable begins with 
         <code>:</code> or <code>unix:</code>, then VirtualGL assumes that the X 
         display connection is local and it defaults to using <em>proxy</em> 
         compression.  Otherwise, it defaults to <em>jpeg</em> compression.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_DISPLAY&nbsp;=&nbsp;</code><em><code>{d}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-d&nbsp;</code><em><code>{d}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{d}</code></em> = the X display or GLP device to use for 3D rendering</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">:0</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If the VirtualGL server has multiple 3D graphics cards and you want the 
        OpenGL rendering to be redirected to a display other than :0, then you 
        can set <code>VGL_DISPLAY=:1.0</code> or whatever.  This could be used, 
        for instance, to support many application instances on a beefy 
        multi-pipe application server. <br /><br /> <em>GLP mode (Solaris/SPARC 
        only):</em> <br /><br /> Setting this option to <code>glp</code> will 
        enable GLP mode and use the first framebuffer device listed in 
        <code>/etc/dt/config/GraphicsDevices</code> to perform 3D rendering.  
        You can also set this option to the pathname of a specific GLP device 
        (example: <code>/dev/fbs/jfb0</code>.)  See Section 
        <a href="#GLP_Usage" class="ref">5.1</a> for more details.
    </dd>
</dl>

<p><a name="VGL_FPS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_FPS&nbsp;=&nbsp;</code><em><code>{f}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-fps&nbsp;</code><em><code>{f}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Limit the client/server frame rate to <em><code>{f}</code></em> frames/second, where <em><code>{f}</code></em> is a floating point number &gt; 0.0</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">0.0 (No limit)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        This option prevents VirtualGL from sending frames at a rate faster than 
        the specified limit.  It can be used, for instance, as a crude way to 
        control network bandwidth or CPU usage in multi-user environments where 
        those resources are constrained. <br /><br /> If frame spoiling is 
        disabled, then this effectively limits the server&rsquo;s 3D rendering 
        frame rate as well.
    </dd>
</dl>

<p><a name="VGL_GAMMA"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GAMMA&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1&nbsp;|&nbsp;{g}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-g</code> / <code>+g</code> / <code>-gamma&nbsp;</code><em><code>{g}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable gamma correction and specify gamma correction factor</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard"><code>VGL_GAMMA=1</code> on Solaris/SPARC VGL servers, <code>VGL_GAMMA=0</code> otherwise</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        &ldquo;Gamma&rdquo; refers to the relationship between the intensity of 
        light which your computer&rsquo;s monitor is instructed to display and 
        the intensity which it actually displays.  The curve is an exponential 
        curve of the form <em>Y = X<sup>G</sup></em>, where X is between 0 and 
        1.  G is called the &ldquo;gamma&rdquo; of the monitor.  PC monitors and 
        TV&rsquo;s usually have a gamma of around 2.2. <br /><br /> Some of the 
        math involved in 3D rendering assumes a linear gamma (G = 1.0), so 
        technically speaking, 3D applications will not display with mathematical 
        correctness unless the pixels are &ldquo;gamma corrected&rdquo; to 
        counterbalance the non-linear response curve of the monitor.  However, 
        some systems do not have any form of built-in gamma correction, so the 
        applications developed for such systems have usually been designed to 
        display properly without gamma correction.  Gamma correction involves 
        passing pixels through a function of the form <em>X = 
        W<sup>1/G</sup></em>, where G is the &ldquo;gamma correction 
        factor&rdquo; and should be equal to the gamma of the monitor.  So the 
        final output is <em>Y = X<sup>G</sup> = (W<sup>1/G</sup>)<sup>G</sup> = 
        W</em>, which describes a linear relationship between the intensity of 
        the pixels drawn by the application and the intensity of the pixels 
        displayed by the monitor. <br /><br /> <em><code>VGL_GAMMA=1</code> or 
        <code>vglrun&nbsp;+g</code> : Enable gamma correction with default 
        settings</em> <br /><br /> This option tells VirtualGL to enable gamma 
        correction using the best available method.  If VirtualGL is remotely 
        displaying to a Solaris/SPARC X server which has gamma-corrected X 
        visuals, then VGL will attempt to assign one of these visuals to the 
        application.  This causes the 3D output of the application to be gamma 
        corrected by the factor specified in <code>fbconfig</code> on the client 
        machine (default: 2.22.)  Otherwise, if the 2D X server does not have 
        gamma-corrected X visuals or if the gamma-corrected visuals it has do 
        not match the application&rsquo;s needs, then VirtualGL performs gamma 
        correction internally and uses a default gamma correction factor of 
        2.22.  This option emulates the default behavior of OpenGL applications 
        running locally on SPARC machines. <br /><br /> 
        <em><code>VGL_GAMMA=0</code> or <code>vglrun&nbsp;-g</code> : Disable 
        gamma correction</em> <br /><br /> This option tells VGL not to use 
        gamma-corrected visuals, even if they are available on the 2D X server, 
        and disables VGL&rsquo;s internal gamma correction system as well.  This 
        emulates the default behavior of OpenGL applications running locally on 
        Linux or Solaris/x86 machines. <br /><br /> 
        <em><code>VGL_GAMMA=</code></em><code>{g}</code><em> or 
        <code>vglrun&nbsp;-gamma&nbsp;</code></em><code>{g}</code><em> : Enable 
        VGL&rsquo;s internal gamma correction system with a gamma correction 
        factor of </em><code>{g}</code> <br /><br /> If <code>VGL_GAMMA</code> 
        is set to an arbitrary floating point value, then VirtualGL performs 
        gamma correction internally using the specified value as the gamma 
        correction factor.  You can also specify a negative value to apply a 
        &ldquo;de-gamma&rdquo; function.  Specifying a gamma correction factor 
        of G (where G &lt; 0) is equivalent to specifying a gamma correction 
        factor of -1/G.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GLLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{l}</code></em> = the location of an alternate OpenGL library</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL tries to call any &ldquo;real&rdquo; GLX and OpenGL 
        functions it needs from the OpenGL library against which it is linked 
        (usually <code>/usr/lib/libGL.so.1</code>, 
        <code>/usr/lib64/libGL.so.1</code>,  or 
        <code>/usr/lib/64/libGL.so.1</code>).  Failing this, VirtualGL will then 
        try to call these functions from the first compatible library named 
        <code>libGL.so.1</code> that is found in the dynamic loader path.  You 
        can use the <code>VGL_GLLIB</code> environment variable to override this 
        and specify a dynamic library from which VirtualGL will call the 
        &ldquo;real&rdquo; GLX and OpenGL functions. <br /><br /> You 
        shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t 
        work.  However, setting this environment variable is necessary when 
        using VirtualGL with 
        <a href="#Chromium">Chromium</a><a name="idx0077"></a>.  It is also 
        potentially useful if one wishes to insert another OpenGL interposer 
        between VirtualGL and the system&rsquo;s OpenGL library.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GUI&nbsp;=&nbsp;</code><em><code>{k}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{k}</code></em> = the key sequence used to pop up the VirtualGL Configuration dialog, or <code>none</code> to disable the dialog</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">shift-ctrl-f9</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        VirtualGL will normally monitor an application&rsquo;s X event queue and 
        pop up the VirtualGL Configuration dialog whenever 
        <code>CTRL-SHIFT-F9</code> is pressed.  In the event that this 
        interferes with a key sequence that the application is already using, 
        then you can redefine the key sequence used to pop up the VirtualGL 
        Configuration dialog by setting <code>VGL_GUI</code> to some combination 
        of <code>shift</code>, <code>ctrl</code>, <code>alt</code>, and one of 
        <code>f1,&nbsp;f2,&nbsp;...,&nbsp;f12</code>. You can also set 
        <code>VGL_GUI</code> to <code>none</code> to disable the configuration 
        dialog altogether.  See Chapter 
        <a href="#Config_Dialog" class="ref">16</a> for more details.
    </dd>
</dl>

<p><a name="VGL_INTERFRAME"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_INTERFRAME&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Enable or disable interframe image comparison</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray, VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The VGL and Sun Ray Image Transports will normally compare each frame 
        with the previous frame and send only the portions of the image which 
        have changed.  Setting <code>VGL_INTERFRAME</code> to <code>0</code> 
        disables this behavior. <br /><br /> This setting was introduced in 
        order to work around a specific application interaction issue, but since 
        a proper fix for that issue was introduced in VirtualGL 2.1.1, this 
        option isn&rsquo;t really useful anymore.
        <div class="important"><p class="important">
        When using the VGL Image Transport, interframe comparison is affected by the <a href="#VGL_TILESIZE"><code>VGL_TILESIZE</code></a><a name="idx0078"></a> option
        </p></div>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_LOG&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Redirect all messages from VirtualGL to a log file specified by <em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Print all messages to stderr</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Setting this environment variable to the pathname of a log file on the 
        VirtualGL server will cause VirtualGL to redirect all of its messages 
        (including profiling and trace output) to the specified log file rather 
        than to stderr.
    </dd>
</dl>

<p><a name="VGL_NPROCS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_NPROCS&nbsp;=&nbsp;</code><em><code>{n}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-np&nbsp;</code><em><code>{n}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{n}</code></em> = the number of CPUs to use for multi-threaded compression</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The VGL Image Transport can divide the task of compressing each frame 
        among multiple server CPUs.  This might speed up the overall throughput 
        in rare circumstances where the server CPUs are significantly slower 
        than the client CPUs. <br /><br /> VirtualGL will not allow more than 4 
        processors total to be used for compression, nor will it allow you to 
        set this parameter to a value greater than the number of processors in 
        the system.
        <div class="important"><p class="important">
        Multi-threaded compression is affected by the <a href="#VGL_TILESIZE"><code>VGL_TILESIZE</code></a><a name="idx0079"></a> option
        </p></div>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-p&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = the TCP port to use when connecting to the VirtualGL Client</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Read from X property stored by VirtualGL Client</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The connection port for the VGL Image Transport is normally determined 
        by reading an X property that <code>vglclient</code> stores on the 2D X 
        server, so don&rsquo;t override this unless you know what you&rsquo;re 
        doing.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-pr</code> / <code>+pr</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable profiling output</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If profiling output is enabled, then VirtualGL will continuously 
        benchmark itself and periodically print out the throughput of various 
        stages in its image pipelines. <br /><br /> See Chapter 
        <a href="#Perf_Measurement" class="ref">15</a> for more details.
    </dd>
</dl>

<p><a name="VGL_QUAL"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_QUAL&nbsp;=&nbsp;</code><em><code>{q}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-q&nbsp;</code><em><code>{q}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{q}</code></em> = the JPEG compression quality, 1 &lt;= <em><code>{q}</code></em> &lt;= 100</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">95</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        In digital images, &ldquo;frequency&rdquo; refers to how quickly the 
        color changes between light and dark as you move either horizontally or 
        vertically in the image.  Images with very sharp, bright features on a 
        dark background, for instance, consist of both low-frequency and 
        high-frequency components, whereas images with smooth transitions 
        between neighboring pixels contain only low-frequency components.  JPEG 
        compression works by breaking down the image into its constituent 
        frequencies and then throwing out the highest of these frequencies.  The 
        JPEG image &ldquo;quality&rdquo; determines which frequencies are thrown 
        out.  A JPEG quality of 1 throws out all but the lowest frequencies and 
        thus produces a very impressionistic, but generally not very useful, 
        compressed image.  A JPEG quality of 100 retains all frequencies in the 
        original image (but, due to roundoff errors, the compressed image is 
        still not completely lossless.) <br /><br /> Because the human eye 
        usually can&rsquo;t detect the highest frequencies in the image, and 
        often because the image lacks those high-frequency elements to begin 
        with, a sufficiently high JPEG quality setting can produce a 
        &ldquo;perceptually lossless&rdquo; image.  A &ldquo;perceptually 
        lossless&rdquo; image contains a small amount of mathematical error when 
        compared to the original image, but this error is so small that, under 
        normal circumstances, the human visual system cannot distinguish it.  
        The threshold quality level at which JPEG compression becomes 
        perceptually lossless is different for each image, but experiments with 
        various visual difference benchmarks (such as 
        <span class="remote"><a href="http://www.mpi-inf.mpg.de/resources/hdr/vdp/" class="remote">HDR-VDP</a></span><a name="idx0080"></a>) 
        suggest that	a JPEG quality of 95 is sufficient to guarantee perceptual 
        losslessness for the types of applications (volume visualization apps, 
        in particular) in which image quality is critical.  As with any 
        benchmarks, Your Mileage May Vary. If image quality is of paramount 
        concern, consider setting the JPEG quality to 100 or using RGB encoding.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_READBACK&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable VirtualGL&rsquo;s pixel pipelines</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        On rare occasions, it might be desirable to have VirtualGL redirect 
        OpenGL rendering from an application into a Pbuffer but not 
        automatically read back and send the rendered pixels.  Some applications 
        have their own mechanisms for reading back the rendered pixels, so 
        setting <code>VGL_READBACK=0</code> disables VirtualGL&rsquo;s readback 
        mechanism and prevents duplication of effort. <br /><br /> This feature 
        was developed initially to support running 
        <span class="remote"><a href="http://www.paraview.org/" class="remote">ParaView</a></span><a name="idx0081"></a> 
        in parallel using MPI.  ParaView/MPI normally uses MPI processes 1 
        through N as rendering servers, each drawing a portion of the geometry 
        into a separate window on a separate X display. ParaView reads back 
        these server windows and composites the pixels into the main application 
        window, which is controlled by MPI process 0.  By creating a script 
        which passes a different value of <code>VGL_DISPLAY</code> and 
        <code>VGL_READBACK</code> to each MPI process, it is possible to make 
        all of the ParaView server processes render to off-screen buffers on 
        different graphics cards while preventing VirtualGL from displaying any 
        pixels except those generated by process 0. <br /><br /> This setting 
        can also be used to force Chromium to render into Pbuffers instead of 
        windows.  See Section <a href="#Force_Pbuffer" class="ref">11.2</a>.
    </dd>
</dl>

<p><a name="VGL_SPOIL"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SPOIL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-sp</code> / <code>+sp</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable frame spoiling</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        In remote display environments, the mouse movement is generally sampled 
        at least 40 and sometimes 60 times per second.  Therefore, unless 
        VirtualGL is able to deliver at least this number of frames per second 
        to the client, the movement of a 3D scene will appear to drag behind the 
        mouse motion.  VirtualGL&rsquo;s default behavior is to compensate for 
        this by dropping frames.  This ensures that every mouse motion event 
        will result in a new frame being rendered on the server, even though not 
        all of these frames will actually be delivered to the client. 
        <br /><br /> Frame spoiling should produce the best results with 
        interactive applications, but it should be turned off when running 
        benchmarks or other non-interactive applications.  Turning off frame 
        spoiling will force every frame rendered on the server to be sent 
        through VirtualGL, and thus the frame rate reported by OpenGL benchmarks 
        will accurately reflect the frame rate of VirtualGL&rsquo;s image 
        pipeline (though, in X proxy environments, this may still not accurately 
        reflect the frame rate seen by the user.  See Section 
        <a href="#Frame_Spoiling" class="ref">15.2</a>.)  Disabling frame 
        spoiling also prevents non-interactive applications from wasting 
        graphics resources by rendering frames that will never be seen.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SSL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-s</code> / <code>+s</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable SSL encryption of the VGL Image Transport</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Enabling this option causes the VGL Image Transport to be tunneled 
        through a secure socket layer (SSL) (see Section 
        <a href="#SSL_Encryption" class="ref">7.3</a>.)
    </dd>
</dl>

<p><a name="VGL_STEREO"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_STEREO&nbsp;=&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-st&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the delivery method for stereo images</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">quad</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
         <em>left</em> = When an application renders a stereo frame, send only 
         the left eye buffer <br /><br /> <em>right</em> = When an application 
         renders a stereo frame, send only the right eye buffer <br /><br /> 
         <em>quad</em> = Attempt to use quad-buffered stereo, which will result 
         in a pair of images being sent to the VirtualGL Client for every frame.  
         If quad-buffered stereo is not available, either because the client 
         machine or the image transport does not support it, then fall back to 
         using anaglyphic stereo.  Quad-buffered stereo requires the VGL Image 
         Transport, and it also requires that the 2D X server support OpenGL and 
         be connected to a 3D accelerator that supports stereo rendering. 
         <br /><br /> <em>rc</em> = Use Red/Cyan (anaglyphic) stereo, even if 
         quad-buffered is available <br /><br /> See Chapter 
         <a href="#Advanced_OpenGL" class="ref">14</a> for more details.
    </dd>
</dl>

<p><a name="VGL_SUBSAMP"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SUBSAMP&nbsp;=&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-samp&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the level of chrominance subsampling in the JPEG and Sun Ray image compressors</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray (DPCM, YUV), VGL (JPEG)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1x for VGL Image Transport, 16x for Sun Ray Image Transport</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When an image is encoded using JPEG, Sun Ray	DPCM, or Sun Ray YUV, each 
        pixel in the image is first converted from RGB (Red/Green/Blue) to YUV.  
        An RGB pixel has three values that specify the amounts of red, green, 
        and blue that make up the pixel&rsquo;s color.  A YUV pixel has three 
        values that specify the overall brightness of the pixel (Y, or 
        &ldquo;luminance&rdquo;) and the overall color of the pixel (U and V, or 
        &ldquo;chrominance&rdquo;.) <br /><br /> Since the human eye is less 
        sensitive to changes in color than it is to changes in brightness, the 
        chrominance components for some of the pixels can be discarded without 
        much noticeable loss in image quality.  This technique, called 
        &ldquo;chrominance subsampling&rdquo;, significantly reduces the size of 
        the compressed image. <br /><br /> <em>1x</em> = no chrominance 
        subsampling <br /><br /> <em>2x</em> = discard the chrominance 
        components for every other pixel along the image&rsquo;s X direction 
        (this is also known as &ldquo;4:2:2&rdquo; or &ldquo;2:1&rdquo; 
        subsampling.) All else being equal, 2x subsampling generally reduces the 
        image size by about 20-25% when compared to no subsampling.<br /> <br /> 
        <em>4x</em> = discard the chrominance components for every other pixel 
        along both the X and Y directions of the image (this is also known as 
        &ldquo;4:2:0&rdquo; or &ldquo;2:2&rdquo; subsampling.)   All else being 
        equal, 4x subsampling generally reduces the image size by about 35-40% 
        when compared to no subsampling. <br /><br /> <em>8x</em> = discard the 
        chrominance components for 3 out of every 4 pixels along the 
        image&rsquo;s X direction and half the pixels along the image&rsquo;s Y 
        direction (this is also known as &ldquo;4:1:0&rdquo; or 
        &ldquo;4:2&rdquo; subsampling.)  <em>This option is available only with 
        Sun Ray DPCM or YUV encoding.</em> <br /><br /> <em>16x</em> = discard 
        the chrominance components for 3 out of every 4 pixels along both the X 
        and Y directions of the image (this is also known as &ldquo;4:4&rdquo; 
        subsampling.)  <em>This option is available only with Sun Ray DPCM or 
        YUV encoding.</em> <br /><br /> <em>gray</em> = discard all chrominance 
        components.  This is useful when running applications (such as medical 
        visualization applications) that are already generating grayscale 
        images.  <em>This option is available only with JPEG compression.</em> 
        <br /><br /> Subsampling artifacts are less noticeable with volume data, 
        since it usually only contains 256 colors to begin with.  But narrow, 
        aliased lines and other sharp features on a black background will tend 
        to produce very noticeable artifacts when subsampling is enabled. 
        <br /><br /> The axis indicator from a popular visualization app 
        displayed with 1x, 2x, and 4x subsampling (respectively):<br /> 
        <img src="444.gif" alt="444" class="inline" id="imgid_6" name="imgid_6"/><img src="422.gif" alt="422" class="inline" id="imgid_7" name="imgid_7"/><img src="411.gif" alt="411" class="inline" id="imgid_8" name="imgid_8"/>
    </dd>
</dl>

<p><a name="VGL_SYNC"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SYNC&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-sync</code> / <code>+sync</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable strict 2D/3D synchronization</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL&rsquo;s operation is asynchronous from the point of 
        view of the application.  The application swaps the buffers or calls 
        <code>glFinish()</code> or <code>glFlush()</code> or 
        <code>glXWaitGL()</code>, and VirtualGL reads	back the framebuffer and 
        sends the pixels to the client&rsquo;s display &hellip; eventually. This 
        will work fine for the vast majority of applications, but it does not 
        strictly conform to the GLX spec.  Technically speaking, when an 
        application calls <code>glXWaitGL()</code> or <code>glFinish()</code>, 
        it is well within its rights to expect the 3D image to be immediately 
        available in the X window. Fortunately, very few applications actually 
        do expect this, but on rare occasions, an application may try to use 
        <code>XGetImage()</code> or other X11 functions to obtain a bitmap of 
        the pixels that were rendered by OpenGL. Enabling <code>VGL_SYNC</code> 
        is a somewhat extreme measure that may be needed to make such 
        applications work properly.  It was developed initially as a way to pass 
        the GLX conformance suite (<code>conformx</code>, specifically), but at 
        least one commercial application is known to require it as well (see 
        <a href="#Application_Recipes">Application 
        Recipes</a><a name="idx0082"></a>.)<br /><br />When 
        <code>VGL_SYNC</code> is enabled, every call to <code>glFinish()</code>, 
        <code>glXWaitGL()</code>, and <code>glXSwapBuffers()</code> will cause 
        the contents of the Pbuffer to be read back and <em>synchronously</em> 
        drawn into the application&rsquo;s window <em>using the X11 Image 
        Transport and no frame spoiling</em>.  The call to 
        <code>glFinish()</code>, <code>glXWaitGL()</code>, or 
        <code>glXSwapBuffers()</code> will not return until VirtualGL has 
        verified that the pixels have been delivered into the 
        application&rsquo;s window.  As such, this mode can have potentially 
        dire effects on performance when used with a remote 2D X server.  It is 
        strongly recommended that <code>VGL_SYNC</code> be used only in 
        conjunction with an X proxy (such as TurboVNC) running on the same 
        server as VirtualGL.
    </dd>
</dl>

<p><a name="VGL_TILESIZE"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TILESIZE&nbsp;=&nbsp;</code><em><code>{t}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{t}</code></em> = the image tile size (<em><code>{t}</code></em> x <em><code>{t}</code></em> pixels) to use for multi-threaded compression and interframe comparison (8 &lt;= <em><code>{t}</code></em> &lt;= 1024)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">256</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, the VGL Image Transport will divide an OpenGL window into 
        equal-sized square tiles, compare each tile vs. the same tile in the 
        previous frame, then compress and send only the tiles which have changed 
        (assuming <a href="#VGL_INTERFRAME">interframe 
        comparison</a><a name="idx0083"></a> is enabled.)  The VGL Image 
        Transport	will also divide up the task of compressing these tiles among 
        the available CPUs in a round robin fashion, if multi-threaded 
        compression is enabled (see 
        <a href="#VGL_NPROCS">VGL_NPROCS</a><a name="idx0084"></a>.) 
        <br /><br /> There are several tradeoffs that must be considered when 
        choosing a tile size: <br /><br /> <em>Smaller tile sizes:</em> 
        <ul class="Itemize"><li class="Itemize-0">
            Better parallel scalability
        </li>
        <li class="Itemize-0">
            Worse compression efficiency
        </li>
        <li class="Itemize-0">
            Better inter-frame optimization
        </li>
        <li class="Itemize-0">
            Worse network efficiency
        </li></ul> <em>Larger tile sizes:</em> 
        <ul class="Itemize"><li class="Itemize-0">
            Worse parallel scalability
        </li>
        <li class="Itemize-0">
            Better compression efficiency
        </li>
        <li class="Itemize-0">
            Worse inter-frame optimization
        </li>
        <li class="Itemize-0">
            Better network efficiency
        </li></ul> <br /> Smaller tiles can more easily be divided up among 
        multiple CPUs, but they compress less efficiently (and less quickly) on 
        an individual basis.  Using larger tiles can reduce traffic to the 
        client by allowing the server to send only one frame update instead of 
        many.  But on the flip side, using larger tiles decreases the chance 
        that a tile will be unchanged from the previous frame. <br /><br /> 
        256x256 was chosen as the default because, in experiments, it provided 
        the best balance between scalability and efficiency on the platforms 
        that VirtualGL supports.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TRACE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-tr</code> / <code>+tr</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable tracing</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When tracing is enabled, VirtualGL will log all calls to the GLX and X11 
        functions it is intercepting, as well as the arguments, return values, 
        and execution times for those functions.  This is useful when diagnosing 
        interaction problems between VirtualGL and a particular OpenGL 
        application.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TRAPX11&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable VirtualGL&rsquo;s X11 error handler</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If an application does not install its own X11 error handler, then the 
        default X11 error handler is used.  The default X11 error handler will 
        cause the application to exit if an X11 error occurs.  Enabling the 
        <code>VGL_TRAPX11</code> option will cause VirtualGL to install its own 
        X11 error handler, which prints a warning message but allows the 
        application to continue running.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-v</code> / <code>+v</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable verbose VirtualGL messages</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When verbose mode is enabled, VirtualGL will reveal some of the 
        decisions it makes behind the scenes, such as which code path it is 
        using to compress images, which type of X11 drawing it is using, etc.  
        This can be helpful when diagnosing performance problems.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_X11LIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{l}</code></em> = the location of an alternate X11 library</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL tries to call any &ldquo;real&rdquo; X11 functions 
        it needs from the X11 library against which it is linked (usually 
        <code>/usr/lib/libX11.so.6</code>, <code>/usr/lib/64/libX11.so.6</code>, 
        <code>/usr/X11R6/lib/libX11.so.6</code>, or 
        <code>/usr/X11R6/lib64/libX11.so.6</code>). Failing this, VirtualGL will 
        then try to call these functions from the first compatible library named 
        <code>libX11.so.6</code> that is found in the dynamic loader path.  You 
        can use the <code>VGL_X11LIB</code> environment	variable to override 
        this and specify a dynamic library from which VirtualGL will call the 
        &ldquo;real&rdquo; X11 functions. <br /><br /> You shouldn&rsquo;t need 
        to muck with this unless something doesn&rsquo;t work.  However, it is 
        potentially useful if one wishes to insert another X11 interposer 
        between VirtualGL and the system&rsquo;s X11 library.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_XVENDOR&nbsp;=&nbsp;</code><em><code>{v}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{v}</code></em> = a fake X11 vendor string to return when the application calls <code>XServerVendor()</code> or <code>ServerVendor()</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Some applications expect the X11 vendor string to contain a particular 
        value, which the application (sometimes erroneously) uses to figure out 
        whether it is being displayed to a local or a remote X server. This 
        setting allows you to fool such applications into thinking that they are 
        being	displayed to a &ldquo;local&rdquo; X server rather than a remote 
        one. <br /><br /> Refer to Chapter 
        <a href="#Application_Recipes" class="ref">13</a> for specific 
        applications that require this.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_ZOOM_X&nbsp;=&nbsp;</code><em><code>1&nbsp;|&nbsp;2</code></em><br /> <code>VGL_ZOOM_Y&nbsp;=&nbsp;</code><em><code>1&nbsp;|&nbsp;2</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Subsample all pixels by the specified factor</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Setting <code>VGL_ZOOM_X=2</code> causes the Sun Ray Image Transport to 
        discard every other pixel along the X direction of the image.  Setting 
        <code>VGL_ZOOM_Y=2</code> does the same thing for the Y direction of the 
        image.  This differs from <code>VGL_SUBSAMP</code> in that 
        <code>VGL_SUBSAMP</code> discards only the chrominance components from 
        the pixels it subsamples.  <code>VGL_ZOOM_*</code>, on the other hand, 
        discards the luminance components as well.  The result is extremely 
        grainy.
    </dd>
</dl>


<h2 id="hd0017002">17.2&nbsp;Client Settings</h2>

<p>These settings control the VirtualGL Client, which is used only with the 
VGL Image Transport.  <code>vglclient</code> is normally launched 
automatically from <code>vglconnect</code> and should not require any 
further configuration except in exotic circumstances.  These settings 
are meant only for advanced users or those wishing to build additional 
infrastructure around VirtualGL.</p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_DRAWMODE&nbsp;=&nbsp;</code><em><code>ogl&nbsp;|&nbsp;x11</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-gl</code> / <code>-x</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the method used to draw pixels into the application window</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard"><code>ogl</code> for Solaris/SPARC systems with 3D accelerators, <code>x11</code> otherwise</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If the client machine has a 3D accelerator, then it may be faster to 
        draw pixels using OpenGL rather than using 2D (X11) commands.  This is 
        particularly true of many 3D accelerators available for the 
        Solaris/SPARC platform, since they are able to draw images using 24-bit 
        pixels instead of the 32-bit pixels required by the X server.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_LISTEN&nbsp;=&nbsp;</code><em><code>sslonly&nbsp;|&nbsp;nossl</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-sslonly</code> / <code>-nossl</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Accept only unencrypted or only SSL connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
</table>
</div>


<p><br /></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-port&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = TCP port on which to listen for unencrypted connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically select a free port</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The default behavior for <code>vglclient</code> is to first try 
        listening on port	4242, to maintain backward compatibility with 
        VirtualGL v2.0.x.  If port 4242 is not available, then 
        <code>vglclient</code> will try to find a free port in the range of 
        4200-4299.  If none of those ports is available, then 
        <code>vglclient</code> will request a free port from the operating 
        system. <br /><br /> Setting this option circumvents the automatic 
        behavior described above and causes <code>vglclient</code> to listen 
        only on the specified TCP port.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable profiling output</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If profiling output is enabled, then VirtualGL will continuously 
        benchmark itself and periodically print out the throughput of various 
        stages in its image pipelines. <br /><br /> See Chapter 
        <a href="#Perf_Measurement" class="ref">15</a> for more details.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_SSLPORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-sslport&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = TCP port on which to listen for SSL connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically select a free port</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The default behavior for <code>vglclient</code> is to first try 
        listening on port	4243, to maintain backward compatibility with 
        VirtualGL v2.0.x.  If port 4243 is not available, then 
        <code>vglclient</code> will try to find a free port in the range of 
        4200-4299.  If none of those ports is available, then 
        <code>vglclient</code> will request a free port from the operating 
        system. <br /><br /> Setting this option circumvents the automatic 
        behavior described above and causes <code>vglclient</code> to listen 
        only on the specified TCP port.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable verbose VirtualGL messages</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When verbose mode is enabled, VirtualGL will reveal some of the 
        decisions it makes behind the scenes, such as which code path it is 
        using to decompress images, which type of X11 drawing it is using, etc.  
        This can be helpful when diagnosing performance problems.
    </dd>
</dl>

<p><br /></p>

</body>
</html>

