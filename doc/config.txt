* Advanced Configuration
{anchor: Advanced_Configuration}

** Server Settings

You can control the operation of the VirtualGL faker in four different ways.
Each method of configuration takes precedence over the previous method:

	#. Setting a configuration environment variable globally (for instance, in
		''/etc/profile'')

	#. Setting a configuration environment variable on a per-user basis (for instance, in
		''~/.bashrc'')

	#. Setting a configuration environment variable only for the current shell
		session (for instance, ''export VGL_XXX={whatever}'')

	#. Passing a configuration option as an argument to ''vglrun''.  This
		effectively overrides any previous environment variable setting
		corresponding to that configuration option.
{:}
	!!! If "Custom (if supported)" is listed as one of the available Image
	Transports, then this means that image transport plugins are free to handle
	or ignore this option as they see fit.

| Environment Variable | ''VGL_CLIENT = ''__''{c}''__ |
| ''vglrun'' argument | ''-cl ''__''{c}''__ |
| Summary | __''{c}''__ = the hostname or IP address of the VirtualGL client |
| Image Transports | VGL, Custom (if supported) |
| Default Value | Automatically set by ''vglconnect'' or ''vglrun'' |
#OPT: hiCol=first

	Description :: When using the VGL Transport, ''VGL_CLIENT'' should be set to
	the hostname or IP address of the machine on which ''vglclient'' is running.
	Normally, ''VGL_CLIENT'' is set automatically by the ''vglconnect'' or
	''vglrun'' script, so don't override it unless you know what you're doing. \

{anchor: VGL_COMPRESS}
| Environment Variable | ''VGL_COMPRESS = ''__''proxy \| jpeg \| rgb''__ |
| ''vglrun'' argument | ''-c ''__''proxy \| jpeg \| rgb''__ |
| Summary | Set image transport and image compression type |
| Image Transports | All |
| Default Value | (See description) |
#OPT: hiCol=first

	Description :: {:}
	__proxy__ = Send images uncompressed using the X11 Transport.  This is useful
	when displaying to a local 2D X server or X proxy (see
	{ref prefix="Section ": X11_Proxy_Usage_Local}.)
	{nl}{nl} \
	__jpeg__ = Compress images using JPEG and send using the VGL Transport.  This
	is useful when displaying to a remote 2D X server (see
	{ref prefix="Chapter ": VGL_Transport_Usage}.)
	{nl}{nl} \
	__rgb__ = Encode images as uncompressed RGB and send using the VGL Transport.
	 This is useful when displaying to a remote 2D X server or X proxy across a
	very fast network (see {ref prefix="Section ": X11_Proxy_Usage_Remote}.)
	{nl}{nl} \
	If this option is not specified, then the default is set as follows:
	{nl}{nl} \
	If the ''DISPLAY'' environment variable begins with '':'' or ''unix:'', then
	VirtualGL assumes that the X display connection is local and it defaults to
	using __proxy__ compression.  Otherwise, it defaults to __jpeg__
	compression.

	!!! If an image transport plugin is being used, then you can set
	''VGL_COMPRESS'' to any numeric value >= 0 (Default value = 0.)  How the
	plugin responds to this value is implementation-specific.

| Environment Variable | ''VGL_DISPLAY = ''__''{d}''__ |
| ''vglrun'' argument | ''-d ''__''{d}''__ |
| Summary | __''{d}''__ = the X display or GLP device to use for 3D rendering |
| Image Transports | All |
| Default Value | :0 |
#OPT: hiCol=first

	Description :: If the VirtualGL server has multiple 3D graphics cards and you
	want the OpenGL rendering to be redirected to a display other than :0, then
	you can set ''VGL_DISPLAY=:1.0'' or whatever.  This could be used, for
	instance, to support many application instances on a beefy multi-pipe
	application server.
	{nl}{nl} \
	__GLP mode (Solaris/SPARC only):__
	{nl}{nl} \
	Setting this option to ''glp'' will enable GLP mode and use the first
	framebuffer device listed in ''/etc/dt/config/GraphicsDevices'' to
	perform 3D rendering.  You can also set this option to the
	pathname of a specific GLP device (example: ''/dev/fbs/jfb0''.)  See
	{ref prefix="Section ": GLP_Usage} for more details.

{anchor: VGL_FPS}
| Environment Variable | ''VGL_FPS = ''__''{f}''__ |
| ''vglrun'' argument | ''-fps ''__''{f}''__ |
| Summary | Limit the client/server frame rate to __''{f}''__ frames/second, \
	where __''{f}''__ is a floating point number > 0.0 |
| Image Transports | VGL, X11, Custom (if supported) |
| Default Value | 0.0 (No limit) |
#OPT: hiCol=first

	Description :: This option prevents VirtualGL from sending frames at a rate
	faster than the specified limit.  It can be used, for instance, as a crude
	way to control network bandwidth or CPU usage in multi-user environments
	where those resources are constrained.
	{nl}{nl} \
	If frame spoiling is disabled, then this effectively limits the server's 3D
	rendering frame rate as well.

{anchor: VGL_GAMMA}
| Environment Variable | ''VGL_GAMMA = ''__''0 \| 1 \| {g}''__ |
| ''vglrun'' argument | ''-g'' / ''+g'' / ''-gamma ''__''{g}''__ |
| Summary | Disable/enable gamma correction and specify gamma correction \
	factor |
| Image Transports | All |
| Default Value | ''VGL_GAMMA=1'' on Solaris/SPARC VGL servers, \
	''VGL_GAMMA=0'' otherwise |
#OPT: hiCol=first

	Description :: "Gamma" refers to the relationship between the intensity of
	light which your computer's monitor is instructed to display and the
	intensity which it actually displays.  The curve is an exponential curve of
	the form __Y = X{^G}__, where X is between 0 and 1.  G is called the "gamma"
	of the monitor.  PC monitors and TV's usually have a gamma of around 2.2.
	{nl}{nl} \
		Some of the math involved in 3D rendering assumes a linear gamma \
		(G = 1.0), so technically speaking, 3D applications will not display with \
		mathematical correctness unless the pixels are "gamma corrected" to \
		counterbalance the non-linear response curve of the monitor.  However, \
		some systems do not have any form of built-in gamma correction, so the \
		applications developed for such systems have usually been designed to \
		display properly without gamma correction.  Gamma correction involves \
		passing pixels through a function of the form __X = W{^1/G}__, where G \
		is the "gamma correction factor" and should be equal to the gamma of the \
		monitor.  So the final output is __Y = X{^G} = (W{^1/G}){^G} = W__, which \
		describes a linear relationship between the intensity of the pixels drawn \
		by the application and the intensity of the pixels displayed by the \
		monitor. \
		{nl}{nl} \
		__''VGL_GAMMA=1'' or ''vglrun +g'' : Enable gamma correction with default \
			settings__ \
		{nl}{nl} \
		This option tells VirtualGL to enable gamma correction using the best \
		available method.  If VirtualGL is remotely displaying to a Solaris/SPARC \
		X server which has gamma-corrected X visuals, then VGL will attempt to \
		assign one of these visuals to the application.  This causes the 3D \
		output of the application to be gamma corrected by the factor specified \
		in ''fbconfig'' on the client machine (default: 2.22.)  Otherwise, if the \
		2D X server does not have gamma-corrected X visuals or if the \
		gamma-corrected visuals it has do not match the application's needs, then \
		VirtualGL performs gamma correction internally and uses a default gamma \
		correction factor of 2.22.  This option emulates the default behavior of \
		OpenGL applications running locally on SPARC machines. \
		{nl}{nl} \
		__''VGL_GAMMA=0'' or ''vglrun -g'' : Disable gamma correction__ \
		{nl}{nl} \
		This option tells VGL not to use gamma-corrected visuals, even if they are \
		available on the 2D X server, and disables VGL's internal gamma correction \
		system as well.  This emulates the default behavior of OpenGL \
		applications running locally on Linux or Solaris/x86 machines. \
		{nl}{nl} \
		__''VGL_GAMMA=''__''{g}''__ or ''vglrun -gamma ''__''{g}''__ : Enable \
			VGL's internal gamma correction system with a gamma correction factor \
			of __''{g}'' \
		{nl}{nl} \
		If ''VGL_GAMMA'' is set to an arbitrary floating point value, then \
		VirtualGL performs gamma correction internally using the specified value \
		as the gamma correction factor.  You can also specify a negative \
		value to apply a "de-gamma" function.  Specifying a gamma correction \
		factor of G (where G < 0) is equivalent to specifying a gamma correction \
		factor of -1/G.

| Environment Variable | ''VGL_GLLIB = ''__''{l}''__ |
| Summary | __''{l}''__ = the location of an alternate OpenGL library |
| Image Transports | All |
#OPT: hiCol=first

	Description :: Normally, VirtualGL tries to call any "real" GLX and OpenGL
	functions it needs from the OpenGL library against which it is linked
	(usually ''/usr/lib/libGL.so.1'', ''/usr/lib64/libGL.so.1'',  or
	''/usr/lib/64/libGL.so.1'').  Failing this, VirtualGL will then try to call
	these functions from the first compatible library named ''libGL.so.1'' that
	is found in the dynamic loader path.  You can use the ''VGL_GLLIB''
	environment variable to override this and specify a dynamic library from
	which VirtualGL will call the "real" GLX and OpenGL functions.
	{nl}{nl} \
	You shouldn't need to muck with this unless something doesn't work.  However,
	setting this environment variable is necessary when using VirtualGL with
	[[chromium.txt#Chromium][Chromium]].  It is also potentially useful if one
	wishes to insert another OpenGL interposer between VirtualGL and the system's
	OpenGL library.

| Environment Variable | ''VGL_GUI = ''__''{k}''__ |
| Summary | __''{k}''__ = the key sequence used to pop up the VirtualGL \
	Configuration dialog, or ''none'' to disable the dialog |
| Image Transports | All |
| Default Value | shift-ctrl-f9 |
#OPT: hiCol=first

	Description :: VirtualGL will normally monitor an application's X event queue
	and pop up the VirtualGL Configuration dialog whenever ''CTRL-SHIFT-F9'' is
	pressed.  In the event that this interferes with a key sequence that the
	application is already using, then you can redefine the key sequence used to
	pop up the VirtualGL Configuration dialog by setting ''VGL_GUI'' to some
	combination of ''shift'', ''ctrl'', ''alt'', and one of ''f1, f2, ..., f12''.
	You can also set ''VGL_GUI'' to ''none'' to disable the configuration dialog
	altogether.  See {ref prefix="Chapter ": Config_Dialog} for more details.

{anchor: VGL_INTERFRAME}
| Environment Variable | ''VGL_INTERFRAME = ''__''0 \| 1''__ |
| Summary | Enable or disable interframe image comparison |
| Image Transports | VGL, Custom (if supported) |
| Default Value | Enabled |
#OPT: hiCol=first

	Description :: The VGL Transport will normally compare each frame with the
	previous frame and send only the portions of the image which have changed.
	Setting ''VGL_INTERFRAME'' to ''0'' disables this behavior.
	{nl}{nl} \
	This setting was introduced in order to work around a specific application
	interaction issue, but since a proper fix for that issue was introduced in
	VirtualGL 2.1.1, this option isn't really useful anymore.

	!!! When using the VGL Transport, interframe comparison is affected by the
	[[#VGL_TILESIZE][''VGL_TILESIZE'']] option

| Environment Variable | ''VGL_LOG = ''__''{l}''__ |
| Summary | Redirect all messages from VirtualGL to a log file specified by \
	__''{l}''__ |
| Image Transports | All |
| Default Value | Print all messages to stderr |
#OPT: hiCol=first

	Description :: Setting this environment variable to the pathname of a log
	file on the VirtualGL server will cause VirtualGL to redirect all of its
	messages (including profiling and trace output) to the specified log file
	rather than to stderr.

| Environment Variable | ''VGL_LOGO = ''__''0 \| 1''__ |
| Summary | Enable or disable the display of a VGL logo in the 3D window |
| Image Transports | All |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: Setting ''VGL_LOGO'' to ''1'' will cause VirtualGL to display
	a small logo in the bottom right-hand corner of the 3D window.  This is meant
	as a debugging tool to allow users to determine whether or not VirtualGL is
	active.

{anchor: VGL_NPROCS}
| Environment Variable | ''VGL_NPROCS = ''__''{n}''__ |
| ''vglrun'' argument | ''-np ''__''{n}''__ |
| Summary | __''{n}''__ = the number of CPUs to use for multi-threaded \
	compression |
| Image Transports | VGL, Custom (if supported) |
| Default Value | 1 |
#OPT: hiCol=first

	Description :: The VGL Transport can divide the task of compressing each
	frame among multiple server CPUs.  This might speed up the overall throughput
	in rare circumstances where the server CPUs are significantly slower than the
	client CPUs.
	{nl}{nl} \
	VirtualGL will not allow more than 4 processors total to be used for
	compression, nor will it allow you to set this parameter to a value greater
	than the number of processors in the system.

	!!! When using the VGL Transport, multi-threaded compression is affected by
	the [[#VGL_TILESIZE][''VGL_TILESIZE'']] option

| Environment Variable | ''VGL_PORT = ''__''{p}''__ |
| ''vglrun'' argument | ''-p ''__''{p}''__ |
| Summary | __''{p}''__ = the TCP port to use when connecting to the \
	VirtualGL Client |
| Image Transports | VGL, Custom (if supported) |
| Default Value | Read from X property stored by VirtualGL Client |
#OPT: hiCol=first

	Description :: The connection port for the VGL Transport is normally
	determined by reading an X property that ''vglclient'' stores on the 2D X
	server, so don't override this unless you know what you're doing.

| Environment Variable | ''VGL_PROFILE = ''__''0 \| 1''__ |
| ''vglrun'' argument | ''-pr'' / ''+pr'' |
| Summary | Disable/enable profiling output |
| Image Transports | VGL, X11, Custom (if supported) |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: If profiling output is enabled, then VirtualGL will
	continuously benchmark itself and periodically print out the throughput of
	various stages in its image pipelines.
	{nl}{nl} \
	See {ref prefix="Chapter ": Perf_Measurement} for more details.

{anchor: VGL_QUAL}
| Environment Variable | ''VGL_QUAL = ''__''{q}''__ |
| ''vglrun'' argument | ''-q ''__''{q}''__ |
| Summary | __''{q}''__ = the JPEG compression quality, 1 \<\= __''{q}''__ \<\= 100 |
| Image Transports | VGL (JPEG), Custom (if supported) |
| Default Value | 95 |
#OPT: hiCol=first

	Description :: In digital images, "frequency" refers to how quickly the color
	changes between light and dark as you move either horizontally or vertically
	in the image.  Images with very sharp, bright features on a dark background,
	for instance, consist of both low-frequency and high-frequency components,
	whereas images with smooth transitions between neighboring pixels contain
	only low-frequency components.  JPEG compression works by breaking down the
	image into its constituent frequencies and then throwing out the highest of
	these frequencies.  The JPEG image "quality" determines which frequencies are
	thrown out.  A JPEG quality of 1 throws out all but the lowest frequencies
	and thus produces a very impressionistic, but generally not very useful,
	compressed image.  A JPEG quality of 100 retains all frequencies in the
	original image (but, due to roundoff errors, the compressed image is still
	not completely lossless.)
	{nl}{nl} \
	Because the human eye usually can't detect the highest frequencies in the
	image, and often because the image lacks those high-frequency elements to
	begin with, a sufficiently high JPEG quality setting can produce a
	"perceptually lossless" image.  A "perceptually lossless" image contains
	a small amount of mathematical error when compared to the original image, but
	this error is so small that, under normal circumstances, the human visual
	system cannot distinguish it.  The threshold quality level at which JPEG
	compression becomes perceptually lossless is different for each image, but
	experiments with various visual difference benchmarks (such as
	[[http://www.mpi-inf.mpg.de/resources/hdr/vdp/][HDR-VDP]]) suggest that	a
	JPEG quality of 95 is sufficient to guarantee perceptual losslessness for the
	types of applications (volume visualization apps, in particular) in which
	image quality is critical.  As with any benchmarks, Your Mileage May Vary.
	If image quality is of paramount concern, consider setting the JPEG quality
	to 100 or using RGB encoding.

| Environment Variable | ''VGL_READBACK = ''__''0 \| 1''__ |
| Summary | Disable/enable VirtualGL's pixel pipelines |
| Image Transports | All |
| Default Value | Enabled |
#OPT: hiCol=first

	Description :: On rare occasions, it might be desirable to have VirtualGL
	redirect OpenGL rendering from an application into a Pbuffer but not
	automatically read back and send the rendered pixels.  Some applications have
	their own mechanisms for reading back the rendered pixels, so setting
	''VGL_READBACK=0'' disables VirtualGL's readback mechanism and prevents
	duplication of effort.
	{nl}{nl} \
	This feature was developed initially to support running
	[[http://www.paraview.org/][ParaView]] in parallel using MPI.  ParaView/MPI
	normally uses MPI processes 1 through N as rendering servers, each drawing a
	portion of the geometry into a separate window on a separate X display.
	ParaView reads back these server windows and composites the pixels into the
	main application window, which is controlled by MPI process 0.  By creating a
	script which passes a different value of ''VGL_DISPLAY'' and ''VGL_READBACK''
	to each MPI process, it is possible to make all of the ParaView server
	processes render to off-screen buffers on different graphics cards while
	preventing VirtualGL from displaying any pixels except those generated by
	process 0.
	{nl}{nl} \
	This setting can also be used to force Chromium to render into Pbuffers
	instead of windows.  See {ref prefix="Section ": Force_Pbuffer}.

{anchor: VGL_SPOIL}
| Environment Variable | ''VGL_SPOIL = ''__''0 \| 1''__ |
| ''vglrun'' argument | ''-sp'' / ''+sp'' |
| Summary | Disable/enable frame spoiling |
| Image Transports | VGL, X11, Custom (if supported) |
| Default Value | Enabled |
#OPT: hiCol=first

	Description :: In remote display environments, the mouse movement is
	generally sampled at least 40 and sometimes 60 times per second.  Therefore,
	unless VirtualGL is able to deliver at least this number of frames per
	second to the client, the movement of a 3D scene will appear to drag behind
	the mouse motion.  VirtualGL's default behavior is to compensate for this by
	dropping frames.  This ensures that every mouse motion event will result in a
	new frame being rendered on the server, even though not all of these frames
	will actually be delivered to the client.
	{nl}{nl} \
	Frame spoiling should produce the best results with interactive applications,
	but it should be turned off when running benchmarks or other non-interactive
	applications.  Turning off frame spoiling will force every frame rendered on
	the server to be sent through VirtualGL, and thus the frame rate reported by
	OpenGL benchmarks will accurately reflect the frame rate of VirtualGL's image
	pipeline (though, in X proxy environments, this may still not accurately
	reflect the frame rate seen by the user.  See
	{ref prefix="Section ": Frame_Spoiling}.)  Disabling frame spoiling also
	prevents non-interactive applications from wasting graphics resources by
	rendering frames that will never be seen.

| Environment Variable | ''VGL_SSL = ''__''0 \| 1''__ |
| ''vglrun'' argument | ''-s'' / ''+s'' |
| Summary | Disable/enable SSL encryption of the image transport |
| Image Transports | VGL, Custom (if supported) |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: Enabling this option causes the VGL Transport to be
	tunneled through a secure socket layer (SSL).

	!!! This option has no effect unless both the VirtualGL server and client
	were built with OpenSSL support.

{anchor: VGL_STEREO}
| Environment Variable | ''VGL_STEREO = ''__''left \| right \| quad \| rc''__ |
| ''vglrun'' argument | ''-st ''__''left \| right \| quad \| rc''__ |
| Summary | Specify the delivery method for stereo images |
| Image Transports | All |
| Default Value | quad |
#OPT: hiCol=first

	Description :: {:}
	__left__ = When an application renders a stereo frame, send only the left
	eye buffer
	{nl}{nl} \
	__right__ = When an application renders a stereo frame, send only the right
	eye buffer
	{nl}{nl} \
	__quad__ = Attempt to use quad-buffered stereo, which will result in a pair
	of images being sent to the VirtualGL Client for every frame.  If using the
	VGL Transport and quad-buffered stereo is not available on the client, or if
	using the X11 Transport, then fall back to using anaglyphic stereo.
	Using quad-buffered stereo requires the VGL Transport (or a transport plugin
	that can handle stereo image pairs.)  Using quad-buffered stereo with the VGL
	Transport also requires that the 2D X server support OpenGL and be connected
	to a 3D accelerator that supports stereo rendering.
	{nl}{nl} \
	__rc__ = Use Red/Cyan (anaglyphic) stereo, even if quad-buffered is
	available
	{nl}{nl} \
	See {ref prefix="Chapter ": Advanced_OpenGL} for more details.

{anchor: VGL_SUBSAMP}
| Environment Variable | ''VGL_SUBSAMP = ''__''gray \| 1x \| 2x \| 4x \| 8x \| 16x''__ |
| ''vglrun'' argument | ''-samp ''__''gray \| 1x \| 2x \| 4x \| 8x \| 16x''__ |
| Summary | Specify the level of chrominance subsampling in the \
	JPEG image compressor |
| Image Transports | VGL (JPEG), Custom (if supported) |
| Default Value | 1x |
#OPT: hiCol=first

	Description :: When an image is encoded using JPEG, each pixel in the image
	is first converted from RGB (Red/Green/Blue) to YUV.  An RGB pixel has three
	values that specify the amounts of red, green, and blue that make up the
	pixel's color.  A YUV pixel has three values that specify the overall
	brightness of the pixel (Y, or "luminance") and the overall color of the
	pixel (U and V, or "chrominance".)
	{nl}{nl} \
	Since the human eye is less sensitive to changes in color than it is to
	changes in brightness, the chrominance components for some of the pixels can
	be discarded without much noticeable loss in image quality.  This technique,
	called "chrominance subsampling", significantly reduces the size of the
	compressed image.
	{nl}{nl} \
	__1x__ = no chrominance subsampling
	{nl}{nl} \
	__2x__ = discard the chrominance components for every other pixel along the
	image's X direction (this is also known as "4:2:2" or "2:1" subsampling.) All
	else being equal, 2x subsampling generally reduces the image size by about
	20-25% when compared to no subsampling.{nl} \
	{nl} \
	__4x__ = discard the chrominance components for every other pixel along both
	the X and Y directions of the image (this is also known as "4:2:0" or "2:2"
	subsampling.)   All else being equal, 4x subsampling generally reduces the
	image size by about 35-40% when compared to no subsampling.
	{nl}{nl} \
	__8x__ = discard the chrominance components for 3 out of every 4 pixels along
	the image's X direction and half the pixels along the image's Y direction
	(this is also known as "4:1:0" or "4:2" subsampling.)  __This option is
	available only when using an image transport plugin that supports it.__
	{nl}{nl} \
	__16x__ = discard the chrominance components for 3 out of every 4 pixels
	along both the X and Y directions of the image (this is also known as "4:4"
	subsampling.)  __This option is available only when using an image transport
	plugin that supports it.__
	{nl}{nl} \
	__gray__ = discard all chrominance components.  This is useful when running
	applications (such as medical visualization applications) that are already
	generating grayscale images.
	{nl}{nl} \
	Subsampling artifacts are less noticeable with volume data, since it usually
	only contains 256 colors to begin with.  But narrow, aliased lines and other
	sharp features on a black background will tend to produce very noticeable
	artifacts when subsampling is enabled. \
	{nl}{nl} \
	The axis indicator from a popular visualization app displayed with 1x, \
	2x, and 4x subsampling (respectively):{nl} \
	{img: 444.gif}{img: 422.gif}{img: 411.gif} \

{anchor: VGL_SYNC}
| Environment Variable | ''VGL_SYNC = ''__''0 \| 1''__ |
| ''vglrun'' argument | ''-sync'' / ''+sync'' |
| Summary | Disable/enable strict 2D/3D synchronization |
| Image Transports | VGL, X11, Custom (if supported) |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: Normally, VirtualGL's operation is asynchronous from the point
	of view of the application.  The application swaps the buffers or calls
	''glFinish()'' or ''glFlush()'' or ''glXWaitGL()'', and VirtualGL reads	back
	the framebuffer and sends the pixels to the client's display ... eventually.
	This will work fine for the vast majority of applications, but it does not
	strictly conform to the GLX spec.  Technically speaking, when an application
	calls ''glXWaitGL()'' or ''glFinish()'', it is well within its rights to
	expect the 3D image to be immediately available in the X window.
	Fortunately, very few applications actually do expect this, but on rare
	occasions, an application may try to use ''XGetImage()'' or other X11
	functions to obtain a bitmap of the pixels that were rendered by OpenGL.
	Enabling ''VGL_SYNC'' is a somewhat extreme measure that may be needed to
	make such applications work properly.  It was developed initially as a way to
	pass the GLX conformance suite (''conformx'', specifically), but at least one
	commercial application is known to require it as well (see
	[[#Application_Recipes][Application Recipes]].){nl}\
	{nl}\
	When ''VGL_SYNC'' is enabled, every call to ''glFinish()'', ''glXWaitGL()'',
	and ''glXSwapBuffers()'' will cause the contents of the Pbuffer
	to be read back and __synchronously__ drawn into the application's window
	__using the X11 Transport and no frame spoiling__.  The call to
	''glFinish()'', ''glXWaitGL()'', or ''glXSwapBuffers()'' will not return
	until VirtualGL has verified that the pixels have been delivered into the
	application's window.  As such, this mode can have potentially dire effects
	on performance when used with a remote 2D X server.  It is strongly
	recommended that ''VGL_SYNC'' be used only in conjunction with an X proxy
	running on the same server as VirtualGL.

	!!! If an image transport plugin is being used, then VirtualGL does not
	automatically enable the X11 Transport or disable frame spoiling when
	''VGL_SYNC'' is set.  This allows the plugin to handle synchronous image
	delivery as it sees fit (or to simply ignore this option.)

{anchor: VGL_TILESIZE}
| Environment Variable | ''VGL_TILESIZE = ''__''{t}''__ |
| Summary | __''{t}''__ = the image tile size (__''{t}''__ x __''{t}''__ pixels) \
	to use for multi-threaded compression and interframe comparison \
	(8 \<\= __''{t}''__ \<\= 1024) |
| Image Transports | VGL, Custom (if supported) |
| Default Value | 256 |
#OPT: hiCol=first

	Description :: Normally, the VGL Transport will divide an OpenGL window into
	equal-sized square tiles, compare each tile vs. the same tile in the previous
	frame, then compress and send only the tiles which have changed (assuming
	[[#VGL_INTERFRAME][interframe comparison]] is enabled.)  The VGL Transport
	will also divide up the task of compressing these tiles among the available
	CPUs in a round robin fashion, if multi-threaded compression is enabled
	(see [[#VGL_NPROCS][VGL_NPROCS]].)
	{nl}{nl} \
	There are several tradeoffs that must be considered when choosing a tile
	size:
	{nl}{nl} \
	__Smaller tile sizes:__ \
	{list: \
		{item: Better parallel scalability} \
		{item: Worse compression efficiency} \
		{item: Better inter-frame optimization} \
		{item: Worse network efficiency}} \
	__Larger tile sizes:__ \
	{list: \
		{item: Worse parallel scalability} \
		{item: Better compression efficiency} \
		{item: Worse inter-frame optimization} \
		{item: Better network efficiency}} \
	{nl} \
	Smaller tiles can more easily be divided up among multiple CPUs, but they
	compress less efficiently (and less quickly) on an individual basis.  Using
	larger tiles can reduce traffic to the client by allowing the server to send
	only one frame update instead of many.  But on the flip side, using larger
	tiles decreases the chance that a tile will be unchanged from the previous
	frame.
	{nl}{nl} \
	256x256 was chosen as the default because, in experiments, it provided
	the best balance between scalability and efficiency on the platforms that
	VirtualGL supports.

| Environment Variable | ''VGL_TRACE = ''__''0 \| 1''__ |
| ''vglrun'' argument | ''-tr'' / ''+tr'' |
| Summary | Disable/enable tracing |
| Image Transports | All |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: When tracing is enabled, VirtualGL will log all calls to the
	GLX and X11 functions it is intercepting, as well as the arguments, return
	values, and execution times for those functions.  This is useful when
	diagnosing interaction problems between VirtualGL and a particular OpenGL
	application.

| Environment Variable | ''VGL_TRANSPORT = ''__''{t}''__ |
| ''vglrun'' argument | ''-trans ''__''{t}''__ |
| Summary | Use an image transport plugin |
| Default Value | None |
#OPT: hiCol=first

	Description :: If this option is specified, then VirtualGL will attempt to
	load an image transport plugin contained in a dynamic library named
	''libtransvgl_''__''{t}''__''.so'' located in the dynamic linker path.

| Environment Variable | ''VGL_TRAPX11 = ''__''0 \| 1''__ |
| Summary | Disable/enable VirtualGL's X11 error handler |
| Image Transports | All |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: If an application does not install its own X11 error handler,
	then the default X11 error handler is used.  The default X11 error handler
	will cause the application to exit if an X11 error occurs.  Enabling the
	''VGL_TRAPX11'' option will cause VirtualGL to install its own X11 error
	handler, which prints a warning message but allows the application to
	continue running.

| Environment Variable | ''VGL_VERBOSE = ''__''0 \| 1''__ |
| ''vglrun'' argument | ''-v'' / ''+v'' |
| Summary | Disable/enable verbose VirtualGL messages |
| Image Transports | All |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: When verbose mode is enabled, VirtualGL will reveal some of
	the decisions it makes behind the scenes, such as which code path it is using
	to compress images, which type of X11 drawing it is using, etc.  This can be
	helpful when diagnosing performance problems.

| Environment Variable | ''VGL_X11LIB = ''__''{l}''__ |
| Summary | __''{l}''__ = the location of an alternate X11 library |
| Image Transports | All |
#OPT: hiCol=first

	Description :: Normally, VirtualGL tries to call any "real" X11 functions it
	needs from the X11 library against which it is linked (usually
	''/usr/lib/libX11.so.6'', ''/usr/lib/64/libX11.so.6'',
	''/usr/X11R6/lib/libX11.so.6'', or ''/usr/X11R6/lib64/libX11.so.6'').
	Failing this, VirtualGL will then try to call these functions from the first
	compatible library named ''libX11.so.6'' that is found in the dynamic loader
	path.  You can use the ''VGL_X11LIB'' environment	variable to override this
	and specify a dynamic library from which VirtualGL will call the "real" X11
	functions.
	{nl}{nl} \
	You shouldn't need to muck with this unless something doesn't work.  However,
	it is potentially useful if one wishes to insert another X11 interposer
	between VirtualGL and the system's X11 library.

| Environment Variable | ''VGL_XVENDOR = ''__''{v}''__ |
| Summary | __''{v}''__ = a fake X11 vendor string to return when the \
	application calls ''XServerVendor()'' or ''ServerVendor()'' |
| Image Transports | All |
#OPT: hiCol=first

	Description :: Some applications expect the X11 vendor string to contain a
	particular value, which the application (sometimes erroneously) uses to
	figure out whether it is being displayed to a local or a remote X server.
	This setting allows you to fool such applications into thinking that they
	are being	displayed to a "local" X server rather than a remote one.
	{nl}{nl} \
	Refer to {ref prefix="Chapter ": Application_Recipes} for specific
	applications that require this.

** Client Settings

These settings control the VirtualGL Client, which is used only with the VGL
Transport.  ''vglclient'' is normally launched automatically from
''vglconnect'' and should not require any further configuration except in
exotic circumstances.  These settings are meant only for advanced users or
those wishing to build additional infrastructure around VirtualGL.

| Environment Variable | ''VGLCLIENT_DRAWMODE = ''__''ogl \| x11''__ |
| ''vglclient'' argument | ''-gl'' / ''-x'' |
| Summary | Specify the method used to draw pixels into the application window |
| Default Value | ''ogl'' for Solaris/SPARC systems with 3D accelerators, \
	''x11'' otherwise |
#OPT: hiCol=first

	Description :: If the client machine has a 3D accelerator, then it may be
	faster to draw pixels using OpenGL rather than using 2D (X11) commands.  This
	is particularly true of many 3D accelerators available for the Solaris/SPARC
	platform, since they are able to draw images using 24-bit pixels instead of
	the 32-bit pixels required by the X server.

| Environment Variable | ''VGLCLIENT_LISTEN = ''__''sslonly \| nossl''__ |
| ''vglclient'' argument | ''-sslonly'' / ''-nossl'' |
| Summary | Accept only unencrypted or only SSL connections from the \
	VirtualGL server |
| Default Value | Accept both SSL and unencrypted connections |
#OPT: hiCol=first

	!!! This option is available only if the VirtualGL client was built
	with OpenSSL support.

| Environment Variable | ''VGLCLIENT_PORT = ''__''{p}''__ |
| ''vglclient'' argument | ''-port ''__''{p}''__ |
| Summary | __''{p}''__ = TCP port on which to listen for unencrypted \
	connections from the VirtualGL server |
| Default Value | Automatically select a free port |
#OPT: hiCol=first

	Description :: The default behavior for ''vglclient'' is to first try
	listening on port	4242, to maintain backward compatibility with VirtualGL
	v2.0.x.  If port 4242 is not available, then ''vglclient'' will try to find
	a free port in the range of 4200-4299.  If none of those ports is available,
	then ''vglclient'' will request a free port from the operating system.
	{nl}{nl} \
	Setting this option circumvents the automatic behavior described above and
	causes ''vglclient'' to listen only on the specified TCP port.

| Environment Variable | ''VGL_PROFILE = ''__''0 \| 1''__ |
| Summary | Disable/enable profiling output |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: If profiling output is enabled, then VirtualGL will
	continuously benchmark itself and periodically print out the throughput of
	various stages in its image pipelines.
	{nl}{nl} \
	See {ref prefix="Chapter ": Perf_Measurement} for more details.

| Environment Variable | ''VGLCLIENT_SSLPORT = ''__''{p}''__ |
| ''vglclient'' argument | ''-sslport ''__''{p}''__ |
| Summary | __''{p}''__ = TCP port on which to listen for SSL \
	connections from the VirtualGL server |
| Default Value | Automatically select a free port |
#OPT: hiCol=first

	Description :: The default behavior for ''vglclient'' is to first try
	listening on port	4243, to maintain backward compatibility with VirtualGL
	v2.0.x.  If port 4243 is not available, then ''vglclient'' will try to find
	a free port in the range of 4200-4299.  If none of those ports is available,
	then ''vglclient'' will request a free port from the operating system.
	{nl}{nl} \
	Setting this option circumvents the automatic behavior described above and
	causes ''vglclient'' to listen only on the specified TCP port.

	!!! This option is available only if the VirtualGL client was built
	with OpenSSL support.

| Environment Variable | ''VGL_VERBOSE = ''__''0 \| 1''__ |
| Summary | Disable/enable verbose VirtualGL messages |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: When verbose mode is enabled, VirtualGL will reveal some of
	the decisions it makes behind the scenes, such as which code path it is using
	to decompress images, which type of X11 drawing it is using, etc.  This can
	be helpful when diagnosing performance problems.
